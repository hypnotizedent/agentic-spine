#!/usr/bin/env bash
set -euo pipefail

# Spine pre-commit hook (versioned)
#
# Guards:
# 1. Multi-agent commit guard (blocks direct commits when multiple sessions active)
# 2. Commit signing enforcement (commit_sign_required knob)
# 3. Multi-agent write policy (multi_agent_writes knob)
# 4. Terminal write-scope enforcement (role-scoped staged paths)
# 5. Hook-fast AOF hygiene checks (staged only)
# 6. Gate registry projection autopilot (gate.registry.yaml staged)
# 7. Capability metadata validation (ops/capabilities.yaml staged)

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "${ROOT:-}" ]]; then
  exit 0
fi

cd "$ROOT"

if ! command -v git >/dev/null 2>&1; then
  exit 0
fi

current_branch="$(git branch --show-current 2>/dev/null || echo detached)"

staged="$(git diff --cached --name-only --diff-filter=ACMRT 2>/dev/null || true)"

# ─── Guard 1: Multi-agent commit guard ─────────────────────
# If multiple sessions are active within TTL, block direct commits
# unless the apply-owner lock is held.

SESSIONS_DIR="$ROOT/mailroom/state/sessions"
LOCK_FILE="$ROOT/mailroom/state/apply-owner.lock"
SESSION_TTL=${SPINE_SESSION_TTL:-14400}  # 4 hours

parse_epoch_utc() {
  local ts="${1:-}"
  [[ -n "$ts" ]] || { echo 0; return; }

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$ts" <<'PY'
import sys
from datetime import datetime, timezone

ts = (sys.argv[1] or "").strip()
if not ts:
    print(0)
    raise SystemExit(0)

if ts.endswith("Z"):
    ts = ts[:-1] + "+00:00"

try:
    dt = datetime.fromisoformat(ts)
except Exception:
    print(0)
    raise SystemExit(0)

if dt.tzinfo is None:
    dt = dt.replace(tzinfo=timezone.utc)

print(int(dt.timestamp()))
PY
    return
  fi

  if date --version >/dev/null 2>&1; then
    date -d "$ts" "+%s" 2>/dev/null || echo 0
    return
  fi

  local clean_ts="${ts%%Z*}"
  clean_ts="${clean_ts%%+*}"
  date -j -f "%Y-%m-%dT%H:%M:%S" "$clean_ts" "+%s" 2>/dev/null || echo 0
}

if [[ -d "$SESSIONS_DIR" ]]; then
  NOW=$(date +%s)
  ACTIVE=0

  for sdir in "$SESSIONS_DIR"/SES-*/; do
    [[ -d "$sdir" ]] || continue
    manifest="$sdir/session.yaml"
    [[ -f "$manifest" ]] || continue

    created=$(grep '^created:' "$manifest" 2>/dev/null | sed 's/^created: *//' | tr -d '"' || echo "")
    pid=$(grep '^pid:' "$manifest" 2>/dev/null | sed 's/^pid: *//' | tr -d '"' || echo "")

    pid_alive=false
    if [[ -n "$pid" && "$pid" != "null" ]]; then
      if kill -0 "$pid" 2>/dev/null; then
        pid_alive=true
      fi
    fi

    epoch=$(parse_epoch_utc "$created")
    age=$((NOW - epoch))
    if [[ "$pid_alive" == "true" && $age -lt $SESSION_TTL ]]; then
      ACTIVE=$((ACTIVE + 1))
    fi
  done

  if [[ "$ACTIVE" -gt 1 ]]; then
    # Multi-agent mode — require apply-owner authorization
    if [[ ! -f "$LOCK_FILE" ]]; then
      if [[ "$current_branch" =~ ^worker/ ]]; then
        echo "NOTICE: multi-agent mode detected ($ACTIVE active sessions); worker branch commit allowed: $current_branch" >&2
      else
        echo "BLOCKED: main blocked, worker branches allowed." >&2
        echo "Multi-agent mode detected ($ACTIVE active sessions) and no apply-owner lock is held." >&2
        echo "" >&2
        echo "Remediation:" >&2
        echo "  1. Use proposals: ./bin/ops cap run proposals.submit \"description\"" >&2
        echo "  2. Or take apply-owner lock: ./bin/ops cap run session.start apply" >&2
        echo "" >&2
        exit 1
      fi
    fi
    # apply-owner.lock exists — commit is authorized
  fi
fi

# ─── Guard 2: Commit signing enforcement (commit_sign_required knob) ───
# Resolve policy to check if signing is required
if [[ -f "$ROOT/ops/lib/resolve-policy.sh" ]]; then
  source "$ROOT/ops/lib/resolve-policy.sh"
  resolve_policy_knobs
  if [[ "${RESOLVED_COMMIT_SIGN_REQUIRED:-false}" == "true" ]]; then
    # Check if gpg signing is configured
    sign_key="$(git config --get user.signingkey 2>/dev/null || true)"
    gpg_sign="$(git config --get commit.gpgsign 2>/dev/null || true)"
    if [[ -z "$sign_key" || "$gpg_sign" != "true" ]]; then
      echo "BLOCKED: commit_sign_required=true (policy: ${RESOLVED_POLICY_PRESET:-unknown})" >&2
      echo "Commit signing is required but not configured." >&2
      echo "" >&2
      echo "Remediation:" >&2
      echo "  git config --global user.signingkey <YOUR_KEY_ID>" >&2
      echo "  git config --global commit.gpgsign true" >&2
      echo "" >&2
      echo "Or override policy: SPINE_POLICY_PRESET=balanced" >&2
      exit 1
    fi
  fi
fi

# ─── Guard 3: Multi-agent write policy (multi_agent_writes knob) ───
# When multi_agent_writes=proposal-only, block direct commits on main
if [[ "${RESOLVED_MULTI_AGENT_WRITES:-direct}" == "proposal-only" ]]; then
  if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
    if [[ ! -f "$LOCK_FILE" ]]; then
      echo "BLOCKED: multi_agent_writes=proposal-only (policy: ${RESOLVED_POLICY_PRESET:-unknown})" >&2
      echo "Direct commits to $current_branch blocked by policy. Use proposal flow." >&2
      echo "" >&2
      echo "Remediation:" >&2
      echo "  ./bin/ops cap run proposals.submit \"description\"" >&2
      echo "Or override policy: SPINE_POLICY_PRESET=balanced" >&2
      exit 1
    fi
  fi
fi

# ─── Guard 4: Terminal write-scope enforcement ──────────────
# When terminal role context is present, staged files must remain
# within the role's declared write_scope in terminal.role.contract.yaml.

TERMINAL_ROLE_CONTRACT="$ROOT/ops/bindings/terminal.role.contract.yaml"
terminal_role="${OPS_TERMINAL_ROLE:-${SPINE_TERMINAL_ROLE:-${SPINE_TERMINAL_NAME:-${SPINE_TERMINAL_ID:-}}}}"

if [[ -n "$terminal_role" ]]; then
  if [[ ! -f "$TERMINAL_ROLE_CONTRACT" ]]; then
    echo "BLOCKED: terminal write-scope enforcement contract missing: $TERMINAL_ROLE_CONTRACT" >&2
    exit 1
  fi
  if ! command -v yq >/dev/null 2>&1; then
    echo "BLOCKED: terminal write-scope enforcement requires yq" >&2
    exit 1
  fi

  mapfile -t role_write_scope < <(yq e -r ".roles[]? | select(.id == \"$terminal_role\") | .write_scope[]?" "$TERMINAL_ROLE_CONTRACT" 2>/dev/null || true)
  if [[ "${#role_write_scope[@]}" -eq 0 ]]; then
    echo "BLOCKED: terminal role '$terminal_role' has no write_scope in $TERMINAL_ROLE_CONTRACT" >&2
    exit 1
  fi

  outside_scope=()
  while IFS= read -r path; do
    [[ -n "$path" ]] || continue
    allowed=0
    for scope in "${role_write_scope[@]}"; do
      [[ -n "$scope" && "$scope" != "null" ]] || continue
      if [[ "$scope" == */ ]]; then
        if [[ "$path" == "$scope"* ]]; then
          allowed=1
          break
        fi
      else
        if [[ "$path" == "$scope" || "$path" == "$scope/"* ]]; then
          allowed=1
          break
        fi
      fi
    done
    if [[ "$allowed" -eq 0 ]]; then
      outside_scope+=("$path")
    fi
  done <<< "$staged"

  if [[ "${#outside_scope[@]}" -gt 0 ]]; then
    echo "BLOCKED: staged files outside terminal write scope for role '$terminal_role'" >&2
    echo "Allowed write_scope:" >&2
    printf '  - %s\n' "${role_write_scope[@]}" >&2
    echo "Out-of-scope staged files:" >&2
    printf '  - %s\n' "${outside_scope[@]}" >&2
    exit 1
  fi
fi

# ─── Guard 5: Hook-fast AOF hygiene checks (staged only) ───
# Keep pre-commit lightweight while catching common AOF drift early.

if echo "$staged" | rg -q '^ops/bindings/.*\.ya?ml$'; then
  schema_audit="ops/plugins/verify/bin/schema-conventions-audit"
  if [[ ! -x "$schema_audit" ]]; then
    echo "STOP: missing schema audit runner: $schema_audit" >&2
    exit 1
  fi
  "$schema_audit" --mode staged
fi

if echo "$staged" | rg -q '^(mailroom/state/loop-scopes/.*\.scope\.md|docs/product/.*\.md)$'; then
  d145_gate="surfaces/verify/d145-aof-decomposition-vocabulary-lock.sh"
  if [[ ! -x "$d145_gate" ]]; then
    echo "STOP: missing decomposition vocabulary gate: $d145_gate" >&2
    exit 1
  fi
  "$d145_gate" --staged-only
fi

# ─── Guard 6: Gate registry projection autopilot ────────────
# When gate.registry.yaml is staged, reconcile header metadata and
# re-sync entry-surface projections so D85/D285 stay green.

if echo "$staged" | grep -qx 'ops/bindings/gate.registry.yaml'; then
  gen_header="$ROOT/bin/generators/gen-gate-registry-header.sh"
  if [[ -x "$gen_header" ]]; then
    "$gen_header" || {
      echo "STOP: gen-gate-registry-header.sh failed" >&2
      exit 1
    }
    git add ops/bindings/gate.registry.yaml
  fi

  if [[ -x "$ROOT/ops/plugins/docs/bin/docs-projection-sync" ]]; then
    "$ROOT/bin/ops" cap run docs.projection.sync >/dev/null 2>&1 || {
      echo "STOP: docs.projection.sync failed" >&2
      exit 1
    }
    for f in AGENTS.md CLAUDE.md docs/governance/generated/ENTRY_SURFACE_GATE_METADATA.md docs/governance/generated/BOOT_ENTRY_SURFACE.md; do
      [[ -f "$ROOT/$f" ]] && git add "$f"
    done
  fi
fi

# ─── Guard 7: Capability metadata validation ───────────────
# Main-branch commits are allowed. Worktrees are optional, not mandatory.
# Drift gates (spine.verify) catch problems; the pre-commit hook stays lean.

if ! echo "$staged" | grep -qx 'ops/capabilities.yaml'; then
  exit 0
fi

validator="surfaces/verify/d63-capabilities-metadata-lock.sh"
if [[ ! -f "$validator" ]]; then
  echo "STOP: missing validator: $validator" >&2
  exit 1
fi

tmp="$(mktemp)"
cleanup() { rm -f "$tmp" 2>/dev/null || true; }
trap cleanup EXIT INT TERM

git show :ops/capabilities.yaml >"$tmp" 2>/dev/null || {
  echo "STOP: could not read staged ops/capabilities.yaml" >&2
  exit 1
}

bash "$validator" --file "$tmp"
