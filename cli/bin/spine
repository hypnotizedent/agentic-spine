#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
RUNS="${ROOT}/runs"
RECEIPTS="${ROOT}/receipts/sessions"
SPINE_STATE="${ROOT}/.spine"

usage() {
  cat <<USAGE
spine: detachable front door

Commands:
  spine doctor
  spine start
  spine status
  spine run --task <path>
  spine smoke
  spine receipt --run-id <RUN_ID> --status <0|1> --note "<text>"
  spine closeout --run-id <RUN_ID>
  spine conflicts --group <GROUP>

Groups: AUTHORITY_CONFLICT, TOOLING_DRIFT, LOOPING, SECRETS_BREAK,
        PATH_CONFUSION, RECEIPT_MISSING, BUG, INCIDENT

  spine authority --domain <DOMAIN>

Domains: ENTRYPOINT, AGENT_PATHS, WORK_STATE, PILLAR_SSOTS, ARTWORK

USAGE
}

doctor() {
  echo "SPINE DOCTOR"
  echo "root: ${ROOT}"
  [[ -d "${ROOT}/cli/bin" ]] && echo "ok: cli/bin" || echo "FAIL: cli/bin"
  [[ -d "${ROOT}/engine" ]] && echo "ok: engine" || echo "FAIL: engine"
  [[ -f "${ROOT}/docs/RECEIPTS_CONTRACT.md" ]] && echo "ok: receipts contract" || echo "FAIL: receipts contract"
  command -v git >/dev/null 2>&1 && echo "ok: git" || echo "WARN: git missing"
  echo "done"
}

start() {
  local run_id="R$(date -u +%Y%m%d-%H%M%S)"
  mkdir -p "${RUNS}/${run_id}" "${RECEIPTS}/${run_id}" "${SPINE_STATE}"
  echo "${run_id}" > "${SPINE_STATE}/latest_run_id"
  cat > "${RUNS}/${run_id}/run.md" <<EOF2
# Run
RUN_ID: ${run_id}
UTC: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF2
  echo "${run_id}"
}

run_task() {
  local task=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --task) shift; task="${1:-}";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done

  [[ -n "${task}" ]] || task="tasks/canonical/receipt-grade-verify.task.md"
  [[ -f "${task}" ]] || { echo "FAIL: task file not found: ${task}"; exit 1; }

  # Always mint a fresh run for each task run (Ronny-proof MOU)
  local run_id
  run_id="$(start)"

  mkdir -p "${RUNS}/${run_id}"
  cp "${task}" "${RUNS}/${run_id}/task.txt"

  # Extract the ## REQUEST section (deterministic) into runs/<RUN_ID>/request.txt
  perl -0777 -ne 'if (s/^.*?^## REQUEST\s*\n//ms) { s/\n\s*\z//; print } else { die "FAIL: task missing ## REQUEST\n" }' \
    "${RUNS}/${run_id}/task.txt" > "${RUNS}/${run_id}/request.txt"

  local runner="${ROOT}/engine/run.sh"
  [[ -x "${runner}" ]] || { echo "FAIL: missing engine adapter: ${runner}"; exit 1; }
  local runner_output
  runner_output="$("${runner}" "${run_id}")"

  local result_path=""
  local usage_total=""
  local usage_prompt=""
  local usage_completion=""
  local provider_requested=""
  local provider_used=""
  local provider_error=""
  while IFS= read -r line; do
    case "${line}" in
      RESULT=*) result_path="${line#RESULT=}";;
      USAGE_TOTAL_TOKENS=*) usage_total="${line#*=}";;
      USAGE_PROMPT_TOKENS=*) usage_prompt="${line#*=}";;
      USAGE_COMPLETION_TOKENS=*) usage_completion="${line#*=}";;
      PROVIDER_REQUESTED=*) provider_requested="${line#*=}";;
      PROVIDER_USED=*) provider_used="${line#*=}";;
      PROVIDER_ERROR=*) provider_error="${line#*=}";;
    esac
  done <<< "$(printf '%s\n' "${runner_output}")"

  [[ -n "${result_path}" ]] || { echo "FAIL: engine did not return result path"; exit 1; }

  # Write receipt (auto) listing request/result artifacts
  local out="${RECEIPTS}/${run_id}/receipt.md"
  mkdir -p "${RECEIPTS}/${run_id}"

  local usage_section=""
  if [[ -n "${usage_total}" ]] || [[ -n "${usage_prompt}" ]] || [[ -n "${usage_completion}" ]]; then
    usage_section=$'\nUsage tokens:'
    [[ -n "${usage_total}" ]] && usage_section+=$'\n- total: '"${usage_total}"
    [[ -n "${usage_prompt}" ]] && usage_section+=$'\n- prompt: '"${usage_prompt}"
    [[ -n "${usage_completion}" ]] && usage_section+=$'\n- completion: '"${usage_completion}"
  fi

  cat > "${out}" <<EOF2
# Receipt
RUN_ID: ${run_id}
UTC timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Command invoked: spine run --task ${task}
Inputs (file paths):
- runs/${run_id}/task.txt
Outputs (file paths):
- runs/${run_id}/request.txt
- runs/${run_id}/result.txt
- receipts/sessions/${run_id}/receipt.md
Exit status: 0
Notes: v0.1 MOU (extract REQUEST + write result)
EOF2

  cat >> "${out}" <<EOF3
Provider requested: ${provider_requested:-—}
Provider used: ${provider_used:-—}
Provider error: ${provider_error:-—}
EOF3

  if [[ -n "${usage_section}" ]]; then
    cat >> "${out}" <<EOF3
${usage_section}
EOF3
  fi

  echo "RUN_ID=${run_id}"
  echo "TASK=${task}"
  echo "RESULT=${result_path}"
  [[ -n "${usage_total}" ]] && echo "USAGE_TOTAL_TOKENS=${usage_total}"
  [[ -n "${usage_prompt}" ]] && echo "USAGE_PROMPT_TOKENS=${usage_prompt}"
  [[ -n "${usage_completion}" ]] && echo "USAGE_COMPLETION_TOKENS=${usage_completion}"
  echo "${out}"
}

status() {
  local provider_default="${SPINE_ENGINE_PROVIDER:-openai}"
  local latest_run=""
  if [[ -f "${SPINE_STATE}/latest_run_id" ]]; then
    latest_run="$(cat "${SPINE_STATE}/latest_run_id")"
  fi

  local latest_receipt_dir=""
  local receipt_path=""
  if [[ -d "${RECEIPTS}" ]]; then
    latest_receipt_dir="$(ls -1t "${RECEIPTS}" 2>/dev/null | head -1 || true)"
  fi
  if [[ -n "${latest_receipt_dir}" ]]; then
    receipt_path="${RECEIPTS}/${latest_receipt_dir}/receipt.md"
  fi

  local exit_status="—"
  if [[ -f "${receipt_path}" ]]; then
    exit_status="$(grep -m1 '^Exit status:' "${receipt_path}" | cut -d: -f2- | tr -d ' ' || true)"
    [[ -z "${exit_status}" ]] && exit_status="—"
    [[ -z "${latest_run}" ]] && latest_run="${latest_receipt_dir}"
  fi

  printf 'STATUS RUN_ID=%s | provider_default=%s | receipt=%s | last_exit=%s\n' \
    "${latest_run:-—}" "${provider_default}" "${receipt_path:-—}" "${exit_status}"
  echo ""
  echo "Hint: spine conflicts --group <GROUP>"
  echo "Groups: AUTHORITY_CONFLICT | TOOLING_DRIFT | LOOPING | SECRETS_BREAK"
  echo "        PATH_CONFUSION | RECEIPT_MISSING | BUG | INCIDENT"
}

smoke() {
  local smoke_tasks=(examples/hello.task.md examples/receipt-smoke.task.md)
  for task in "${smoke_tasks[@]}"; do
    echo "Smoke: running ${task}"
    run_task --task "${task}"
  done
}

receipt() {
  local run_id="" status="" note=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --run-id) shift; run_id="${1:-}";;
      --status) shift; status="${1:-}";;
      --note) shift; note="${1:-}";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done

  [[ -n "${run_id}" ]] || { echo "FAIL: --run-id required"; exit 1; }
  [[ -n "${status}" ]] || { echo "FAIL: --status required"; exit 1; }

  local out="${RECEIPTS}/${run_id}/receipt.md"
  cat > "${out}" <<EOF2
# Receipt
RUN_ID: ${run_id}
UTC timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Command invoked: spine run
Inputs (file paths):
- runs/${run_id}/task.txt
Outputs (file paths):
- receipts/sessions/${run_id}/receipt.md
Exit status: ${status}
Notes: ${note:-—}
EOF2
  echo "${out}"
}

closeout() {
  local run_id=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --run-id) shift; run_id="${1:-}";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done

  [[ -n "${run_id}" ]] || { echo "FAIL: --run-id required"; exit 1; }
  echo "Closed: ${run_id}"
  echo "Receipt: receipts/sessions/${run_id}/receipt.md"
}

conflicts() {
  local group=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --group) shift; group="${1:-}";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done

  [[ -n "${group}" ]] || { echo "FAIL: --group required"; exit 1; }

  local json_path="${ROOT}/plugins/conflicts/out/conflicts.json"
  [[ -f "${json_path}" ]] || { echo "FAIL: conflicts.json not found at ${json_path}"; exit 1; }

  python3 - "${json_path}" "${group}" <<'PY'
import json, sys
path, group = sys.argv[1], sys.argv[2]
with open(path, "r", encoding="utf-8") as f:
    data = json.load(f)
grp = next((x for x in data.get("groups", []) if x.get("group") == group), None)
if not grp:
    available = [x.get("group") for x in data.get("groups", [])]
    print(f"FAIL: group not found: {group}", file=sys.stderr)
    print(f"Available: {available}", file=sys.stderr)
    sys.exit(1)
h = grp.get("default_header", {})
print("________________")
print(f"SESSION TYPE: {h.get('SESSION_TYPE', 'SPINE')}")
print(f"MODE: {h.get('MODE', 'TALK')}")
print(f"PIPELINE STAGE: {h.get('PIPELINE_STAGE', 'VERIFY')}")
print(f"GROUP: {grp.get('group', '')}")
print(f"DR: {h.get('DR', '—')}")
print("________________")
PY
}

authority() {
  local domain=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --domain) shift; domain="${1:-}";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done

  [[ -n "${domain}" ]] || { echo "FAIL: --domain required"; exit 1; }

  local json_path="${ROOT}/plugins/authority/out/authority.json"
  [[ -f "${json_path}" ]] || { echo "FAIL: authority.json not found at ${json_path}"; exit 1; }

  python3 - "${json_path}" "${domain}" <<'PY'
import json, sys
path, domain = sys.argv[1], sys.argv[2]
with open(path, "r", encoding="utf-8") as f:
    data = json.load(f)
dom = next((x for x in data.get("domains", []) if x.get("domain") == domain), None)
if not dom:
    available = [x.get("domain") for x in data.get("domains", [])]
    print(f"FAIL: domain not found: {domain}", file=sys.stderr)
    print(f"Available: {available}", file=sys.stderr)
    sys.exit(1)
print("________________")
print(f"DOMAIN: {dom.get('domain', '')}")
print(f"MEANING: {dom.get('meaning', '')}")
print("")
print("AUTHORITIES:")
for a in dom.get("authorities", []):
    print(f"  {a.get('what')}: {a.get('authority')}")
print("")
print("LEGACY (do not use):")
for l in dom.get("legacy", []):
    print(f"  - {l}")
print("________________")
PY
}

cmd="${1:-}"
shift || true
case "${cmd}" in
  doctor) doctor ;;
  start) start ;;
  status) status ;;
  run) run_task "$@" ;;
  smoke) smoke ;;
  receipt) receipt "$@" ;;
  closeout) closeout "$@" ;;
  conflicts) conflicts "$@" ;;
  authority) authority "$@" ;;
  ""|help|-h|--help) usage ;;
  *) echo "Unknown command: ${cmd}"; usage; exit 1 ;;
esac
