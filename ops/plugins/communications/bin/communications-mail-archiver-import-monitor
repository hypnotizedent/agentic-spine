#!/usr/bin/env bash
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
CONTRACT="${COMMUNICATIONS_STACK_CONTRACT:-$ROOT/ops/bindings/communications.stack.contract.yaml}"
SSH_BINDING="${SSH_TARGETS_FILE:-$ROOT/ops/bindings/ssh.targets.yaml}"
STATUS_BIN="${MAIL_ARCHIVER_IMPORT_STATUS_BIN:-$ROOT/ops/plugins/communications/bin/communications-mail-archiver-import-status}"

JSON=0
WRITE_STATE=1
TARGET_ID=""

fail() { echo "ERROR: $*" >&2; exit 1; }
need() { command -v "$1" >/dev/null 2>&1 || fail "missing dependency: $1"; }

need yq
need jq
[[ -f "$CONTRACT" ]] || fail "missing contract: $CONTRACT"
[[ -f "$SSH_BINDING" ]] || fail "missing ssh binding: $SSH_BINDING"
[[ -x "$STATUS_BIN" ]] || fail "missing executable status surface: $STATUS_BIN"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --target|--ssh-id) TARGET_ID="${2:?--target requires a value}"; shift 2 ;;
    --json) JSON=1; shift ;;
    --no-state-write) WRITE_STATE=0; shift ;;
    -h|--help)
      cat <<'USAGE'
Usage: communications-mail-archiver-import-monitor [--target <ssh-target-id>] [--json] [--no-state-write]

Canonical monitor wrapper for mail-archiver import status.
Enforces:
  - non-interactive machine polling target (LAN/OpenSSH)
  - BLOCKED_AUTH classification when Tailscale SSH interactive auth is required
  - single-flight lock (one checker at a time)
USAGE
      exit 0
      ;;
    *)
      fail "unknown argument: $1"
      ;;
  esac
done

if [[ -z "$TARGET_ID" ]]; then
  TARGET_ID="$(yq e -r '.mail_archiver.monitoring.machine_status_target.ssh_target // ""' "$CONTRACT")"
fi
[[ -n "$TARGET_ID" && "$TARGET_ID" != "null" ]] || fail "monitor target id missing in contract (mail_archiver.monitoring.machine_status_target.ssh_target)"

TARGET_HOST="$(yq e -r ".ssh.targets[] | select(.id == \"$TARGET_ID\") | .host // \"\"" "$SSH_BINDING")"
TARGET_USER="$(yq e -r ".ssh.targets[] | select(.id == \"$TARGET_ID\") | .user // \"\"" "$SSH_BINDING")"
TARGET_POLICY="$(yq e -r ".ssh.targets[] | select(.id == \"$TARGET_ID\") | .access_policy // \"lan_first\"" "$SSH_BINDING")"
[[ -n "$TARGET_HOST" && "$TARGET_HOST" != "null" ]] || fail "ssh target '$TARGET_ID' missing host in $SSH_BINDING"
[[ -n "$TARGET_POLICY" && "$TARGET_POLICY" != "null" ]] || TARGET_POLICY="lan_first"

REQUIRE_NONINTERACTIVE="$(yq e -r '.mail_archiver.monitoring.machine_status_target.require_noninteractive // true' "$CONTRACT")"
BLOCKED_STATE="$(yq e -r '.mail_archiver.monitoring.blocked_auth_state.lane_state // "BLOCKED_AUTH"' "$CONTRACT")"
BLOCKED_RETRY_ALLOWED="$(yq e -r '.mail_archiver.monitoring.blocked_auth_state.retry_allowed // false' "$CONTRACT")"
STATE_FILE_REL="$(yq e -r '.mail_archiver.monitoring.blocked_auth_state.state_file // "mailroom/state/communications/mail-archiver-import-monitor.state.yaml"' "$CONTRACT")"
LOCK_FILE_REL="$(yq e -r '.mail_archiver.monitoring.single_flight.lock_file // "mailroom/state/locks/mail-archiver-import-monitor.lock"' "$CONTRACT")"

STATE_FILE="$ROOT/$STATE_FILE_REL"
LOCK_FILE="$ROOT/$LOCK_FILE_REL"
mkdir -p "$(dirname "$STATE_FILE")" "$(dirname "$LOCK_FILE")"

is_tailscale_auth_challenge() {
  local text="${1:-}"
  grep -Eiq 'tailscale ssh requires an additional check|to authenticate, visit:|login\.tailscale\.com' <<<"$text"
}

classify_connectivity_error() {
  local text="${1:-}"
  if grep -Eiq 'operation timed out|connection timed out|timed out' <<<"$text"; then
    echo "connect_timeout"
    return
  fi
  if grep -Eiq 'could not resolve hostname|name or service not known' <<<"$text"; then
    echo "ssh_unreachable"
    return
  fi
  if grep -Eiq 'connection refused' <<<"$text"; then
    echo "connect_refused"
    return
  fi
  echo "status_probe_error"
}

is_private_ipv4() {
  local ip="$1"
  [[ "$ip" =~ ^10\. ]] && return 0
  [[ "$ip" =~ ^192\.168\. ]] && return 0
  if [[ "$ip" =~ ^172\.([0-9]+)\. ]]; then
    local o2="${BASH_REMATCH[1]}"
    [[ "$o2" -ge 16 && "$o2" -le 31 ]] && return 0
  fi
  return 1
}

local_ipv4_prefixes() {
  {
    if command -v ifconfig >/dev/null 2>&1; then
      ifconfig 2>/dev/null | awk '/inet /{print $2}'
    fi
    if command -v ip >/dev/null 2>&1; then
      ip -4 addr show 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1
    fi
  } | awk -F. 'NF==4 {print $1 "." $2 "." $3}' | sort -u
}

is_same_local_subnet_24() {
  local ip="$1"
  local prefix local_prefix
  prefix="$(awk -F. 'NF==4 {print $1 "." $2 "." $3}' <<<"$ip")"
  [[ -n "$prefix" ]] || return 1
  while read -r local_prefix; do
    [[ -n "$local_prefix" ]] || continue
    [[ "$local_prefix" == "$prefix" ]] && return 0
  done < <(local_ipv4_prefixes)
  return 1
}

is_off_lan_context() {
  local ip="$1"
  is_private_ipv4 "$ip" || return 1
  is_same_local_subnet_24 "$ip" && return 1
  return 0
}

write_state_yaml() {
  local lane_state="$1"
  local retry_allowed="$2"
  local reason="$3"
  local status_rc="$4"
  local raw_status="$5"
  local ts
  ts="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  cat >"$STATE_FILE" <<EOF
updated_at: "$ts"
capability: communications.mailarchiver.import.monitor
lane_state: "$lane_state"
retry_allowed: $retry_allowed
target:
  id: "$TARGET_ID"
  host: "$TARGET_HOST"
  user: "$TARGET_USER"
last_run:
  status_rc: $status_rc
  raw_status: "$raw_status"
  reason: "$reason"
EOF
}

emit_json() {
  local lane_state="$1"
  local retry_allowed="$2"
  local reason="$3"
  local status_rc="$4"
  local raw_status="$5"
  jq -n \
    --arg capability "communications.mailarchiver.import.monitor" \
    --arg generated_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    --arg lane_state "$lane_state" \
    --argjson retry_allowed "$retry_allowed" \
    --arg target_id "$TARGET_ID" \
    --arg target_host "$TARGET_HOST" \
    --arg target_user "$TARGET_USER" \
    --arg reason "$reason" \
    --arg raw_status "$raw_status" \
    --argjson status_rc "$status_rc" \
    '{
      capability: $capability,
      generated_at: $generated_at,
      lane_state: $lane_state,
      retry_allowed: $retry_allowed,
      target: {id:$target_id, host:$target_host, user:$target_user},
      status: {code:$status_rc, raw:$raw_status},
      reason: $reason
    }'
}

# Single-flight lock: avoid multiple concurrent checkers spawning duplicate auth flows.
if command -v flock >/dev/null 2>&1; then
  exec 9>"$LOCK_FILE"
  if ! flock -n 9; then
    [[ "$JSON" -eq 1 ]] && emit_json "SINGLE_FLIGHT_ACTIVE" true "lock_busy" 0 "SKIP" || \
      echo "communications.mailarchiver.import.monitor: SINGLE_FLIGHT_ACTIVE (lock busy: $LOCK_FILE)"
    exit 0
  fi
else
  LOCK_DIR="${LOCK_FILE}.d"
  if ! mkdir "$LOCK_DIR" 2>/dev/null; then
    [[ "$JSON" -eq 1 ]] && emit_json "SINGLE_FLIGHT_ACTIVE" true "lock_busy" 0 "SKIP" || \
      echo "communications.mailarchiver.import.monitor: SINGLE_FLIGHT_ACTIVE (lock busy: $LOCK_DIR)"
    exit 0
  fi
  trap 'rmdir "$LOCK_DIR" 2>/dev/null || true' EXIT INT TERM
fi

# Preflight: machine path must stay non-interactive.
if [[ "$REQUIRE_NONINTERACTIVE" == "true" && "$TARGET_HOST" =~ ^100\. ]]; then
  if [[ "$WRITE_STATE" -eq 1 ]]; then
    write_state_yaml "$BLOCKED_STATE" "$BLOCKED_RETRY_ALLOWED" "machine_target_is_tailscale_ip" 0 "BLOCKED_AUTH"
  fi
  [[ "$JSON" -eq 1 ]] && emit_json "$BLOCKED_STATE" "$BLOCKED_RETRY_ALLOWED" "machine_target_is_tailscale_ip" 0 "BLOCKED_AUTH" || \
    echo "communications.mailarchiver.import.monitor: $BLOCKED_STATE (machine target '$TARGET_ID' resolves to Tailscale IP '$TARGET_HOST')"
  exit 0
fi

set +e
STATUS_OUTPUT="$("$STATUS_BIN" --target "$TARGET_ID" --json 2>&1)"
STATUS_RC=$?
set -e

if is_tailscale_auth_challenge "$STATUS_OUTPUT"; then
  if [[ "$WRITE_STATE" -eq 1 ]]; then
    write_state_yaml "$BLOCKED_STATE" "$BLOCKED_RETRY_ALLOWED" "tailscale_interactive_auth_required" "$STATUS_RC" "BLOCKED_AUTH"
  fi
  [[ "$JSON" -eq 1 ]] && emit_json "$BLOCKED_STATE" "$BLOCKED_RETRY_ALLOWED" "tailscale_interactive_auth_required" "$STATUS_RC" "BLOCKED_AUTH" || \
    echo "communications.mailarchiver.import.monitor: $BLOCKED_STATE (tailscale interactive auth required)"
  exit 0
fi

if [[ "$STATUS_RC" -ne 0 ]]; then
  if ! jq -e . >/dev/null 2>&1 <<<"$STATUS_OUTPUT"; then
    STATUS_REASON="$(classify_connectivity_error "$STATUS_OUTPUT")"
    if [[ "$TARGET_POLICY" == "lan_first" ]] && is_off_lan_context "$TARGET_HOST" && [[ "$STATUS_REASON" == "connect_timeout" || "$STATUS_REASON" == "ssh_unreachable" ]]; then
      if [[ "$WRITE_STATE" -eq 1 ]]; then
        write_state_yaml "CONTEXT_BLOCKED" true "off_lan_connectivity_context" "$STATUS_RC" "BLOCKED_CONTEXT"
      fi
      [[ "$JSON" -eq 1 ]] && emit_json "CONTEXT_BLOCKED" true "off_lan_connectivity_context" "$STATUS_RC" "BLOCKED_CONTEXT" || \
        echo "communications.mailarchiver.import.monitor: CONTEXT_BLOCKED (off-LAN lan_first target unreachable: $TARGET_ID/$TARGET_HOST)"
      exit 0
    fi
  fi
fi

RAW_STATUS="UNKNOWN"
if jq -e '.' >/dev/null 2>&1 <<<"$STATUS_OUTPUT"; then
  RAW_STATUS="$(jq -r '.status // "UNKNOWN"' <<<"$STATUS_OUTPUT")"
fi

LANE_STATE="DEGRADED"
RETRY_ALLOWED=true
REASON="status_surface_result"
case "$RAW_STATUS" in
  OK) LANE_STATE="HEALTHY"; RETRY_ALLOWED=true ;;
  WARN) LANE_STATE="DEGRADED"; RETRY_ALLOWED=true ;;
  FAIL) LANE_STATE="FAILED"; RETRY_ALLOWED=true ;;
  *) if [[ "$STATUS_RC" -eq 0 ]]; then LANE_STATE="HEALTHY"; RAW_STATUS="OK"; else LANE_STATE="FAILED"; fi ;;
esac

if [[ "$WRITE_STATE" -eq 1 ]]; then
  write_state_yaml "$LANE_STATE" "$RETRY_ALLOWED" "$REASON" "$STATUS_RC" "$RAW_STATUS"
fi

if [[ "$JSON" -eq 1 ]]; then
  emit_json "$LANE_STATE" "$RETRY_ALLOWED" "$REASON" "$STATUS_RC" "$RAW_STATUS"
else
  echo "communications.mailarchiver.import.monitor"
  echo "target: $TARGET_ID ($TARGET_USER@$TARGET_HOST)"
  echo "lane_state: $LANE_STATE"
  echo "raw_status: $RAW_STATUS"
  echo "status_rc: $STATUS_RC"
  echo "retry_allowed: $RETRY_ALLOWED"
  echo "state_file: $STATE_FILE_REL"
fi

exit 0
