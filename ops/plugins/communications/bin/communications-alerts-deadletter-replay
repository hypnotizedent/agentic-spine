#!/usr/bin/env bash
set -euo pipefail

# communications-alerts-deadletter-replay â€” move dead-letter intents back to
# pending queue for controlled replay.
#
# Safety: mutating
# Approval: manual

ROOT="${SPINE_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
QUEUE_CONTRACT="${COMMUNICATIONS_ALERTS_QUEUE_CONTRACT:-$ROOT/ops/bindings/communications.alerts.queue.contract.yaml}"
source "$ROOT/ops/lib/runtime-paths.sh"
spine_runtime_resolve_paths

INTENT_DIR="$ROOT/mailroom/outbox/alerts/email-intents"
LIMIT=10
JSON=0

usage() {
  cat <<'USAGE'
Usage: communications-alerts-deadletter-replay [--limit <n>] [--json]

Moves dead-lettered intent artifacts back into pending queue state.

Options:
  --limit <n>    Replay up to N dead-letter intents (0 = all, default: 10)
  --json         Emit JSON summary
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --limit)
      LIMIT="${2:-10}"
      shift 2
      ;;
    --json)
      JSON=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "ERROR: unknown argument: $1" >&2
      exit 2
      ;;
  esac
done

command -v yq >/dev/null 2>&1 || { echo "ERROR: missing dependency: yq" >&2; exit 1; }
command -v jq >/dev/null 2>&1 || { echo "ERROR: missing dependency: jq" >&2; exit 1; }
[[ -f "$QUEUE_CONTRACT" ]] || { echo "ERROR: missing queue contract: $QUEUE_CONTRACT" >&2; exit 1; }
[[ "$LIMIT" =~ ^[0-9]+$ ]] || { echo "ERROR: --limit must be numeric" >&2; exit 2; }

expand_path() {
  local p="$1"
  p="${p//\$SPINE_OUTBOX/$SPINE_OUTBOX}"
  echo "$p"
}

dead_letter_dir_raw="$(yq -r '.retry_policy.dead_letter_dir // "$SPINE_OUTBOX/alerts/email-intents-dead-letter"' "$QUEUE_CONTRACT")"
DEAD_LETTER_DIR="$(expand_path "$dead_letter_dir_raw")"

mkdir -p "$INTENT_DIR" "$DEAD_LETTER_DIR"

selected=0
replayed=0
results='[]'
now_iso="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

while IFS= read -r src; do
  [[ -n "$src" ]] || continue
  if [[ "$LIMIT" -gt 0 && "$selected" -ge "$LIMIT" ]]; then
    break
  fi
  selected=$((selected + 1))

  base="$(basename "$src")"
  target="$INTENT_DIR/$base"
  if [[ -e "$target" ]]; then
    stem="${base%.yaml}"
    target="$INTENT_DIR/${stem}.replay.$(date -u +%Y%m%dT%H%M%SZ).$RANDOM.yaml"
  fi

  intent_id="$(yq -r '.intent_id // ""' "$src" 2>/dev/null || echo "")"

  yq -i \
    ".flush_status = \"pending\" | .attempts = 0 | .replayed_at = \"$now_iso\" | .replay_source = \"dead-letter\" | .replay_source_path = \"$src\" | .last_error = \"\" | del(.dead_lettered_at, .dead_letter_reason, .next_retry_at, .retry_delay_seconds, .flushed_at, .delivery_event_id, .last_attempt_at)" \
    "$src"

  mv "$src" "$target"
  replayed=$((replayed + 1))
  results="$(echo "$results" | jq -c --arg intent_id "$intent_id" --arg source "$src" --arg target "$target" '. + [{intent_id:$intent_id,source:$source,target:$target,status:"replayed"}]')"
done < <(find "$DEAD_LETTER_DIR" -name '*.yaml' -type f 2>/dev/null | sort)

if [[ "$JSON" -eq 1 ]]; then
  jq -n \
    --arg capability "communications.alerts.deadletter.replay" \
    --arg status "ok" \
    --arg generated_at "$now_iso" \
    --argjson selected "$selected" \
    --argjson replayed "$replayed" \
    --argjson results "$results" \
    '{
      capability: $capability,
      status: $status,
      generated_at: $generated_at,
      data: {
        selected: $selected,
        replayed: $replayed,
        results: $results
      }
    }'
  exit 0
fi

echo "communications.alerts.deadletter.replay"
echo "selected: $selected"
echo "replayed: $replayed"
echo "$results" | jq -r '.[] | "  \(.intent_id) \(.status) \(.target)"'
