#!/usr/bin/env bash
# services-health-status - Read-only HTTP health probe for declared services
#
# No auth headers printed. No verbose curl. No mutations.
# STOP=2 on preconditions (missing binding, yq, curl).
#
# Usage:
#   services-health-status                 # check all endpoints
#   services-health-status <id>            # check specific endpoint id
#   services-health-status --id <id>       # check specific endpoint id
#   services-health-status --host <host>   # check endpoints for one host
#   services-health-status --id <id> --host <host>
#   services-health-status [filters...] --strict-exit

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
BINDING="$SPINE_ROOT/ops/bindings/services.health.yaml"

stop(){ echo "STOP (2): $*" >&2; exit 2; }

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v curl >/dev/null 2>&1 || stop "missing dependency: curl"
[[ -f "$BINDING" ]] || stop "missing binding: $BINDING"

FILTER_ID=""
FILTER_HOST=""
STRICT_EXIT=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --id)
      [[ $# -ge 2 ]] || stop "--id requires a value"
      FILTER_ID="$2"
      shift 2
      ;;
    --host)
      [[ $# -ge 2 ]] || stop "--host requires a value"
      FILTER_HOST="$2"
      shift 2
      ;;
    --strict-exit)
      STRICT_EXIT=1
      shift
      ;;
    -h|--help)
      cat <<'EOF'
Usage:
  services-health-status
  services-health-status <id>
  services-health-status --id <id>
  services-health-status --host <host>
  services-health-status --id <id> --host <host>

Flags:
  --strict-exit  Exit non-zero when any checked endpoint is not OK.
EOF
      exit 0
      ;;
    *)
      if [[ -z "$FILTER_ID" ]]; then
        FILTER_ID="$1"
      else
        stop "unknown argument: $1"
      fi
      shift
      ;;
  esac
done

DEF_CONNECT="$(yq -r '.defaults.connect_timeout_sec // 5' "$BINDING")"
DEF_MAX="$(yq -r '.defaults.max_time_sec // 10' "$BINDING")"

COUNT="$(yq -r '.endpoints | length' "$BINDING" 2>/dev/null || echo 0)"
[[ "$COUNT" -gt 0 ]] || stop "no endpoints configured in $BINDING"

echo "services.health.status"
echo "binding: $BINDING"
echo "endpoints: $COUNT"
echo
printf "%-16s %-16s %-8s %-10s %s\n" "ID" "HOST" "STATUS" "TIME" "NOTE"

fail=0
checked=0

for i in $(seq 0 $((COUNT-1))); do
  id="$(yq -r ".endpoints[$i].id" "$BINDING")"
  host="$(yq -r ".endpoints[$i].host" "$BINDING")"
  url="$(yq -r ".endpoints[$i].url" "$BINDING")"
  expect="$(yq -r ".endpoints[$i].expect // 200" "$BINDING")"
  # NOTE: yq `//` coalesces on null OR false, so don't use it for booleans.
  enabled="$(yq -r ".endpoints[$i].enabled" "$BINDING")"
  [[ -z "$enabled" || "$enabled" == "null" ]] && enabled="true"

  if [[ -n "$FILTER_ID" && "$id" != "$FILTER_ID" ]]; then
    continue
  fi
  if [[ -n "$FILTER_HOST" && "$host" != "$FILTER_HOST" ]]; then
    continue
  fi

  checked=$((checked + 1))

  if [[ "$enabled" != "true" ]]; then
    printf "%-16s %-16s %-8s %-10s %s\n" "$id" "$host" "SKIP" "-" "disabled"
    continue
  fi

  # Time the request (ms)
  start_ms="$(python3 -c 'import time; print(int(time.time()*1000))')"

  set +e
  http_code="$(curl -sS -o /dev/null -w "%{http_code}" \
    --connect-timeout "$DEF_CONNECT" \
    --max-time "$DEF_MAX" \
    "$url" 2>/dev/null)"
  curl_exit=$?
  set -e

  end_ms="$(python3 -c 'import time; print(int(time.time()*1000))')"
  dur_ms=$((end_ms - start_ms))

  # Accept either a single expected code (e.g. 200) or comma-separated set
  # (e.g. "401,403") for endpoints that legitimately vary by route/context.
  expect_normalized="$(echo "$expect" | tr -d '[:space:]')"
  code_ok=0
  IFS=',' read -r -a expected_codes <<< "$expect_normalized"
  for expected_code in "${expected_codes[@]}"; do
    if [[ -n "$expected_code" && "$http_code" == "$expected_code" ]]; then
      code_ok=1
      break
    fi
  done

  # Check HTTP code first (even if curl reported non-zero exit for HTTP errors)
  if [[ "$code_ok" -eq 1 ]]; then
    printf "%-16s %-16s %-8s %-10s %s\n" "$id" "$host" "OK" "${dur_ms}ms" ""
  elif [[ "$curl_exit" -eq 0 ]]; then
    printf "%-16s %-16s %-8s %-10s %s\n" "$id" "$host" "DEGRADED" "${dur_ms}ms" "http=$http_code expected=$expect_normalized"
    fail=1
  elif [[ "$curl_exit" -eq 28 ]]; then
    printf "%-16s %-16s %-8s %-10s %s\n" "$id" "$host" "TIMEOUT" "${dur_ms}ms" "connect/max timeout"
    fail=1
  elif [[ "$curl_exit" -eq 7 ]]; then
    printf "%-16s %-16s %-8s %-10s %s\n" "$id" "$host" "REFUSED" "${dur_ms}ms" "connection refused"
    fail=1
  else
    printf "%-16s %-16s %-8s %-10s %s\n" "$id" "$host" "FAIL" "${dur_ms}ms" "http=$http_code curl_exit=$curl_exit"
    fail=1
  fi
done

echo

if [[ "$checked" -eq 0 && ( -n "$FILTER_ID" || -n "$FILTER_HOST" ) ]]; then
  echo "STOP (2): no endpoints matched filter(s): id='${FILTER_ID:-*}' host='${FILTER_HOST:-*}'"
  exit 2
fi

# Status-style capabilities should report issues but not fail the capability run.
# Drift gates can enforce policy separately; operators still get reason-coded output.
if [[ "$fail" -eq 1 ]]; then
  echo "status: FAIL (some endpoints unhealthy)"
else
  echo "status: OK (all endpoints healthy)"
fi

if [[ "$STRICT_EXIT" -eq 1 && "$fail" -eq 1 ]]; then
  exit 1
fi

exit 0
