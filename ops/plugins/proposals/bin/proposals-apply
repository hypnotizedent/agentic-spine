#!/bin/bash
set -euo pipefail

# proposals-apply: Apply a change proposal to the repo (non-interactive).
#
# Notes:
# - `ops cap run proposals.apply` already enforces `approval: manual` ("Type 'yes' to proceed").
# - This script must not prompt for additional input, or piping `yes` into ops will deadlock.
# - Write admission is mandatory and cannot be bypassed.
#
# Usage:
#   proposals-apply [--dry-run] CP-<name>

usage() {
  cat <<'USAGE'
Usage:
  proposals-apply [--dry-run] CP-<name>

Applies the proposal from:
  mailroom/outbox/proposals/<CP-...>/

Requires:
  - clean git working tree (abort otherwise)
  - manifest.yaml contains changes with action/path/reason
  - for create/modify: proposal/files/<path> exists

Admission controller (mandatory):
  - verify.core.run equivalent
  - path-scoped verify.domain.run <domain> --force routing
  - workbench AOF contract checks (when workbench paths are present)
  - SSOT schema convention checks for changed ops/bindings YAML files
  - vertical integration admission matrix checks for mint pricing/suppliers module touches
  - loop/gap linkage checks

Policy:
  - P0/P1 findings block apply
  - P2 findings warn-only
USAGE
}

need_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "ERROR: required command missing: $cmd" >&2
    exit 1
  }
}

contains_value() {
  local needle="$1"
  shift || true
  local item
  for item in "$@"; do
    [[ "$item" == "$needle" ]] && return 0
  done
  return 1
}

validate_path() {
  local p="$1"
  if [[ -z "$p" ]]; then return 1; fi
  if [[ "$p" == /* ]]; then return 1; fi
  if [[ "$p" == *".."* ]]; then return 1; fi
  if [[ "$p" == *"~"* ]]; then return 1; fi
  if [[ "$p" == *$'\n'* ]]; then return 1; fi
  return 0
}

normalize_action() {
  local action="$1"
  case "$action" in
    create|created)
      echo "create"
      ;;
    modify|update|edit|api-write)
      echo "modify"
      ;;
    delete|remove)
      echo "delete"
      ;;
    *)
      echo "$action"
      ;;
  esac
}

normalize_workbench_path() {
  local p="$1"
  case "$p" in
    "$WORKBENCH_ROOT"/*)
      echo "$p"
      ;;
    /Users/*/code/workbench/*)
      echo "$p"
      ;;
    workbench/*)
      echo "$HOME/code/$p"
      ;;
    ../workbench/*)
      echo "$HOME/code/${p#../}"
      ;;
    *)
      echo ""
      ;;
  esac
}

normalize_contract_glob() {
  local pattern="${1:-}"
  pattern="${pattern#./}"
  # Bash [[ pattern matching ]] treats '*' as multi-segment wildcard already.
  pattern="${pattern//\*\*/\*}"
  printf '%s\n' "$pattern"
}

path_matches_contract_glob() {
  local path="$1"
  local glob_raw="$2"
  local glob
  glob="$(normalize_contract_glob "$glob_raw")"
  [[ -n "$glob" ]] || return 1
  [[ "$path" == $glob ]]
}

admission_add_finding() {
  local severity="$1"
  local code="$2"
  local detail="$3"
  ADMISSION_FINDINGS+=("$severity|$code|$detail")
}

severity_blocks_apply() {
  local severity="$1"
  contains_value "$severity" "${ADMISSION_BLOCK_ON[@]}"
}

run_domain_routing_admission() {
  local core_output core_rc
  echo "Admission check: verify core gates"
  set +e
  core_output="$($VERIFY_TOPOLOGY_BIN core 2>&1)"
  core_rc=$?
  set -e
  echo "$core_output"
  if (( core_rc != 0 )); then
    admission_add_finding "P0" "verify_core" "verify.core.run equivalent failed"
  fi

  local recommend_output recommend_rc
  local -a recommend_cmd
  local -a recommended_domains=()
  local path
  recommend_cmd=("$VERIFY_TOPOLOGY_BIN" recommend --json)
  # Always include proposal capability context so loop_gap governance routes are evaluated.
  recommend_cmd+=(--capability "proposals.apply")
  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    recommend_cmd+=(--path "$path")
  done < "$changes_tmp"

  echo "Admission check: resolve affected domains"
  set +e
  recommend_output="$(${recommend_cmd[@]} 2>&1)"
  recommend_rc=$?
  set -e

  if (( recommend_rc != 0 )); then
    echo "$recommend_output"
    admission_add_finding "P1" "verify_route" "verify.route.recommend equivalent failed"
    return
  fi

  while IFS= read -r domain; do
    [[ -n "$domain" ]] || continue
    if ! contains_value "$domain" "${recommended_domains[@]:-}"; then
      recommended_domains+=("$domain")
    fi
  done < <(jq -r '.recommended_domains[]?' <<< "$recommend_output" 2>/dev/null || true)

  if (( ${#recommended_domains[@]} == 0 )); then
    recommended_domains=("core")
  fi

  echo "Admission routed domains: ${recommended_domains[*]}"

  local domain_output domain_rc domain
  for domain in "${recommended_domains[@]}"; do
    [[ "$domain" == "core" ]] && continue
    echo "Admission check: verify domain '$domain'"
    set +e
    domain_output="$($VERIFY_TOPOLOGY_BIN domain "$domain" --force 2>&1)"
    domain_rc=$?
    set -e
    echo "$domain_output"
    if (( domain_rc != 0 )); then
      admission_add_finding "P0" "verify_domain" "verify.domain.run $domain --force failed"
    fi
  done
}

run_workbench_contract_admission() {
  local -a wb_paths=()
  local normalized path action reason

  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    normalized="$(normalize_workbench_path "$path")"
    [[ -n "$normalized" ]] || continue
    if ! contains_value "$normalized" "${wb_paths[@]:-}"; then
      wb_paths+=("$normalized")
    fi
  done < "$changes_tmp"

  if (( ${#wb_paths[@]} == 0 )); then
    return
  fi

  if [[ ! -d "$WORKBENCH_ROOT" ]]; then
    admission_add_finding "P1" "workbench_preflight" "workbench path required but WORKBENCH_ROOT is unreachable: $WORKBENCH_ROOT"
    return
  fi

  if [[ ! -x "$WORKBENCH_AOF_CHECKER" ]]; then
    admission_add_finding "P1" "workbench_preflight" "workbench AOF checker missing: $WORKBENCH_AOF_CHECKER"
    return
  fi

  echo "Admission check: workbench AOF contract"
  local -a checker_args=()
  checker_args=(--mode all --format text)
  for path in "${wb_paths[@]}"; do
    checker_args+=(--changed-files "$path")
  done

  local preflight_output preflight_rc summary_line p0 p1 p2 parsed_summary
  set +e
  preflight_output="$($WORKBENCH_AOF_CHECKER ${checker_args[@]} 2>&1)"
  preflight_rc=$?
  set -e
  echo "$preflight_output"

  summary_line="$(grep -E '^summary:' <<< "$preflight_output" | tail -1 || true)"
  p0=0
  p1=0
  p2=0
  parsed_summary=0
  if [[ "$summary_line" =~ P0=([0-9]+)[[:space:]]+P1=([0-9]+)[[:space:]]+P2=([0-9]+) ]]; then
    parsed_summary=1
    p0="${BASH_REMATCH[1]}"
    p1="${BASH_REMATCH[2]}"
    p2="${BASH_REMATCH[3]}"
    (( p0 > 0 )) && admission_add_finding "P0" "workbench_aof" "workbench checker reported P0 findings: $p0"
    (( p1 > 0 )) && admission_add_finding "P1" "workbench_aof" "workbench checker reported P1 findings: $p1"
    (( p2 > 0 )) && admission_add_finding "P2" "workbench_aof" "workbench checker reported P2 findings: $p2"
  elif (( preflight_rc != 0 )); then
    admission_add_finding "P1" "workbench_aof" "workbench checker failed without parseable severity summary"
  fi

  if (( preflight_rc != 0 && parsed_summary == 0 )); then
    admission_add_finding "P1" "workbench_aof" "workbench checker exited non-zero"
  fi
}

run_ssot_schema_conventions_admission() {
  local schema_contract="$SCHEMA_CONVENTIONS_CONTRACT"
  local touch_to_fix
  local -a disallowed_keys=()
  local -a discouraged_keys=()
  local -a allowed_status=()
  local -a allowed_lifecycle=()

  local -a binding_paths=()
  local action path reason
  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    [[ "$action" == "create" || "$action" == "modify" ]] || continue
    case "$path" in
      ops/bindings/*.yml|ops/bindings/*.yaml)
        if ! contains_value "$path" "${binding_paths[@]:-}"; then
          binding_paths+=("$path")
        fi
        ;;
    esac
  done < "$changes_tmp"

  if (( ${#binding_paths[@]} == 0 )); then
    return
  fi

  if [[ ! -f "$schema_contract" ]]; then
    admission_add_finding "P1" "schema_conventions" "missing schema conventions contract: $schema_contract"
    return
  fi

  touch_to_fix="$(yq e -r '.legacy_alias_rules.touch_to_fix_required // true' "$schema_contract" 2>/dev/null || echo true)"

  while IFS= read -r path; do
    [[ -n "$path" ]] && disallowed_keys+=("$path")
  done < <(yq e -r '.field_rules.disallowed_alias_keys[]?' "$schema_contract" 2>/dev/null || true)

  while IFS= read -r path; do
    [[ -n "$path" ]] && discouraged_keys+=("$path")
  done < <(yq e -r '.field_rules.discouraged_alias_keys[]?' "$schema_contract" 2>/dev/null || true)

  while IFS= read -r path; do
    [[ -n "$path" ]] && allowed_status+=("$path")
  done < <(yq e -r '.status_rules.allowed_values[]?' "$schema_contract" 2>/dev/null || true)

  while IFS= read -r path; do
    [[ -n "$path" ]] && allowed_lifecycle+=("$path")
  done < <(yq e -r '.status_rules.lifecycle_values[]?' "$schema_contract" 2>/dev/null || true)

  echo "Admission check: SSOT schema conventions"

  local rel src key status lifecycle
  local -a file_keys=()
  local -a file_allowed_alias=()
  local -a status_values=()
  local -a lifecycle_values=()

  for rel in "${binding_paths[@]}"; do
    src="$files_dir/$rel"

    if [[ ! -f "$src" ]]; then
      admission_add_finding "P0" "schema_conventions" "missing proposal file for binding change: $rel"
      continue
    fi

    if ! yq e '.' "$src" >/dev/null 2>&1; then
      admission_add_finding "P0" "schema_conventions" "invalid YAML in proposal file: $rel"
      continue
    fi

    file_keys=()
    while IFS= read -r key; do
      [[ -n "$key" ]] && file_keys+=("$key")
    done < <(yq e '.. | select(tag == "!!map") | keys | .[]' "$src" 2>/dev/null | awk 'NF && !seen[$0]++')

    file_allowed_alias=()
    while IFS= read -r key; do
      [[ -n "$key" ]] && file_allowed_alias+=("$key")
    done < <(yq e -r ".legacy_alias_rules.legacy_exceptions[] | select(.file == \"$rel\") | .allowed_keys[]?" "$schema_contract" 2>/dev/null || true)

    for key in "${disallowed_keys[@]:-}"; do
      [[ -n "$key" ]] || continue
      if contains_value "$key" "${file_keys[@]:-}"; then
        if contains_value "$key" "${file_allowed_alias[@]:-}"; then
          if [[ "$touch_to_fix" == "true" ]]; then
            admission_add_finding "P1" "schema_conventions" "$rel uses legacy-excepted key '$key' in touched file (touch_and_fix enforced)"
          else
            admission_add_finding "P2" "schema_conventions" "$rel uses legacy-excepted key '$key'"
          fi
        else
          admission_add_finding "P1" "schema_conventions" "$rel includes disallowed alias key '$key'"
        fi
      fi
    done

    for key in "${discouraged_keys[@]:-}"; do
      [[ -n "$key" ]] || continue
      if contains_value "$key" "${file_keys[@]:-}"; then
        admission_add_finding "P2" "schema_conventions" "$rel includes discouraged key '$key'"
      fi
    done

    status_values=()
    while IFS= read -r status; do
      [[ -n "$status" && "$status" != "null" ]] && status_values+=("$status")
    done < <(yq e '.. | select(tag == "!!map" and has("status")) | .status' "$src" 2>/dev/null || true)

    if (( ${#status_values[@]} > 0 )); then
      for status in "${status_values[@]}"; do
        [[ -n "$status" && "$status" != "null" ]] || continue
        if ! contains_value "$status" "${allowed_status[@]:-}"; then
          admission_add_finding "P1" "schema_conventions" "$rel includes non-canonical status value '$status'"
        fi
      done
    fi

    lifecycle_values=()
    while IFS= read -r lifecycle; do
      [[ -n "$lifecycle" && "$lifecycle" != "null" ]] && lifecycle_values+=("$lifecycle")
    done < <(yq e '.. | select(tag == "!!map" and has("lifecycle")) | .lifecycle' "$src" 2>/dev/null || true)

    if (( ${#lifecycle_values[@]} > 0 )); then
      for lifecycle in "${lifecycle_values[@]}"; do
        [[ -n "$lifecycle" && "$lifecycle" != "null" ]] || continue
        if ! contains_value "$lifecycle" "${allowed_lifecycle[@]:-}"; then
          admission_add_finding "P1" "schema_conventions" "$rel includes non-canonical lifecycle value '$lifecycle'"
        fi
      done
    fi
  done
}

run_vertical_integration_admission() {
  local contract="$VERTICAL_INTEGRATION_CONTRACT"
  local enabled matrix_count idx
  local action path reason
  local rule_id matched trigger_glob companion_id companion_glob
  local -a changed_paths=()
  local -a triggered_rules=()
  local -a required_companions=()

  if [[ ! -f "$contract" ]]; then
    admission_add_finding "P1" "vertical_integration_contract" "missing vertical integration admission contract: $contract"
    return
  fi

  enabled="$(yq e -r '.admission.enabled // true' "$contract" 2>/dev/null || echo true)"
  [[ "$enabled" == "true" ]] || return

  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    if ! contains_value "$path" "${changed_paths[@]:-}"; then
      changed_paths+=("$path")
    fi
  done < "$changes_tmp"

  if (( ${#changed_paths[@]} == 0 )); then
    return
  fi

  matrix_count="$(yq e '.admission.required_change_matrix | length' "$contract" 2>/dev/null || echo 0)"
  [[ "$matrix_count" =~ ^[0-9]+$ ]] || matrix_count=0
  if (( matrix_count == 0 )); then
    return
  fi

  for ((idx=0; idx<matrix_count; idx++)); do
    matched=0
    rule_id="$(yq e -r ".admission.required_change_matrix[$idx].id // \"rule_$idx\"" "$contract" 2>/dev/null || echo "rule_$idx")"

    while IFS= read -r trigger_glob; do
      [[ -n "$trigger_glob" ]] || continue
      for path in "${changed_paths[@]}"; do
        if path_matches_contract_glob "$path" "$trigger_glob"; then
          matched=1
          break
        fi
      done
      (( matched == 1 )) && break
    done < <(yq e -r ".admission.required_change_matrix[$idx].touch_any[]?" "$contract" 2>/dev/null || true)

    if (( matched == 1 )); then
      if ! contains_value "$rule_id" "${triggered_rules[@]:-}"; then
        triggered_rules+=("$rule_id")
      fi

      while IFS= read -r companion_id; do
        [[ -n "$companion_id" ]] || continue
        if ! contains_value "$companion_id" "${required_companions[@]:-}"; then
          required_companions+=("$companion_id")
        fi
      done < <(yq e -r ".admission.required_change_matrix[$idx].required_companions[]?" "$contract" 2>/dev/null || true)
    fi
  done

  if (( ${#triggered_rules[@]} == 0 )); then
    return
  fi

  echo "Admission check: vertical integration matrix (${triggered_rules[*]})"

  local loop_required loop_severity
  local changes_required changes_severity change_count
  loop_required="$(yq e -r '.admission.manifest_requirements.loop_id.required // true' "$contract" 2>/dev/null || echo true)"
  loop_severity="$(yq e -r '.admission.manifest_requirements.loop_id.severity // "P0"' "$contract" 2>/dev/null || echo P0)"
  if [[ "$loop_required" == "true" && -z "${loop_id:-}" ]]; then
    admission_add_finding "$loop_severity" "vertical_loop_id" "vertical integration trigger matched but manifest loop_id is missing"
  fi

  changes_required="$(yq e -r '.admission.manifest_requirements.changes_non_empty.required // true' "$contract" 2>/dev/null || echo true)"
  changes_severity="$(yq e -r '.admission.manifest_requirements.changes_non_empty.severity // "P0"' "$contract" 2>/dev/null || echo P0)"
  change_count="$(yq e '.changes | length' "$manifest" 2>/dev/null || echo 0)"
  [[ "$change_count" =~ ^[0-9]+$ ]] || change_count=0
  if [[ "$changes_required" == "true" && "$change_count" -eq 0 ]]; then
    admission_add_finding "$changes_severity" "vertical_changes" "vertical integration trigger matched but manifest changes list is empty"
  fi

  local override_root status_key reason_key status_value reason_required invalid_override_severity
  override_root="$(yq e -r '.admission.manifest_requirements.not_required_override.root_key // "vertical_integration.surface_overrides"' "$contract" 2>/dev/null || echo "vertical_integration.surface_overrides")"
  status_key="$(yq e -r '.admission.manifest_requirements.not_required_override.status_key // "status"' "$contract" 2>/dev/null || echo status)"
  reason_key="$(yq e -r '.admission.manifest_requirements.not_required_override.reason_key // "reason"' "$contract" 2>/dev/null || echo reason)"
  status_value="$(yq e -r '.admission.manifest_requirements.not_required_override.status_value // "not-required"' "$contract" 2>/dev/null || echo "not-required")"
  reason_required="$(yq e -r '.admission.manifest_requirements.not_required_override.reason_required // true' "$contract" 2>/dev/null || echo true)"
  invalid_override_severity="$(yq e -r '.admission.manifest_requirements.not_required_override.severity_when_invalid // "P1"' "$contract" 2>/dev/null || echo P1)"

  local companion_severity companion_description
  local companion_status companion_reason
  local companion_path_summary
  local -a companion_globs=()
  local satisfied_by_change

  for companion_id in "${required_companions[@]}"; do
    companion_severity="$(yq e -r ".companion_surfaces.\"$companion_id\".severity // \"P1\"" "$contract" 2>/dev/null || echo P1)"
    companion_description="$(yq e -r ".companion_surfaces.\"$companion_id\".description // \"\"" "$contract" 2>/dev/null || true)"

    companion_globs=()
    companion_path_summary=""
    while IFS= read -r companion_glob; do
      [[ -n "$companion_glob" ]] || continue
      companion_globs+=("$companion_glob")
      if [[ -n "$companion_path_summary" ]]; then
        companion_path_summary+=", "
      fi
      companion_path_summary+="$companion_glob"
    done < <(yq e -r ".companion_surfaces.\"$companion_id\".satisfy_any_path[]?" "$contract" 2>/dev/null || true)

    if (( ${#companion_globs[@]} == 0 )); then
      admission_add_finding "P1" "vertical_${companion_id}_contract" "contract companion '$companion_id' has no satisfy_any_path rules"
      continue
    fi

    satisfied_by_change=0
    for path in "${changed_paths[@]}"; do
      for companion_glob in "${companion_globs[@]}"; do
        if path_matches_contract_glob "$path" "$companion_glob"; then
          satisfied_by_change=1
          break
        fi
      done
      (( satisfied_by_change == 1 )) && break
    done

    if (( satisfied_by_change == 1 )); then
      continue
    fi

    companion_status="$(yq e -r ".${override_root}.\"$companion_id\".${status_key} // \"\"" "$manifest" 2>/dev/null || true)"
    companion_reason="$(yq e -r ".${override_root}.\"$companion_id\".${reason_key} // \"\"" "$manifest" 2>/dev/null || true)"

    if [[ "$companion_status" == "$status_value" ]]; then
      if [[ "$reason_required" == "true" ]]; then
        if [[ -n "$companion_reason" && "$companion_reason" != "null" ]]; then
          continue
        fi
        admission_add_finding "$invalid_override_severity" "vertical_${companion_id}_override" "${override_root}.\"$companion_id\".${status_key}=${status_value} requires non-empty ${reason_key}"
        continue
      fi
      continue
    fi

    admission_add_finding "$companion_severity" "vertical_${companion_id}" "vertical integration trigger(s) [${triggered_rules[*]}] require companion '$companion_id' (${companion_description}). Update one of: ${companion_path_summary}; or set manifest ${override_root}.\"$companion_id\".{${status_key}: ${status_value}, ${reason_key}: <reason>}"
  done
}

run_loop_gap_linkage_admission() {
  local scope_file loop_status gap_rel gap_src linked_count existing_linked_count

  echo "Admission check: loop/gap linkage"

  if [[ -z "${loop_id:-}" ]]; then
    admission_add_finding "P1" "loop_gap_linkage" "manifest loop_id is required for mutating proposal apply"
    return
  fi

  scope_file="$LOOP_SCOPES_DIR/$loop_id.scope.md"
  if [[ ! -f "$scope_file" ]]; then
    admission_add_finding "P1" "loop_gap_linkage" "loop scope file missing for loop_id=$loop_id"
    return
  fi

  loop_status="$(awk '/^status:/{print $2; exit}' "$scope_file" 2>/dev/null || true)"
  case "$loop_status" in
    active|planned|draft)
      ;;
    closed|done|archived)
      admission_add_finding "P1" "loop_gap_linkage" "loop_id=$loop_id is not active (status=$loop_status)"
      ;;
    *)
      admission_add_finding "P2" "loop_gap_linkage" "loop_id=$loop_id has unknown scope status '${loop_status:-unknown}'"
      ;;
  esac

  gap_rel="ops/bindings/operational.gaps.yaml"
  if awk -F'\t' -v p="$gap_rel" '$2 == p { found=1 } END { exit(found ? 0 : 1) }' "$changes_tmp"; then
    gap_src="$files_dir/$gap_rel"
    if [[ ! -f "$gap_src" ]]; then
      admission_add_finding "P1" "loop_gap_linkage" "proposal changes $gap_rel but staged file is missing"
      return
    fi

    linked_count="$(yq e "[.gaps[] | select(.status == \"open\" and (.parent_loop // \"\") == \"$loop_id\")] | length" "$gap_src" 2>/dev/null || echo 0)"
    if [[ "$linked_count" =~ ^[0-9]+$ ]] && (( linked_count == 0 )); then
      admission_add_finding "P1" "loop_gap_linkage" "proposal touches operational.gaps.yaml but no open gap is linked to loop_id=$loop_id"
    fi
  else
    existing_linked_count="$(yq e "[.gaps[] | select(.status == \"open\" and (.parent_loop // \"\") == \"$loop_id\")] | length" "$GAPS_FILE" 2>/dev/null || echo 0)"
    if [[ "$existing_linked_count" =~ ^[0-9]+$ ]] && (( existing_linked_count == 0 )); then
      admission_add_finding "P2" "loop_gap_linkage" "no open gaps currently linked to loop_id=$loop_id"
    fi
  fi
}

load_admission_policy() {
  ADMISSION_BLOCK_ON=()
  ADMISSION_WARN_ONLY=()

  if [[ -f "$PROPOSALS_LIFECYCLE_CONTRACT" ]]; then
    while IFS= read -r sev; do
      [[ -n "$sev" ]] && ADMISSION_BLOCK_ON+=("$sev")
    done < <(yq e -r '.admission_controller.block_on_severity[]?' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || true)

    while IFS= read -r sev; do
      [[ -n "$sev" ]] && ADMISSION_WARN_ONLY+=("$sev")
    done < <(yq e -r '.admission_controller.warn_only_severity[]?' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || true)
  fi

  if (( ${#ADMISSION_BLOCK_ON[@]} == 0 )); then
    ADMISSION_BLOCK_ON=("P0" "P1")
  fi
  if (( ${#ADMISSION_WARN_ONLY[@]} == 0 )); then
    ADMISSION_WARN_ONLY=("P2")
  fi
}

emit_admission_summary_and_enforce() {
  local sev code detail
  local p0=0 p1=0 p2=0
  local blockers=0

  echo ""
  echo "Admission controller findings:"
  if (( ${#ADMISSION_FINDINGS[@]} == 0 )); then
    echo "  - none"
    echo "Admission summary: P0=0 P1=0 P2=0 total=0"
    return 0
  fi

  for entry in "${ADMISSION_FINDINGS[@]}"; do
    IFS='|' read -r sev code detail <<< "$entry"
    case "$sev" in
      P0) p0=$((p0 + 1)) ;;
      P1) p1=$((p1 + 1)) ;;
      P2) p2=$((p2 + 1)) ;;
    esac
    printf '  - %-2s %-20s %s\n' "$sev" "$code" "$detail"
    if severity_blocks_apply "$sev"; then
      blockers=$((blockers + 1))
    fi
  done

  echo "Admission summary: P0=$p0 P1=$p1 P2=$p2 total=${#ADMISSION_FINDINGS[@]}"
  echo "Admission policy: block_on=[${ADMISSION_BLOCK_ON[*]}] warn_only=[${ADMISSION_WARN_ONLY[*]}]"

  if (( blockers > 0 )); then
    echo "ERROR: Admission controller blocked proposal apply due to P0/P1 findings." >&2
    exit 1
  fi
}

run_change_intake_policy_admission() {
  local intake_policy="$CHANGE_INTAKE_POLICY"
  if [[ ! -f "$intake_policy" ]]; then
    admission_add_finding "P2" "change_intake_policy" "change intake policy file missing: $intake_policy"
    return
  fi

  echo "Admission check: change intake policy classification"

  # Count changed files and surfaces
  local -a changed_files=()
  local -a changed_surfaces=()
  local action path reason surface
  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    if ! contains_value "$path" "${changed_files[@]:-}"; then
      changed_files+=("$path")
    fi
    # Derive surface from path prefix
    surface="${path%%/*}"
    if ! contains_value "$surface" "${changed_surfaces[@]:-}"; then
      changed_surfaces+=("$surface")
    fi
  done < "$changes_tmp"

  local file_count=${#changed_files[@]}
  local surface_count=${#changed_surfaces[@]}

  # Check cross-repo (workbench paths present)
  local involves_cross_repo="false"
  for path in "${changed_files[@]}"; do
    case "$path" in
      workbench/*|../workbench/*)
        involves_cross_repo="true"
        break
        ;;
    esac
  done

  # Check multi-agent (manifest agent field + required_agents)
  local involves_multi_agent="false"
  local agent_count=0
  if [[ -n "${agent:-}" ]]; then
    agent_count=1
  fi
  local required_agents_raw
  required_agents_raw="$(yq e -r '.required_agents[]?' "$manifest" 2>/dev/null || true)"
  if [[ -n "$required_agents_raw" ]]; then
    involves_multi_agent="true"
  fi

  # Check new binding/SSOT introduction
  local introduces_new_binding="false"
  for path in "${changed_files[@]}"; do
    case "$path" in
      ops/bindings/*.yaml|ops/bindings/*.yml)
        # Check if this is a create action
        local check_action
        check_action="$(awk -F'\t' -v p="$path" '$2 == p { print $1; exit }' "$changes_tmp")"
        check_action="$(normalize_action "$check_action")"
        if [[ "$check_action" == "create" ]]; then
          introduces_new_binding="true"
          break
        fi
        ;;
    esac
  done

  # Determine risk severity from manifest or default to medium
  local risk_severity
  risk_severity="$(yq e -r '.risk_severity // "medium"' "$manifest" 2>/dev/null || echo medium)"

  # Evaluate proposal_required_if (any_true)
  local proposal_required="false"

  # Read thresholds from policy
  local file_threshold surface_threshold
  file_threshold="$(yq e -r '.decision_rules.proposal_required_if.any_true[] | select(test("changed_file_count"))' "$intake_policy" 2>/dev/null | head -1 || true)"
  surface_threshold="$(yq e -r '.decision_rules.proposal_required_if.any_true[] | select(test("changed_surface_count"))' "$intake_policy" 2>/dev/null | head -1 || true)"

  # Default thresholds from policy: changed_file_count >= 3, changed_surface_count >= 2
  local file_limit=3
  local surface_limit=2
  if [[ "$file_threshold" =~ ([0-9]+) ]]; then
    file_limit="${BASH_REMATCH[1]}"
  fi
  if [[ "$surface_threshold" =~ ([0-9]+) ]]; then
    surface_limit="${BASH_REMATCH[1]}"
  fi

  if (( file_count >= file_limit )); then
    proposal_required="true"
  fi
  if (( surface_count >= surface_limit )); then
    proposal_required="true"
  fi
  if [[ "$involves_cross_repo" == "true" ]]; then
    proposal_required="true"
  fi
  if [[ "$involves_multi_agent" == "true" ]]; then
    proposal_required="true"
  fi
  if [[ "$introduces_new_binding" == "true" ]]; then
    proposal_required="true"
  fi
  if [[ "$risk_severity" == "high" || "$risk_severity" == "critical" ]]; then
    proposal_required="true"
  fi

  # Classify change
  local change_class="single_mutation_low_risk"
  if [[ "$risk_severity" == "high" || "$risk_severity" == "critical" ]]; then
    change_class="high_risk_change"
  elif [[ "$proposal_required" == "true" ]]; then
    change_class="coordinated_multi_step"
  fi

  # Emit classification
  printf '  files=%d surfaces=%d cross_repo=%s multi_agent=%s new_binding=%s risk=%s\n' \
    "$file_count" "$surface_count" "$involves_cross_repo" "$involves_multi_agent" "$introduces_new_binding" "$risk_severity"
  printf '  classification: %s proposal_required: %s\n' "$change_class" "$proposal_required"

  # Enforcement: if proposal_required and this is a proposal apply, we're on the
  # correct path. But if the change class is high_risk_change, verify the manifest
  # declares appropriate approval context.
  if [[ "$change_class" == "high_risk_change" ]]; then
    local terminal_c_approval
    terminal_c_approval="$(yq e -r '.terminal_c_approval // ""' "$manifest" 2>/dev/null || true)"
    if [[ -z "$terminal_c_approval" || "$terminal_c_approval" == "null" ]]; then
      admission_add_finding "P1" "change_intake_policy" "high-risk change class requires terminal_c_approval in manifest (risk=$risk_severity)"
    fi
  fi

  # If proposal_required but the execution path expects preflight verify, check loop_id
  if [[ "$proposal_required" == "true" && -z "${loop_id:-}" ]]; then
    admission_add_finding "P1" "change_intake_policy" "proposal-required change missing loop_id (files=$file_count surfaces=$surface_count cross_repo=$involves_cross_repo)"
  fi
}

run_admission_controller() {
  echo "Running admission controller..."
  need_cmd yq
  need_cmd jq
  [[ -x "$VERIFY_TOPOLOGY_BIN" ]] || {
    echo "ERROR: verify topology runner not executable: $VERIFY_TOPOLOGY_BIN" >&2
    exit 1
  }

  load_admission_policy
  run_domain_routing_admission
  run_workbench_contract_admission
  run_ssot_schema_conventions_admission
  run_vertical_integration_admission
  run_loop_gap_linkage_admission
  run_change_intake_policy_admission
  emit_admission_summary_and_enforce
}

DRY_RUN=0
if [[ "${1:-}" == "--dry-run" ]]; then
  DRY_RUN=1
  shift
fi

PROPOSAL_NAME="${1:-}"
if [[ -z "$PROPOSAL_NAME" ]]; then
  usage
  exit 2
fi

SPINE_CODE="${SPINE_CODE:-.}"
WORKBENCH_ROOT="${WORKBENCH_ROOT:-$HOME/code/workbench}"
WORKBENCH_AOF_CHECKER="${WORKBENCH_AOF_CHECKER:-$WORKBENCH_ROOT/scripts/root/aof/workbench-aof-check.sh}"
PROPOSALS_DIR="$SPINE_CODE/mailroom/outbox/proposals"
PROPOSAL_DIR="$PROPOSALS_DIR/$PROPOSAL_NAME"
PROPOSALS_LIFECYCLE_CONTRACT="$SPINE_CODE/ops/bindings/proposals.lifecycle.yaml"
SCHEMA_CONVENTIONS_CONTRACT="$SPINE_CODE/ops/bindings/spine.schema.conventions.yaml"
VERTICAL_INTEGRATION_CONTRACT="$SPINE_CODE/ops/bindings/vertical.integration.admission.contract.yaml"
VERIFY_TOPOLOGY_BIN="$SPINE_CODE/ops/plugins/verify/bin/verify-topology"
GAPS_FILE="$SPINE_CODE/ops/bindings/operational.gaps.yaml"
CHANGE_INTAKE_POLICY="$SPINE_CODE/ops/bindings/change.intake.policy.yaml"
LOOP_SCOPES_DIR="$SPINE_CODE/mailroom/state/loop-scopes"

if [[ ! -d "$PROPOSAL_DIR" ]]; then
  echo "ERROR: Proposal not found: $PROPOSAL_DIR" >&2
  exit 1
fi

manifest="$PROPOSAL_DIR/manifest.yaml"
files_dir="$PROPOSAL_DIR/files"

if [[ ! -f "$manifest" ]]; then
  echo "ERROR: Manifest not found: $manifest" >&2
  exit 1
fi

if [[ -f "$PROPOSAL_DIR/.applied" ]]; then
  echo "ERROR: Proposal already applied: $PROPOSAL_NAME" >&2
  exit 1
fi

# Detect superseded or read-only proposals before attempting apply
manifest_status=$(awk -F': *' '/^status:/{print $2; exit}' "$manifest" | tr -d '"' || true)
read_only=$(awk -F': *' '/^read_only:/{print $2; exit}' "$manifest" | tr -d '"' || true)

if [[ "${manifest_status:-}" == "superseded" ]]; then
  echo "ERROR: Proposal is superseded: $PROPOSAL_NAME" >&2
  superseded_reason=$(awk -F': *' '/^superseded_reason:/{print $2; exit}' "$manifest" | tr -d '"' || true)
  [[ -n "${superseded_reason:-}" ]] && echo "  Reason: $superseded_reason" >&2
  exit 1
fi

if [[ "${read_only:-}" == "true" ]]; then
  echo "ERROR: Proposal is read-only (no file changes): $PROPOSAL_NAME" >&2
  exit 1
fi

cd "$SPINE_CODE"

if [[ -n "$(git status --porcelain)" ]]; then
  echo "ERROR: Working tree is not clean. Commit/stash before applying proposals." >&2
  git status --porcelain | sed -n '1,60p' >&2
  exit 1
fi

agent=$(awk '/^agent:/{sub(/^agent: */, ""); gsub(/"/, ""); print; exit}' "$manifest")
created=$(awk '/^created:/{sub(/^created: */, ""); gsub(/"/, ""); print; exit}' "$manifest")
loop_id=$(awk '/^loop_id:/{sub(/^loop_id: */, ""); gsub(/"/, ""); print; exit}' "$manifest")
[[ "${loop_id:-}" == "null" ]] && loop_id=""

echo "Applying proposal: $PROPOSAL_NAME"
[[ -n "${loop_id:-}" ]] && echo "Loop: $loop_id"
[[ -n "${agent:-}" ]] && echo "Agent: $agent"
[[ -n "${created:-}" ]] && echo "Created: $created"
echo ""

changes_tmp="$(mktemp "/tmp/spine-proposal-changes.XXXXXX")"
trap 'rm -f "$changes_tmp" 2>/dev/null || true' EXIT INT TERM

awk '
  function trim(s) {
    gsub(/^[ \t]+/, "", s)
    gsub(/[ \t]+$/, "", s)
    gsub(/^"+|"+$/, "", s)
    return s
  }
  BEGIN { action=""; path=""; reason="" }
  /^[ \t]*-[ \t]*action:[ \t]*/ {
    if (action != "") { print action "\t" path "\t" reason }
    action = trim($0)
    sub(/^[ \t]*-[ \t]*action:[ \t]*/, "", action)
    path=""; reason=""
    next
  }
  /^[ \t]*path:[ \t]*/ {
    path = trim($0)
    sub(/^[ \t]*path:[ \t]*/, "", path)
    next
  }
  /^[ \t]*reason:[ \t]*/ {
    reason = trim($0)
    sub(/^[ \t]*reason:[ \t]*/, "", reason)
    next
  }
  END {
    if (action != "") { print action "\t" path "\t" reason }
  }
' "$manifest" > "$changes_tmp"

if [[ ! -s "$changes_tmp" ]]; then
  echo "ERROR: No actionable changes in manifest (changes may be empty or use nonstandard format): $manifest" >&2
  exit 1
fi

first_reason=""
had_error=0
while IFS=$'\t' read -r action path reason; do
  action="$(normalize_action "$action")"
  if [[ -z "${first_reason}" && -n "${reason:-}" ]]; then
    first_reason="$reason"
  fi

  case "$action" in
    create|modify|delete) ;;
    *)
      echo "ERROR: Invalid action '$action' in $manifest" >&2
      had_error=1
      ;;
  esac

  if ! validate_path "$path"; then
    echo "ERROR: Unsafe/invalid path '$path' in $manifest" >&2
    had_error=1
  fi
done < "$changes_tmp"

if [[ "$had_error" -ne 0 ]]; then
  echo "ERROR: Proposal manifest validation failed before admission checks." >&2
  exit 1
fi

declare -a ADMISSION_FINDINGS=()
declare -a ADMISSION_BLOCK_ON=()
declare -a ADMISSION_WARN_ONLY=()
run_admission_controller

while IFS=$'\t' read -r action path reason; do
  action="$(normalize_action "$action")"
  if [[ "$DRY_RUN" -eq 1 ]]; then
    printf "DRY RUN: %-6s %s\n" "$action" "$path"
    continue
  fi

  case "$action" in
    create|modify)
      src="$files_dir/$path"
      dst="$SPINE_CODE/$path"
      if [[ ! -f "$src" ]]; then
        echo "ERROR: Missing proposal file for $action: $src" >&2
        had_error=1
        continue
      fi
      if [[ -L "$src" ]]; then
        echo "ERROR: Proposal file must not be a symlink: $src" >&2
        had_error=1
        continue
      fi
      mkdir -p "$(dirname "$dst")"
      cp -p "$src" "$dst"
      git add -- "$path"
      if [[ "$action" == "create" ]]; then
        echo "✓ Create: $path"
      else
        echo "✓ Modify: $path"
      fi
      ;;
    delete)
      if [[ -e "$SPINE_CODE/$path" ]]; then
        git rm -f -- "$path" >/dev/null
        echo "✓ Delete: $path"
      else
        echo "WARN: Delete requested but file missing: $path"
      fi
      ;;
  esac
done < "$changes_tmp"

if [[ "$DRY_RUN" -eq 1 ]]; then
  echo ""
  if [[ "$had_error" -ne 0 ]]; then
    echo "DRY RUN: encountered proposal validation errors." >&2
    exit 1
  fi
  echo "DRY RUN: no files changed, nothing committed."
  exit 0
fi

if [[ "$had_error" -ne 0 ]]; then
  echo "ERROR: One or more changes could not be applied. Aborting." >&2
  exit 1
fi

if git diff --cached --quiet; then
  echo "ERROR: No staged changes after applying proposal. Refusing to commit." >&2
  exit 1
fi

subject=""
if [[ -n "${loop_id:-}" ]]; then
  subject="fix(${loop_id}): apply ${PROPOSAL_NAME}"
else
  subject="gov(${PROPOSAL_NAME}): ${first_reason:-apply proposal}"
fi

git commit -m "$subject" \
  -m "Proposal: ${PROPOSAL_NAME}" \
  -m "Agent: ${agent:-unknown}" \
  -m "Created: ${created:-unknown}" \
  -m "First reason: ${first_reason:-unknown}"

commit_sha="$(git rev-parse HEAD)"

{
  echo "Applied: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
  echo "Commit: ${commit_sha}"
} > "$PROPOSAL_DIR/.applied"

echo ""
echo "Proposal applied successfully."
echo "Commit: $commit_sha"
