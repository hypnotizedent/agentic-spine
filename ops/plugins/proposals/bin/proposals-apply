#!/bin/bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../../../lib/git-lock.sh"

# proposals-apply: Apply a change proposal to the repo (non-interactive).
#
# Notes:
# - `ops cap run proposals.apply` already enforces `approval: manual` ("Type 'yes' to proceed").
# - This script must not prompt for additional input, or piping `yes` into ops will deadlock.
# - Write admission is mandatory and cannot be bypassed.
#
# Usage:
#   proposals-apply [--dry-run] CP-<name>

usage() {
  cat <<'USAGE'
Usage:
  proposals-apply [--dry-run] CP-<name>

Applies the proposal from:
  mailroom/outbox/proposals/<CP-...>/

Requires:
  - clean git working tree (abort otherwise)
  - manifest.yaml contains changes with action/path/reason
  - for create/modify: proposal/files/<path> exists

Admission controller (mandatory):
  - verify.core.run equivalent
  - path-scoped verify.domain.run <domain> --force routing
  - workbench AOF contract checks (when workbench paths are present)
  - SSOT schema convention checks for changed ops/bindings YAML files
  - vertical integration admission matrix checks for mint pricing/suppliers module touches
  - loop/gap linkage checks

Policy:
  - P0/P1 findings block apply
  - P2 findings warn-only
USAGE
}

need_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "ERROR: required command missing: $cmd" >&2
    exit 1
  }
}

contains_value() {
  local needle="$1"
  shift || true
  local item
  for item in "$@"; do
    [[ "$item" == "$needle" ]] && return 0
  done
  return 1
}

validate_path() {
  local p="$1"
  if [[ -z "$p" ]]; then return 1; fi
  if [[ "$p" == /* ]]; then return 1; fi
  if [[ "$p" == *".."* ]]; then return 1; fi
  if [[ "$p" == *"~"* ]]; then return 1; fi
  if [[ "$p" == *$'\n'* ]]; then return 1; fi
  return 0
}

normalize_action() {
  local action="$1"
  case "$action" in
    create|created)
      echo "create"
      ;;
    modify|update|edit|api-write)
      echo "modify"
      ;;
    delete|remove)
      echo "delete"
      ;;
    *)
      echo "$action"
      ;;
  esac
}

normalize_workbench_path() {
  local p="$1"
  case "$p" in
    "$WORKBENCH_ROOT"/*)
      echo "$p"
      ;;
    /Users/*/code/workbench/*)
      echo "$p"
      ;;
    workbench/*)
      echo "$HOME/code/$p"
      ;;
    ../workbench/*)
      echo "$HOME/code/${p#../}"
      ;;
    *)
      echo ""
      ;;
  esac
}

normalize_contract_glob() {
  local pattern="${1:-}"
  pattern="${pattern#./}"
  # Bash [[ pattern matching ]] treats '*' as multi-segment wildcard already.
  pattern="${pattern//\*\*/\*}"
  printf '%s\n' "$pattern"
}

path_matches_contract_glob() {
  local path="$1"
  local glob_raw="$2"
  local glob
  glob="$(normalize_contract_glob "$glob_raw")"
  [[ -n "$glob" ]] || return 1
  [[ "$path" == $glob ]]
}

companion_satisfied_by_existing() {
  local companion_glob="$1"
  # Non-wildcard: direct file check in main tree or proposal staging
  if [[ "$companion_glob" != *"*"* && "$companion_glob" != *"?"* ]]; then
    [[ -f "$SPINE_CODE/$companion_glob" || -f "$files_dir/$companion_glob" ]] && return 0
    return 1
  fi
  # Wildcard: check parent directory for any matching files
  local parent="${companion_glob%%\**}"
  parent="${parent%/}"
  [[ -n "$parent" ]] || parent="."
  local match
  if [[ -d "$SPINE_CODE/$parent" ]]; then
    match="$(find "$SPINE_CODE/$parent" -type f 2>/dev/null | head -1)"
    [[ -n "$match" ]] && return 0
  fi
  if [[ -d "$files_dir/$parent" ]]; then
    match="$(find "$files_dir/$parent" -type f 2>/dev/null | head -1)"
    [[ -n "$match" ]] && return 0
  fi
  return 1
}

admission_add_finding() {
  local severity="$1"
  local code="$2"
  local detail="$3"
  ADMISSION_FINDINGS+=("$severity|$code|$detail")
}

severity_blocks_apply() {
  local severity="$1"
  contains_value "$severity" "${ADMISSION_BLOCK_ON[@]}"
}

run_domain_routing_admission() {
  local core_output core_rc
  echo "Admission check: verify core gates"
  set +e
  core_output="$($VERIFY_TOPOLOGY_BIN core 2>&1)"
  core_rc=$?
  set -e
  echo "$core_output"
  if (( core_rc != 0 )); then
    admission_add_finding "P0" "verify_core" "verify.core.run equivalent failed"
  fi

  local recommend_output recommend_rc
  local -a recommend_cmd
  local -a recommended_domains=()
  local -a verify_domains=()
  local include_loop_gap=0
  local path
  recommend_cmd=("$VERIFY_TOPOLOGY_BIN" recommend --json)
  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    recommend_cmd+=(--path "$path")
    case "$path" in
      ops/bindings/operational.gaps.yaml|mailroom/state/loop-scopes/*|mailroom/outbox/proposals/*)
        include_loop_gap=1
        ;;
    esac
  done < "$changes_tmp"

  # Keep loop_gap routing available when proposal/loop artifacts are touched,
  # but avoid forcing it for every proposal (loop/gap linkage is checked separately).
  if [[ "${PROPOSALS_ADMISSION_FORCE_LOOP_GAP:-0}" == "1" || "$include_loop_gap" -eq 1 ]]; then
    recommend_cmd+=(--capability "proposals.apply")
  fi

  echo "Admission check: resolve affected domains"
  set +e
  recommend_output="$(${recommend_cmd[@]} 2>&1)"
  recommend_rc=$?
  set -e

  if (( recommend_rc != 0 )); then
    echo "$recommend_output"
    admission_add_finding "P1" "verify_route" "verify.route.recommend equivalent failed"
    return
  fi

  while IFS= read -r domain; do
    [[ -n "$domain" ]] || continue
    if ! contains_value "$domain" "${recommended_domains[@]:-}"; then
      recommended_domains+=("$domain")
    fi
  done < <(jq -r '.recommended_domains[]?' <<< "$recommend_output" 2>/dev/null || true)

  if (( ${#recommended_domains[@]} == 0 )); then
    recommended_domains=("core")
  fi

  echo "Admission routed domains: ${recommended_domains[*]}"

  for domain in "${recommended_domains[@]}"; do
    [[ "$domain" == "core" ]] && continue
    if ! contains_value "$domain" "${verify_domains[@]:-}"; then
      verify_domains+=("$domain")
    fi
  done

  if (( ${#verify_domains[@]} == 0 )); then
    return
  fi

  local domains_csv domains_output domains_rc
  domains_csv="$(IFS=,; echo "${verify_domains[*]}")"
  echo "Admission check: verify routed domains (deduped)"
  set +e
  domains_output="$($VERIFY_TOPOLOGY_BIN domains-run "$domains_csv" --force 2>&1)"
  domains_rc=$?
  set -e
  echo "$domains_output"
  if (( domains_rc != 0 )); then
    admission_add_finding "P0" "verify_domain" "verify.domains.run $domains_csv --force failed"
  fi
}

run_workbench_contract_admission() {
  local -a wb_paths=()
  local normalized path action reason

  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    normalized="$(normalize_workbench_path "$path")"
    [[ -n "$normalized" ]] || continue
    if ! contains_value "$normalized" "${wb_paths[@]:-}"; then
      wb_paths+=("$normalized")
    fi
  done < "$changes_tmp"

  if (( ${#wb_paths[@]} == 0 )); then
    return
  fi

  if [[ ! -d "$WORKBENCH_ROOT" ]]; then
    admission_add_finding "P1" "workbench_preflight" "workbench path required but WORKBENCH_ROOT is unreachable: $WORKBENCH_ROOT"
    return
  fi

  if [[ ! -x "$WORKBENCH_AOF_CHECKER" ]]; then
    admission_add_finding "P1" "workbench_preflight" "workbench AOF checker missing: $WORKBENCH_AOF_CHECKER"
    return
  fi

  echo "Admission check: workbench AOF contract"
  local -a checker_args=()
  checker_args=(--mode all --format text)
  for path in "${wb_paths[@]}"; do
    checker_args+=(--changed-files "$path")
  done

  local preflight_output preflight_rc summary_line p0 p1 p2 parsed_summary
  set +e
  preflight_output="$($WORKBENCH_AOF_CHECKER ${checker_args[@]} 2>&1)"
  preflight_rc=$?
  set -e
  echo "$preflight_output"

  summary_line="$(grep -E '^summary:' <<< "$preflight_output" | tail -1 || true)"
  p0=0
  p1=0
  p2=0
  parsed_summary=0
  if [[ "$summary_line" =~ P0=([0-9]+)[[:space:]]+P1=([0-9]+)[[:space:]]+P2=([0-9]+) ]]; then
    parsed_summary=1
    p0="${BASH_REMATCH[1]}"
    p1="${BASH_REMATCH[2]}"
    p2="${BASH_REMATCH[3]}"
    (( p0 > 0 )) && admission_add_finding "P0" "workbench_aof" "workbench checker reported P0 findings: $p0"
    (( p1 > 0 )) && admission_add_finding "P1" "workbench_aof" "workbench checker reported P1 findings: $p1"
    (( p2 > 0 )) && admission_add_finding "P2" "workbench_aof" "workbench checker reported P2 findings: $p2"
  elif (( preflight_rc != 0 )); then
    admission_add_finding "P1" "workbench_aof" "workbench checker failed without parseable severity summary"
  fi

  if (( preflight_rc != 0 && parsed_summary == 0 )); then
    admission_add_finding "P1" "workbench_aof" "workbench checker exited non-zero"
  fi
}

run_ssot_schema_conventions_admission() {
  local schema_contract="$SCHEMA_CONVENTIONS_CONTRACT"
  local touch_to_fix
  local -a disallowed_keys=()
  local -a discouraged_keys=()
  local -a allowed_status=()
  local -a allowed_lifecycle=()

  local -a binding_paths=()
  local action path reason
  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    [[ "$action" == "create" || "$action" == "modify" ]] || continue
    case "$path" in
      ops/bindings/*.yml|ops/bindings/*.yaml)
        if ! contains_value "$path" "${binding_paths[@]:-}"; then
          binding_paths+=("$path")
        fi
        ;;
    esac
  done < "$changes_tmp"

  if (( ${#binding_paths[@]} == 0 )); then
    return
  fi

  if [[ ! -f "$schema_contract" ]]; then
    admission_add_finding "P1" "schema_conventions" "missing schema conventions contract: $schema_contract"
    return
  fi

  touch_to_fix="$(yq e -r '.legacy_alias_rules.touch_to_fix_required // true' "$schema_contract" 2>/dev/null || echo true)"

  while IFS= read -r path; do
    [[ -n "$path" ]] && disallowed_keys+=("$path")
  done < <(yq e -r '.field_rules.disallowed_alias_keys[]?' "$schema_contract" 2>/dev/null || true)

  while IFS= read -r path; do
    [[ -n "$path" ]] && discouraged_keys+=("$path")
  done < <(yq e -r '.field_rules.discouraged_alias_keys[]?' "$schema_contract" 2>/dev/null || true)

  while IFS= read -r path; do
    [[ -n "$path" ]] && allowed_status+=("$path")
  done < <(yq e -r '.status_rules.allowed_values[]?' "$schema_contract" 2>/dev/null || true)

  while IFS= read -r path; do
    [[ -n "$path" ]] && allowed_lifecycle+=("$path")
  done < <(yq e -r '.status_rules.lifecycle_values[]?' "$schema_contract" 2>/dev/null || true)

  echo "Admission check: SSOT schema conventions"

  local rel src key status lifecycle
  local -a file_keys=()
  local -a file_allowed_alias=()
  local -a status_values=()
  local -a lifecycle_values=()

  for rel in "${binding_paths[@]}"; do
    src="$files_dir/$rel"

    if [[ ! -f "$src" ]]; then
      admission_add_finding "P0" "schema_conventions" "missing proposal file for binding change: $rel"
      continue
    fi

    if ! yq e '.' "$src" >/dev/null 2>&1; then
      admission_add_finding "P0" "schema_conventions" "invalid YAML in proposal file: $rel"
      continue
    fi

    file_keys=()
    while IFS= read -r key; do
      [[ -n "$key" ]] && file_keys+=("$key")
    done < <(yq e '.. | select(tag == "!!map") | keys | .[]' "$src" 2>/dev/null | awk 'NF && !seen[$0]++')

    file_allowed_alias=()
    while IFS= read -r key; do
      [[ -n "$key" ]] && file_allowed_alias+=("$key")
    done < <(yq e -r ".legacy_alias_rules.legacy_exceptions[] | select(.file == \"$rel\") | .allowed_keys[]?" "$schema_contract" 2>/dev/null || true)

    for key in "${disallowed_keys[@]:-}"; do
      [[ -n "$key" ]] || continue
      if contains_value "$key" "${file_keys[@]:-}"; then
        if contains_value "$key" "${file_allowed_alias[@]:-}"; then
          if [[ "$touch_to_fix" == "true" ]]; then
            admission_add_finding "P1" "schema_conventions" "$rel uses legacy-excepted key '$key' in touched file (touch_and_fix enforced)"
          else
            admission_add_finding "P2" "schema_conventions" "$rel uses legacy-excepted key '$key'"
          fi
        else
          admission_add_finding "P1" "schema_conventions" "$rel includes disallowed alias key '$key'"
        fi
      fi
    done

    for key in "${discouraged_keys[@]:-}"; do
      [[ -n "$key" ]] || continue
      if contains_value "$key" "${file_keys[@]:-}"; then
        admission_add_finding "P2" "schema_conventions" "$rel includes discouraged key '$key'"
      fi
    done

    status_values=()
    while IFS= read -r status; do
      [[ -n "$status" && "$status" != "null" ]] && status_values+=("$status")
    done < <(yq e '.. | select(tag == "!!map" and has("status")) | .status' "$src" 2>/dev/null || true)

    if (( ${#status_values[@]} > 0 )); then
      for status in "${status_values[@]}"; do
        [[ -n "$status" && "$status" != "null" ]] || continue
        if ! contains_value "$status" "${allowed_status[@]:-}"; then
          admission_add_finding "P1" "schema_conventions" "$rel includes non-canonical status value '$status'"
        fi
      done
    fi

    lifecycle_values=()
    while IFS= read -r lifecycle; do
      [[ -n "$lifecycle" && "$lifecycle" != "null" ]] && lifecycle_values+=("$lifecycle")
    done < <(yq e '.. | select(tag == "!!map" and has("lifecycle")) | .lifecycle' "$src" 2>/dev/null || true)

    if (( ${#lifecycle_values[@]} > 0 )); then
      for lifecycle in "${lifecycle_values[@]}"; do
        [[ -n "$lifecycle" && "$lifecycle" != "null" ]] || continue
        if ! contains_value "$lifecycle" "${allowed_lifecycle[@]:-}"; then
          admission_add_finding "P1" "schema_conventions" "$rel includes non-canonical lifecycle value '$lifecycle'"
        fi
      done
    fi
  done
}

run_vertical_integration_admission() {
  local contract="$VERTICAL_INTEGRATION_CONTRACT"
  local enabled matrix_count idx
  local action path reason
  local rule_id matched trigger_glob companion_id companion_glob
  local -a changed_paths=()
  local -a triggered_rules=()
  local -a required_companions=()

  if [[ ! -f "$contract" ]]; then
    admission_add_finding "P1" "vertical_integration_contract" "missing vertical integration admission contract: $contract"
    return
  fi

  enabled="$(yq e -r '.admission.enabled // true' "$contract" 2>/dev/null || echo true)"
  [[ "$enabled" == "true" ]] || return

  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    if ! contains_value "$path" "${changed_paths[@]:-}"; then
      changed_paths+=("$path")
    fi
  done < "$changes_tmp"

  if (( ${#changed_paths[@]} == 0 )); then
    return
  fi

  matrix_count="$(yq e '.admission.required_change_matrix | length' "$contract" 2>/dev/null || echo 0)"
  [[ "$matrix_count" =~ ^[0-9]+$ ]] || matrix_count=0
  if (( matrix_count == 0 )); then
    return
  fi

  for ((idx=0; idx<matrix_count; idx++)); do
    matched=0
    rule_id="$(yq e -r ".admission.required_change_matrix[$idx].id // \"rule_$idx\"" "$contract" 2>/dev/null || echo "rule_$idx")"

    while IFS= read -r trigger_glob; do
      [[ -n "$trigger_glob" ]] || continue
      for path in "${changed_paths[@]}"; do
        if path_matches_contract_glob "$path" "$trigger_glob"; then
          matched=1
          break
        fi
      done
      (( matched == 1 )) && break
    done < <(yq e -r ".admission.required_change_matrix[$idx].touch_any[]?" "$contract" 2>/dev/null || true)

    if (( matched == 1 )); then
      if ! contains_value "$rule_id" "${triggered_rules[@]:-}"; then
        triggered_rules+=("$rule_id")
      fi

      while IFS= read -r companion_id; do
        [[ -n "$companion_id" ]] || continue
        if ! contains_value "$companion_id" "${required_companions[@]:-}"; then
          required_companions+=("$companion_id")
        fi
      done < <(yq e -r ".admission.required_change_matrix[$idx].required_companions[]?" "$contract" 2>/dev/null || true)
    fi
  done

  if (( ${#triggered_rules[@]} == 0 )); then
    return
  fi

  echo "Admission check: vertical integration matrix (${triggered_rules[*]})"

  local loop_required loop_severity
  local changes_required changes_severity change_count
  loop_required="$(yq e -r '.admission.manifest_requirements.loop_id.required // true' "$contract" 2>/dev/null || echo true)"
  loop_severity="$(yq e -r '.admission.manifest_requirements.loop_id.severity // "P0"' "$contract" 2>/dev/null || echo P0)"
  if [[ "$loop_required" == "true" && -z "${loop_id:-}" ]]; then
    admission_add_finding "$loop_severity" "vertical_loop_id" "vertical integration trigger matched but manifest loop_id is missing"
  fi

  changes_required="$(yq e -r '.admission.manifest_requirements.changes_non_empty.required // true' "$contract" 2>/dev/null || echo true)"
  changes_severity="$(yq e -r '.admission.manifest_requirements.changes_non_empty.severity // "P0"' "$contract" 2>/dev/null || echo P0)"
  change_count="$(yq e '.changes | length' "$manifest" 2>/dev/null || echo 0)"
  [[ "$change_count" =~ ^[0-9]+$ ]] || change_count=0
  if [[ "$changes_required" == "true" && "$change_count" -eq 0 ]]; then
    admission_add_finding "$changes_severity" "vertical_changes" "vertical integration trigger matched but manifest changes list is empty"
  fi

  local override_root status_key reason_key status_value reason_required invalid_override_severity
  override_root="$(yq e -r '.admission.manifest_requirements.not_required_override.root_key // "vertical_integration.surface_overrides"' "$contract" 2>/dev/null || echo "vertical_integration.surface_overrides")"
  status_key="$(yq e -r '.admission.manifest_requirements.not_required_override.status_key // "status"' "$contract" 2>/dev/null || echo status)"
  reason_key="$(yq e -r '.admission.manifest_requirements.not_required_override.reason_key // "reason"' "$contract" 2>/dev/null || echo reason)"
  status_value="$(yq e -r '.admission.manifest_requirements.not_required_override.status_value // "not-required"' "$contract" 2>/dev/null || echo "not-required")"
  reason_required="$(yq e -r '.admission.manifest_requirements.not_required_override.reason_required // true' "$contract" 2>/dev/null || echo true)"
  invalid_override_severity="$(yq e -r '.admission.manifest_requirements.not_required_override.severity_when_invalid // "P1"' "$contract" 2>/dev/null || echo P1)"

  local companion_severity companion_description
  local companion_status companion_reason
  local companion_path_summary
  local -a companion_globs=()
  local satisfied_by_change

  for companion_id in "${required_companions[@]}"; do
    companion_severity="$(yq e -r ".companion_surfaces.\"$companion_id\".severity // \"P1\"" "$contract" 2>/dev/null || echo P1)"
    companion_description="$(yq e -r ".companion_surfaces.\"$companion_id\".description // \"\"" "$contract" 2>/dev/null || true)"

    companion_globs=()
    companion_path_summary=""
    while IFS= read -r companion_glob; do
      [[ -n "$companion_glob" ]] || continue
      companion_globs+=("$companion_glob")
      if [[ -n "$companion_path_summary" ]]; then
        companion_path_summary+=", "
      fi
      companion_path_summary+="$companion_glob"
    done < <(yq e -r ".companion_surfaces.\"$companion_id\".satisfy_any_path[]?" "$contract" 2>/dev/null || true)

    if (( ${#companion_globs[@]} == 0 )); then
      admission_add_finding "P1" "vertical_${companion_id}_contract" "contract companion '$companion_id' has no satisfy_any_path rules"
      continue
    fi

    satisfied_by_change=0
    for path in "${changed_paths[@]}"; do
      for companion_glob in "${companion_globs[@]}"; do
        if path_matches_contract_glob "$path" "$companion_glob"; then
          satisfied_by_change=1
          break
        fi
      done
      (( satisfied_by_change == 1 )) && break
    done

    if (( satisfied_by_change == 1 )); then
      continue
    fi

    # Check if companion is satisfied by files already on disk or in proposal staging
    for companion_glob in "${companion_globs[@]}"; do
      if companion_satisfied_by_existing "$companion_glob"; then
        satisfied_by_change=1
        break
      fi
    done
    if (( satisfied_by_change == 1 )); then
      continue
    fi

    companion_status="$(yq e -r ".${override_root}.\"$companion_id\".${status_key} // \"\"" "$manifest" 2>/dev/null || true)"
    companion_reason="$(yq e -r ".${override_root}.\"$companion_id\".${reason_key} // \"\"" "$manifest" 2>/dev/null || true)"

    if [[ "$companion_status" == "$status_value" ]]; then
      if [[ "$reason_required" == "true" ]]; then
        if [[ -n "$companion_reason" && "$companion_reason" != "null" ]]; then
          continue
        fi
        admission_add_finding "$invalid_override_severity" "vertical_${companion_id}_override" "${override_root}.\"$companion_id\".${status_key}=${status_value} requires non-empty ${reason_key}"
        continue
      fi
      continue
    fi

    admission_add_finding "$companion_severity" "vertical_${companion_id}" "vertical integration trigger(s) [${triggered_rules[*]}] require companion '$companion_id' (${companion_description}). Update one of: ${companion_path_summary}; or set manifest ${override_root}.\"$companion_id\".{${status_key}: ${status_value}, ${reason_key}: <reason>}"
  done
}

run_loop_gap_linkage_admission() {
  local scope_file loop_status gap_rel gap_src linked_count existing_linked_count

  echo "Admission check: loop/gap linkage"

  if [[ -z "${loop_id:-}" ]]; then
    admission_add_finding "P1" "loop_gap_linkage" "manifest loop_id is required for mutating proposal apply"
    return
  fi

  scope_file="$LOOP_SCOPES_DIR/$loop_id.scope.md"
  if [[ ! -f "$scope_file" ]]; then
    admission_add_finding "P1" "loop_gap_linkage" "loop scope file missing for loop_id=$loop_id"
    return
  fi

  loop_status="$(awk '/^status:/{print $2; exit}' "$scope_file" 2>/dev/null || true)"
  case "$loop_status" in
    active|planned|draft)
      ;;
    closed|done|archived)
      admission_add_finding "P1" "loop_gap_linkage" "loop_id=$loop_id is not active (status=$loop_status)"
      ;;
    *)
      admission_add_finding "P2" "loop_gap_linkage" "loop_id=$loop_id has unknown scope status '${loop_status:-unknown}'"
      ;;
  esac

  gap_rel="ops/bindings/operational.gaps.yaml"
  if awk -F'\t' -v p="$gap_rel" '$2 == p { found=1 } END { exit(found ? 0 : 1) }' "$changes_tmp"; then
    gap_src="$files_dir/$gap_rel"
    if [[ ! -f "$gap_src" ]]; then
      admission_add_finding "P1" "loop_gap_linkage" "proposal changes $gap_rel but staged file is missing"
      return
    fi

    linked_count="$(yq e "[.gaps[] | select(.status == \"open\" and (.parent_loop // \"\") == \"$loop_id\")] | length" "$gap_src" 2>/dev/null || echo 0)"
    if [[ "$linked_count" =~ ^[0-9]+$ ]] && (( linked_count == 0 )); then
      admission_add_finding "P1" "loop_gap_linkage" "proposal touches operational.gaps.yaml but no open gap is linked to loop_id=$loop_id"
    fi
  else
    existing_linked_count="$(yq e "[.gaps[] | select(.status == \"open\" and (.parent_loop // \"\") == \"$loop_id\")] | length" "$GAPS_FILE" 2>/dev/null || echo 0)"
    if [[ "$existing_linked_count" =~ ^[0-9]+$ ]] && (( existing_linked_count == 0 )); then
      admission_add_finding "P2" "loop_gap_linkage" "no open gaps currently linked to loop_id=$loop_id"
    fi
  fi
}

run_proposal_horizon_admission() {
  local scope_file loop_horizon loop_readiness proposal_status
  local pending_horizon pending_readiness forced_status
  local deferred_horizons deferred_hit

  echo "Admission check: proposal horizon rules"

  if [[ -z "${loop_id:-}" ]]; then
    admission_add_finding "P1" "proposal_horizon" "manifest loop_id is required for horizon_rules enforcement"
    return
  fi

  scope_file="$LOOP_SCOPES_DIR/$loop_id.scope.md"
  if [[ ! -f "$scope_file" ]]; then
    admission_add_finding "P1" "proposal_horizon" "loop scope file missing for loop_id=$loop_id"
    return
  fi

  loop_horizon="$(awk '/^horizon:/{print $2; exit}' "$scope_file" 2>/dev/null | tr -d '"' || true)"
  loop_readiness="$(awk '/^execution_readiness:/{print $2; exit}' "$scope_file" 2>/dev/null | tr -d '"' || true)"
  [[ -n "$loop_horizon" ]] || loop_horizon="now"
  [[ -n "$loop_readiness" ]] || loop_readiness="runnable"

  proposal_status="${manifest_status:-}"
  [[ -n "$proposal_status" ]] || proposal_status="pending"

  pending_horizon="$(yq e -r '.horizon_rules.pending_requires.parent_loop_horizon // "now"' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || echo now)"
  pending_readiness="$(yq e -r '.horizon_rules.pending_requires.parent_loop_readiness // "runnable"' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || echo runnable)"
  forced_status="$(yq e -r '.horizon_rules.draft_hold_for_deferred.forced_status // "draft_hold"' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || echo draft_hold)"
  deferred_horizons="$(yq e -r '.horizon_rules.draft_hold_for_deferred.applies_when_horizon[]?' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null | tr '\n' ' ')"
  [[ -n "$deferred_horizons" ]] || deferred_horizons="later future"

  deferred_hit=0
  for hz in $deferred_horizons; do
    if [[ "$loop_horizon" == "$hz" ]]; then
      deferred_hit=1
      break
    fi
  done

  if [[ "$deferred_hit" -eq 1 ]]; then
    if [[ "$proposal_status" != "$forced_status" ]]; then
      admission_add_finding "P1" "proposal_horizon_status" "loop_id=$loop_id has horizon=$loop_horizon; proposal status must be ${forced_status} (got ${proposal_status}). Remediation: ./bin/ops cap run proposals.reconcile -- --normalize-status"
    fi
    admission_add_finding "P1" "proposal_horizon_apply_block" "loop_id=$loop_id is deferred (horizon=$loop_horizon). Promote loop before apply: ./bin/ops cap run planning.horizon.set -- --loop $loop_id --horizon $pending_horizon --readiness $pending_readiness"
    return
  fi

  if [[ "$proposal_status" == "pending" ]]; then
    if [[ "$loop_horizon" != "$pending_horizon" || "$loop_readiness" != "$pending_readiness" ]]; then
      admission_add_finding "P1" "proposal_horizon_pending" "pending proposal requires loop horizon=$pending_horizon and readiness=$pending_readiness (observed horizon=$loop_horizon readiness=$loop_readiness). Remediation: ./bin/ops cap run planning.horizon.set -- --loop $loop_id --horizon $pending_horizon --readiness $pending_readiness"
    fi
  fi
}

run_gap_id_validity_admission() {
  echo "Admission check: gap ID validity"

  # Extract GAP-OP-XXXX references from manifest change reasons
  local gap_refs=()
  while IFS= read -r gap_id; do
    [[ -n "$gap_id" ]] && gap_refs+=("$gap_id")
  done < <(yq e -r '.changes[].reason // "" ' "$manifest" 2>/dev/null | grep -oE 'GAP-OP-[0-9]+' | sort -u)

  if (( ${#gap_refs[@]} == 0 )); then
    return
  fi

  for gap_id in "${gap_refs[@]}"; do
    if ! yq e -e ".gaps[] | select(.id == \"$gap_id\")" "$GAPS_FILE" >/dev/null 2>&1; then
      admission_add_finding "P2" "gap_id_validity" "referenced $gap_id does not exist in operational.gaps.yaml"
    fi
  done
}

load_admission_policy() {
  ADMISSION_BLOCK_ON=()
  ADMISSION_WARN_ONLY=()

  if [[ -f "$PROPOSALS_LIFECYCLE_CONTRACT" ]]; then
    while IFS= read -r sev; do
      [[ -n "$sev" ]] && ADMISSION_BLOCK_ON+=("$sev")
    done < <(yq e -r '.admission_controller.block_on_severity[]?' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || true)

    while IFS= read -r sev; do
      [[ -n "$sev" ]] && ADMISSION_WARN_ONLY+=("$sev")
    done < <(yq e -r '.admission_controller.warn_only_severity[]?' "$PROPOSALS_LIFECYCLE_CONTRACT" 2>/dev/null || true)
  fi

  if (( ${#ADMISSION_BLOCK_ON[@]} == 0 )); then
    ADMISSION_BLOCK_ON=("P0" "P1")
  fi
  if (( ${#ADMISSION_WARN_ONLY[@]} == 0 )); then
    ADMISSION_WARN_ONLY=("P2")
  fi
}

emit_admission_summary_and_enforce() {
  local sev code detail
  local p0=0 p1=0 p2=0
  local blockers=0

  echo ""
  echo "Admission controller findings:"
  if (( ${#ADMISSION_FINDINGS[@]} == 0 )); then
    echo "  - none"
    echo "Admission summary: P0=0 P1=0 P2=0 total=0"
    return 0
  fi

  for entry in "${ADMISSION_FINDINGS[@]}"; do
    IFS='|' read -r sev code detail <<< "$entry"
    case "$sev" in
      P0) p0=$((p0 + 1)) ;;
      P1) p1=$((p1 + 1)) ;;
      P2) p2=$((p2 + 1)) ;;
    esac
    printf '  - %-2s %-20s %s\n' "$sev" "$code" "$detail"
    if severity_blocks_apply "$sev"; then
      blockers=$((blockers + 1))
    fi
  done

  echo "Admission summary: P0=$p0 P1=$p1 P2=$p2 total=${#ADMISSION_FINDINGS[@]}"
  echo "Admission policy: block_on=[${ADMISSION_BLOCK_ON[*]}] warn_only=[${ADMISSION_WARN_ONLY[*]}]"

  if (( blockers > 0 )); then
    echo "ERROR: Admission controller blocked proposal apply due to P0/P1 findings." >&2
    exit 1
  fi
}

run_change_intake_policy_admission() {
  local intake_policy="$CHANGE_INTAKE_POLICY"
  if [[ ! -f "$intake_policy" ]]; then
    admission_add_finding "P2" "change_intake_policy" "change intake policy file missing: $intake_policy"
    return
  fi

  echo "Admission check: change intake policy classification"

  # Count changed files and surfaces
  local -a changed_files=()
  local -a changed_surfaces=()
  local action path reason surface
  while IFS=$'\t' read -r action path reason; do
    action="$(normalize_action "$action")"
    case "$action" in
      create|modify|delete) ;;
      *) continue ;;
    esac
    [[ -n "$path" ]] || continue
    if ! contains_value "$path" "${changed_files[@]:-}"; then
      changed_files+=("$path")
    fi
    # Derive surface from path prefix
    surface="${path%%/*}"
    if ! contains_value "$surface" "${changed_surfaces[@]:-}"; then
      changed_surfaces+=("$surface")
    fi
  done < "$changes_tmp"

  local file_count=${#changed_files[@]}
  local surface_count=${#changed_surfaces[@]}

  # Check cross-repo (workbench paths present)
  local involves_cross_repo="false"
  for path in "${changed_files[@]}"; do
    case "$path" in
      workbench/*|../workbench/*)
        involves_cross_repo="true"
        break
        ;;
    esac
  done

  # Check multi-agent (manifest agent field + required_agents)
  local involves_multi_agent="false"
  local agent_count=0
  if [[ -n "${agent:-}" ]]; then
    agent_count=1
  fi
  local required_agents_raw
  required_agents_raw="$(yq e -r '.required_agents[]?' "$manifest" 2>/dev/null || true)"
  if [[ -n "$required_agents_raw" ]]; then
    involves_multi_agent="true"
  fi

  # Check new binding/SSOT introduction
  local introduces_new_binding="false"
  for path in "${changed_files[@]}"; do
    case "$path" in
      ops/bindings/*.yaml|ops/bindings/*.yml)
        # Check if this is a create action
        local check_action
        check_action="$(awk -F'\t' -v p="$path" '$2 == p { print $1; exit }' "$changes_tmp")"
        check_action="$(normalize_action "$check_action")"
        if [[ "$check_action" == "create" ]]; then
          introduces_new_binding="true"
          break
        fi
        ;;
    esac
  done

  # Determine risk severity from manifest or default to medium
  local risk_severity
  risk_severity="$(yq e -r '.risk_severity // "medium"' "$manifest" 2>/dev/null || echo medium)"

  # Evaluate proposal_required_if (any_true)
  local proposal_required="false"

  # Read thresholds from policy
  local file_threshold surface_threshold
  file_threshold="$(yq e -r '.decision_rules.proposal_required_if.any_true[] | select(test("changed_file_count"))' "$intake_policy" 2>/dev/null | head -1 || true)"
  surface_threshold="$(yq e -r '.decision_rules.proposal_required_if.any_true[] | select(test("changed_surface_count"))' "$intake_policy" 2>/dev/null | head -1 || true)"

  # Default thresholds from policy: changed_file_count >= 3, changed_surface_count >= 2
  local file_limit=3
  local surface_limit=2
  if [[ "$file_threshold" =~ ([0-9]+) ]]; then
    file_limit="${BASH_REMATCH[1]}"
  fi
  if [[ "$surface_threshold" =~ ([0-9]+) ]]; then
    surface_limit="${BASH_REMATCH[1]}"
  fi

  if (( file_count >= file_limit )); then
    proposal_required="true"
  fi
  if (( surface_count >= surface_limit )); then
    proposal_required="true"
  fi
  if [[ "$involves_cross_repo" == "true" ]]; then
    proposal_required="true"
  fi
  if [[ "$involves_multi_agent" == "true" ]]; then
    proposal_required="true"
  fi
  if [[ "$introduces_new_binding" == "true" ]]; then
    proposal_required="true"
  fi
  if [[ "$risk_severity" == "high" || "$risk_severity" == "critical" ]]; then
    proposal_required="true"
  fi

  # Classify change
  local change_class="single_mutation_low_risk"
  if [[ "$risk_severity" == "high" || "$risk_severity" == "critical" ]]; then
    change_class="high_risk_change"
  elif [[ "$proposal_required" == "true" ]]; then
    change_class="coordinated_multi_step"
  fi

  # Emit classification
  printf '  files=%d surfaces=%d cross_repo=%s multi_agent=%s new_binding=%s risk=%s\n' \
    "$file_count" "$surface_count" "$involves_cross_repo" "$involves_multi_agent" "$introduces_new_binding" "$risk_severity"
  printf '  classification: %s proposal_required: %s\n' "$change_class" "$proposal_required"

  # Enforcement: if proposal_required and this is a proposal apply, we're on the
  # correct path. But if the change class is high_risk_change, verify the manifest
  # declares appropriate approval context.
  if [[ "$change_class" == "high_risk_change" ]]; then
    local terminal_c_approval
    terminal_c_approval="$(yq e -r '.terminal_c_approval // ""' "$manifest" 2>/dev/null || true)"
    if [[ -z "$terminal_c_approval" || "$terminal_c_approval" == "null" ]]; then
      admission_add_finding "P1" "change_intake_policy" "high-risk change class requires terminal_c_approval in manifest (risk=$risk_severity)"
    fi
  fi

  # If proposal_required but the execution path expects preflight verify, check loop_id
  if [[ "$proposal_required" == "true" && -z "${loop_id:-}" ]]; then
    admission_add_finding "P1" "change_intake_policy" "proposal-required change missing loop_id (files=$file_count surfaces=$surface_count cross_repo=$involves_cross_repo)"
  fi
}

start_admission_task() {
  local task_id="$1"
  local task_fn="$2"

  local out_tmp findings_tmp rc_tmp
  out_tmp="$(mktemp "/tmp/spine-admission-${task_id}.out.XXXXXX")"
  findings_tmp="$(mktemp "/tmp/spine-admission-${task_id}.findings.XXXXXX")"
  rc_tmp="$(mktemp "/tmp/spine-admission-${task_id}.rc.XXXXXX")"

  (
    set +e
    ADMISSION_FINDINGS=()
    "$task_fn"
    local rc=$?
    printf '%s\n' "$rc" > "$rc_tmp"
    printf '%s\n' "${ADMISSION_FINDINGS[@]:-}" > "$findings_tmp"
    exit 0
  ) > "$out_tmp" 2>&1 &

  ADMISSION_TASK_IDS+=("$task_id")
  ADMISSION_TASK_PIDS+=($!)
  ADMISSION_TASK_OUTPUTS+=("$out_tmp")
  ADMISSION_TASK_FINDINGS+=("$findings_tmp")
  ADMISSION_TASK_RCS+=("$rc_tmp")
}

collect_admission_tasks() {
  local idx pid task_id out_tmp findings_tmp rc_tmp rc entry

  for pid in "${ADMISSION_TASK_PIDS[@]:-}"; do
    [[ -z "$pid" ]] && continue
    wait "$pid" 2>/dev/null || true
  done

  for ((idx=0; idx<${#ADMISSION_TASK_IDS[@]}; idx++)); do
    task_id="${ADMISSION_TASK_IDS[$idx]}"
    out_tmp="${ADMISSION_TASK_OUTPUTS[$idx]}"
    findings_tmp="${ADMISSION_TASK_FINDINGS[$idx]}"
    rc_tmp="${ADMISSION_TASK_RCS[$idx]}"

    [[ -f "$out_tmp" ]] && cat "$out_tmp"
    rc=1
    if [[ -f "$rc_tmp" ]] && read -r rc < "$rc_tmp"; then
      :
    fi
    if [[ ! "$rc" =~ ^[0-9]+$ ]]; then
      rc=1
    fi
    if (( rc != 0 )); then
      admission_add_finding "P0" "admission_runtime" "${task_id} admission check failed unexpectedly (rc=$rc)"
    fi

    if [[ -f "$findings_tmp" ]]; then
      while IFS= read -r entry; do
        [[ -n "$entry" ]] || continue
        ADMISSION_FINDINGS+=("$entry")
      done < "$findings_tmp"
    fi

    rm -f "$out_tmp" "$findings_tmp" "$rc_tmp" >/dev/null 2>&1 || true
  done
}

run_admission_controller() {
  echo "Running admission controller..."
  need_cmd yq
  need_cmd jq
  [[ -x "$VERIFY_TOPOLOGY_BIN" ]] || {
    echo "ERROR: verify topology runner not executable: $VERIFY_TOPOLOGY_BIN" >&2
    exit 1
  }

  load_admission_policy

  # Admission checks are independent; execute in parallel and merge findings deterministically.
  ADMISSION_TASK_IDS=()
  ADMISSION_TASK_PIDS=()
  ADMISSION_TASK_OUTPUTS=()
  ADMISSION_TASK_FINDINGS=()
  ADMISSION_TASK_RCS=()

  start_admission_task "domain-routing" run_domain_routing_admission
  start_admission_task "workbench-contract" run_workbench_contract_admission
  start_admission_task "ssot-schema" run_ssot_schema_conventions_admission
  start_admission_task "vertical-integration" run_vertical_integration_admission
  start_admission_task "loop-gap-linkage" run_loop_gap_linkage_admission
  start_admission_task "proposal-horizon" run_proposal_horizon_admission
  start_admission_task "gap-id-validity" run_gap_id_validity_admission
  start_admission_task "change-intake-policy" run_change_intake_policy_admission
  collect_admission_tasks

  emit_admission_summary_and_enforce
}

DRY_RUN=0
BOOTSTRAP_LOOP_SCOPE=0
while [[ "${1:-}" == --* ]]; do
  case "$1" in
    --) shift; break ;;
    --dry-run) DRY_RUN=1; shift ;;
    --bootstrap-loop-scope) BOOTSTRAP_LOOP_SCOPE=1; shift ;;
    *) echo "ERROR: Unknown flag: $1" >&2; usage; exit 2 ;;
  esac
done

PROPOSAL_NAME="${1:-}"
if [[ -z "$PROPOSAL_NAME" ]]; then
  usage
  exit 2
fi

SPINE_CODE="${SPINE_CODE:-.}"
WORKBENCH_ROOT="${WORKBENCH_ROOT:-$HOME/code/workbench}"
WORKBENCH_AOF_CHECKER="${WORKBENCH_AOF_CHECKER:-$WORKBENCH_ROOT/scripts/root/aof/workbench-aof-check.sh}"
PROPOSALS_DIR="$SPINE_CODE/mailroom/outbox/proposals"
PROPOSAL_DIR="$PROPOSALS_DIR/$PROPOSAL_NAME"
PROPOSALS_LIFECYCLE_CONTRACT="$SPINE_CODE/ops/bindings/proposals.lifecycle.yaml"
SCHEMA_CONVENTIONS_CONTRACT="$SPINE_CODE/ops/bindings/spine.schema.conventions.yaml"
VERTICAL_INTEGRATION_CONTRACT="$SPINE_CODE/ops/bindings/vertical.integration.admission.contract.yaml"
VERIFY_TOPOLOGY_BIN="$SPINE_CODE/ops/plugins/verify/bin/verify-topology"
GAPS_FILE="$SPINE_CODE/ops/bindings/operational.gaps.yaml"
CHANGE_INTAKE_POLICY="$SPINE_CODE/ops/bindings/change.intake.policy.yaml"
LOOP_SCOPES_DIR="$SPINE_CODE/mailroom/state/loop-scopes"

if [[ ! -d "$PROPOSAL_DIR" ]]; then
  echo "ERROR: Proposal not found: $PROPOSAL_DIR" >&2
  exit 1
fi

manifest="$PROPOSAL_DIR/manifest.yaml"
files_dir="$PROPOSAL_DIR/files"

if [[ ! -f "$manifest" ]]; then
  echo "ERROR: Manifest not found: $manifest" >&2
  exit 1
fi

if [[ -f "$PROPOSAL_DIR/.applied" ]]; then
  echo "ERROR: Proposal already applied: $PROPOSAL_NAME" >&2
  exit 1
fi

# Detect superseded or read-only proposals before attempting apply
manifest_status=$(awk -F': *' '/^status:/{print $2; exit}' "$manifest" | tr -d '"' || true)
read_only=$(awk -F': *' '/^read_only:/{print $2; exit}' "$manifest" | tr -d '"' || true)

if [[ "${manifest_status:-}" == "superseded" ]]; then
  echo "ERROR: Proposal is superseded: $PROPOSAL_NAME" >&2
  superseded_reason=$(awk -F': *' '/^superseded_reason:/{print $2; exit}' "$manifest" | tr -d '"' || true)
  [[ -n "${superseded_reason:-}" ]] && echo "  Reason: $superseded_reason" >&2
  exit 1
fi

if [[ "${read_only:-}" == "true" ]]; then
  echo "ERROR: Proposal is read-only (no file changes): $PROPOSAL_NAME" >&2
  exit 1
fi

cd "$SPINE_CODE"

if [[ -n "$(git status --porcelain)" ]]; then
  echo "ERROR: Working tree is not clean. Commit/stash before applying proposals." >&2
  git status --porcelain | sed -n '1,60p' >&2
  exit 1
fi

base_head="$(git rev-parse HEAD)"

agent=$(awk '/^agent:/{sub(/^agent: */, ""); gsub(/"/, ""); print; exit}' "$manifest")
created=$(awk '/^created:/{sub(/^created: */, ""); gsub(/"/, ""); print; exit}' "$manifest")
loop_id=$(awk '/^loop_id:/{sub(/^loop_id: */, ""); gsub(/"/, ""); print; exit}' "$manifest")
[[ "${loop_id:-}" == "null" ]] && loop_id=""

echo "Applying proposal: $PROPOSAL_NAME"
[[ -n "${loop_id:-}" ]] && echo "Loop: $loop_id"
[[ -n "${agent:-}" ]] && echo "Agent: $agent"
[[ -n "${created:-}" ]] && echo "Created: $created"
echo ""

# Staleness precheck: warn if proposal is old and paths may have drifted
STALE_THRESHOLD_DAYS=3
if [[ -n "${created:-}" ]]; then
  created_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "${created}" +%s 2>/dev/null || echo 0)
  if [[ "$created_epoch" -gt 0 ]]; then
    now_epoch=$(date +%s)
    age_days=$(( (now_epoch - created_epoch) / 86400 ))
    if [[ "$age_days" -gt "$STALE_THRESHOLD_DAYS" ]]; then
      echo "WARN: Proposal is ${age_days} days old (threshold: ${STALE_THRESHOLD_DAYS}d)"
      echo "  Paths may have drifted since creation."
      echo "  Recommendation: supersede + create successor if changes conflict with recent commits."
      echo ""
    fi
  fi
fi

changes_tmp="$(mktemp "/tmp/spine-proposal-changes.XXXXXX")"
trap 'rm -f "$changes_tmp" 2>/dev/null || true' EXIT INT TERM

awk '
  function trim(s) {
    gsub(/^[ \t]+/, "", s)
    gsub(/[ \t]+$/, "", s)
    gsub(/^"+|"+$/, "", s)
    return s
  }
  BEGIN { action=""; path=""; reason="" }
  /^[ \t]*-[ \t]*action:[ \t]*/ {
    if (action != "") { print action "\t" path "\t" reason }
    action = trim($0)
    sub(/^[ \t]*-[ \t]*action:[ \t]*/, "", action)
    path=""; reason=""
    next
  }
  /^[ \t]*path:[ \t]*/ {
    path = trim($0)
    sub(/^[ \t]*path:[ \t]*/, "", path)
    next
  }
  /^[ \t]*reason:[ \t]*/ {
    reason = trim($0)
    sub(/^[ \t]*reason:[ \t]*/, "", reason)
    next
  }
  END {
    if (action != "") { print action "\t" path "\t" reason }
  }
' "$manifest" > "$changes_tmp"

if [[ ! -s "$changes_tmp" ]]; then
  echo "ERROR: No actionable changes in manifest (changes may be empty or use nonstandard format): $manifest" >&2
  exit 1
fi

first_reason=""
had_error=0
while IFS=$'\t' read -r action path reason; do
  action="$(normalize_action "$action")"
  if [[ -z "${first_reason}" && -n "${reason:-}" ]]; then
    first_reason="$reason"
  fi

  case "$action" in
    create|modify|delete) ;;
    *)
      echo "ERROR: Invalid action '$action' in $manifest" >&2
      had_error=1
      ;;
  esac

  if ! validate_path "$path"; then
    echo "ERROR: Unsafe/invalid path '$path' in $manifest" >&2
    had_error=1
  fi
done < "$changes_tmp"

if [[ "$had_error" -ne 0 ]]; then
  echo "ERROR: Proposal manifest validation failed before admission checks." >&2
  exit 1
fi

# Phase B: inline loop scope bootstrap
if [[ "$BOOTSTRAP_LOOP_SCOPE" -eq 1 && -n "${loop_id:-}" ]]; then
  scope_rel="mailroom/state/loop-scopes/${loop_id}.scope.md"
  if [[ ! -f "$SPINE_CODE/$scope_rel" ]]; then
    echo "Bootstrap: creating loop scope for $loop_id"
    mkdir -p "$files_dir/mailroom/state/loop-scopes"
    cat > "$files_dir/$scope_rel" <<SCOPE
---
loop_id: $loop_id
status: active
created: $(date -u +%Y-%m-%dT%H:%M:%SZ)
---
# $loop_id

Bootstrapped by proposals-apply --bootstrap-loop-scope.
SCOPE
    # Inject synthetic create change before admission
    printf 'create\t%s\tbootstrap loop scope\n' "$scope_rel" >> "$changes_tmp"
  fi
fi

declare -a ADMISSION_FINDINGS=()
declare -a ADMISSION_BLOCK_ON=()
declare -a ADMISSION_WARN_ONLY=()
run_admission_controller

# Acquire a narrow lock for mutation only; admission checks run outside the lock.
if [[ "$DRY_RUN" -ne 1 ]]; then
  SPINE_REPO="${SPINE_REPO:-$SPINE_CODE}"
  acquire_git_lock proposals || exit 1
  trap 'release_git_lock; rm -f "$changes_tmp" 2>/dev/null || true' EXIT INT TERM

  current_head="$(git rev-parse HEAD)"
  if [[ "$current_head" != "$base_head" ]]; then
    echo "ERROR: HEAD changed during admission (before=$base_head after=$current_head). Re-run proposals.apply." >&2
    exit 1
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "ERROR: Working tree changed during admission. Re-run proposals.apply." >&2
    git status --porcelain | sed -n '1,60p' >&2
    exit 1
  fi

  if [[ -f "$PROPOSAL_DIR/.applied" ]]; then
    echo "ERROR: Proposal already applied by another session: $PROPOSAL_NAME" >&2
    exit 1
  fi
fi

while IFS=$'\t' read -r action path reason; do
  action="$(normalize_action "$action")"
  if [[ "$DRY_RUN" -eq 1 ]]; then
    printf "DRY RUN: %-6s %s\n" "$action" "$path"
    continue
  fi

  case "$action" in
    create|modify)
      src="$files_dir/$path"
      dst="$SPINE_CODE/$path"
      if [[ ! -f "$src" ]]; then
        echo "ERROR: Missing proposal file for $action: $src" >&2
        had_error=1
        continue
      fi
      if [[ -L "$src" ]]; then
        echo "ERROR: Proposal file must not be a symlink: $src" >&2
        had_error=1
        continue
      fi
      mkdir -p "$(dirname "$dst")"
      cp -p "$src" "$dst"
      git add -- "$path"
      if [[ "$action" == "create" ]]; then
        echo "✓ Create: $path"
      else
        echo "✓ Modify: $path"
      fi
      ;;
    delete)
      if [[ -e "$SPINE_CODE/$path" ]]; then
        git rm -f -- "$path" >/dev/null
        echo "✓ Delete: $path"
      else
        echo "WARN: Delete requested but file missing: $path"
      fi
      ;;
  esac
done < "$changes_tmp"

if [[ "$DRY_RUN" -eq 1 ]]; then
  echo ""
  if [[ "$had_error" -ne 0 ]]; then
    echo "DRY RUN: encountered proposal validation errors." >&2
    exit 1
  fi
  echo "DRY RUN: no files changed, nothing committed."
  exit 0
fi

if [[ "$had_error" -ne 0 ]]; then
  echo "ERROR: One or more changes could not be applied. Aborting." >&2
  exit 1
fi

if git diff --cached --quiet; then
  echo "ERROR: No staged changes after applying proposal. Refusing to commit." >&2
  exit 1
fi

subject=""
if [[ -n "${loop_id:-}" ]]; then
  subject="fix(${loop_id}): apply ${PROPOSAL_NAME}"
else
  subject="gov(${PROPOSAL_NAME}): ${first_reason:-apply proposal}"
fi

git commit -m "$subject" \
  -m "Proposal: ${PROPOSAL_NAME}" \
  -m "Agent: ${agent:-unknown}" \
  -m "Created: ${created:-unknown}" \
  -m "First reason: ${first_reason:-unknown}"

commit_sha="$(git rev-parse HEAD)"

{
  echo "Applied: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
  echo "Commit: ${commit_sha}"
} > "$PROPOSAL_DIR/.applied"

echo ""
echo "Proposal applied successfully."
echo "Commit: $commit_sha"
