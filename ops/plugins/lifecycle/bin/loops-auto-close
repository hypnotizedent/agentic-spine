#!/usr/bin/env bash
set -euo pipefail

# loops.auto.close — Auto-close loops whose gaps are all resolved
#
# Usage: loops-auto-close [--dry-run]
#
# Iterates all open scope files. For each with linked gaps all resolved,
# delegates to `ops loops close LOOP-ID`.

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)"
SCOPES_DIR="$ROOT/mailroom/state/loop-scopes"
GAPS_FILE="$ROOT/ops/bindings/operational.gaps.yaml"
PROPOSALS_DIR="$ROOT/mailroom/outbox/proposals"

source "$ROOT/ops/plugins/lifecycle/lib/lifecycle-rules.sh"

# Frontmatter field extractor (POSIX-compatible)
_fm_field() {
  local file="$1" field="$2"
  awk '/^---$/{n++; next} n==1{print} n>=2{exit}' "$file" \
    | { grep "^${field}:" || true; } \
    | sed "s/^${field}: *//" \
    | tr -d '"' \
    | head -1
}

# Return pending proposal count for a loop and emit matching proposal ids.
# Output format:
#   line 1: numeric pending count
#   line N: CP-... ids (one per line)
_pending_proposals_for_loop() {
  local loop_id="$1"
  local proposal_dir manifest status cp_loop_id
  local count=0
  local matches=""

  [[ -d "$PROPOSALS_DIR" ]] || {
    echo "0"
    return 0
  }

  for proposal_dir in "$PROPOSALS_DIR"/CP-*; do
    [[ -d "$proposal_dir" ]] || continue
    [[ -f "$proposal_dir/.applied" ]] && continue

    manifest="$proposal_dir/manifest.yaml"
    [[ -f "$manifest" ]] || continue

    status="$(awk -F': *' '/^status:/{print $2; exit}' "$manifest" | tr -d '"' | tr -d "'" || true)"
    [[ -z "$status" ]] && status="pending"
    [[ "$status" != "pending" ]] && continue

    cp_loop_id="$(awk -F': *' '/^loop_id:/{print $2; exit}' "$manifest" | tr -d '"' | tr -d "'" || true)"
    [[ "$cp_loop_id" == "null" ]] && cp_loop_id=""

    if [[ "$cp_loop_id" == "$loop_id" ]]; then
      count=$((count + 1))
      matches="${matches}$(basename "$proposal_dir")"$'\n'
    fi
  done

  echo "$count"
  if [[ -n "$matches" ]]; then
    printf '%s' "$matches"
  fi
}

DRY_RUN=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift ;;
    -h|--help)
      echo "Usage: loops-auto-close [--dry-run]"
      echo ""
      echo "Auto-close loops whose linked gaps are all resolved."
      exit 0 ;;
    *) echo "Unknown arg: $1" >&2; exit 2 ;;
  esac
done

echo "=== LOOPS AUTO-CLOSE ==="
[[ "$DRY_RUN" == "true" ]] && echo "(dry-run mode — no changes)"
echo ""

# Build JSON gap data once (temp file avoids heredoc+stdin conflict)
GAP_JSON_TMP="$(mktemp)"
trap 'rm -f "$GAP_JSON_TMP"' EXIT INT TERM
yq e -o=json '.' "$GAPS_FILE" > "$GAP_JSON_TMP" 2>/dev/null

closed_count=0
skipped_count=0

for scope_file in "$SCOPES_DIR"/*.scope.md; do
  [[ -f "$scope_file" ]] || continue

  local_status="$(_fm_field "$scope_file" "status")"
  case "$local_status" in
    active|draft|open) ;;
    *) continue ;;
  esac

  loop_id="$(_fm_field "$scope_file" "loop_id")"
  [[ -z "$loop_id" ]] && continue

  # Count linked gaps via python3
  eval "$(python3 - "$loop_id" "$GAP_JSON_TMP" <<'PY'
import json
import sys

loop_id = sys.argv[1]
json_file = sys.argv[2]
with open(json_file) as f:
    data = json.load(f)
gaps = data.get("gaps", [])
linked = [g for g in gaps if g.get("parent_loop") == loop_id]
total = len(linked)
open_count = sum(1 for g in linked if g.get("status") == "open")
print(f"TOTAL={total}")
print(f"OPEN={open_count}")
PY
)"

  # Skip zero-gap loops if configured
  if [[ "$TOTAL" -eq 0 ]]; then
    if [[ "$(loops_auto_close_skip_zero)" == "true" ]]; then
      echo "SKIP: $loop_id (0 linked gaps — requires manual close)"
      skipped_count=$((skipped_count + 1))
      continue
    fi
  fi

  # Skip if any gaps still open
  if [[ "$OPEN" -gt 0 ]]; then
    echo "SKIP: $loop_id ($OPEN/$TOTAL gaps still open)"
    skipped_count=$((skipped_count + 1))
    continue
  fi

  pending_blob="$(_pending_proposals_for_loop "$loop_id")"
  pending_count="$(printf '%s\n' "$pending_blob" | head -n1)"
  if [[ "${pending_count:-0}" -gt 0 ]]; then
    echo "SKIP: $loop_id ($pending_count pending linked proposal(s))"
    printf '%s\n' "$pending_blob" | tail -n +2 | sed '/^$/d' | sed 's/^/  - /'
    skipped_count=$((skipped_count + 1))
    continue
  fi

  if [[ "$DRY_RUN" == "true" ]]; then
    echo "WOULD-CLOSE: $loop_id ($TOTAL gaps, all resolved)"
  else
    "$ROOT/ops/commands/loops.sh" close "$loop_id"
    echo "CLOSED: $loop_id ($TOTAL gaps, all resolved)"
  fi
  closed_count=$((closed_count + 1))
done

echo ""
echo "Closed: $closed_count, Skipped: $skipped_count"
