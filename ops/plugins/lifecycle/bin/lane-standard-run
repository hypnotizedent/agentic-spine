#!/usr/bin/env bash
set -euo pipefail

# lane.standard.run — One-command daily lane runner.
#
# Runs:
#   - stability.control.snapshot
#   - verify.core.run (core-8 gates)
#   - services.health.status
#   - docker.compose.status docker-host
#   - docker.compose.status automation-stack
#   - alerting.status
#
# Emits markdown + json reports with run keys, phase results, and summary counts.
#
# Usage:
#   lane-standard-run [--skip-snapshot] [--continue-on-error] [--fail-fast] [--json]
#
# Flags:
#   --skip-snapshot        Skip stability.control.snapshot phase
#   --continue-on-error    Continue on failure (default behavior)
#   --fail-fast            Stop at first failure
#   --json                 Emit JSON envelope instead of text
#
# Exit codes:
#   0 = all phases passed
#   1 = one or more phases failed (or runtime error)

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)"
OPS="$ROOT/bin/ops"

SKIP_SNAPSHOT=0
CONTINUE_ON_ERROR=1
JSON_MODE=0
LEGACY_DOMAINS=""
WARNINGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --domains)
      LEGACY_DOMAINS="${2:-}"
      shift 2
      ;;
    --skip-snapshot)
      SKIP_SNAPSHOT=1
      shift
      ;;
    --continue-on-error)
      CONTINUE_ON_ERROR=1
      shift
      ;;
    --fail-fast)
      CONTINUE_ON_ERROR=0
      shift
      ;;
    --json)
      JSON_MODE=1
      shift
      ;;
    -h|--help)
      cat <<'USAGE'
lane-standard-run — One-command daily lane runner

Usage:
  lane-standard-run [--skip-snapshot] [--continue-on-error] [--fail-fast] [--json]

Flags:
  --skip-snapshot        Skip stability.control.snapshot phase
  --continue-on-error    Continue on failure (default behavior)
  --fail-fast            Stop at first failure
  --json                 Emit JSON envelope instead of text
USAGE
      exit 0
      ;;
    *)
      echo "FAIL: unknown arg: $1" >&2
      exit 2
      ;;
  esac
done

if [[ -n "$LEGACY_DOMAINS" ]]; then
  WARNINGS+=("--domains is deprecated for lane.standard.run daily lane and is ignored")
fi

# ── Internal state ──
TIMESTAMP="$(date -u +%Y%m%dT%H%M%SZ)"
REPORT_DIR="$ROOT/mailroom/outbox/operations/daily-lane"
mkdir -p "$REPORT_DIR"

REPORT_BASENAME="daily-lane-${TIMESTAMP}"
REPORT_FILE="$REPORT_DIR/${REPORT_BASENAME}.md"
REPORT_JSON_FILE="$REPORT_DIR/${REPORT_BASENAME}.json"
LATEST_REPORT_FILE="$REPORT_DIR/daily-lane-latest.md"
LATEST_REPORT_JSON_FILE="$REPORT_DIR/daily-lane-latest.json"

PHASE_RESULTS=()  # "phase_name|status|run_key|detail"
OVERALL_STATUS="pass"
TOTAL_PASS=0
TOTAL_FAIL=0
TOTAL_SKIP=0

# ── Helpers ──
run_phase() {
  local phase_name="$1"
  shift
  local -a cap_cmd=("$@")

  local output rc run_key
  output="$("$OPS" cap run "${cap_cmd[@]}" 2>&1)" && rc=0 || rc=$?

  run_key="$(echo "$output" | grep '^Run Key:' | head -1 | sed 's/^Run Key: *//')"
  [[ -z "$run_key" ]] && run_key="none"

  local status_str="pass"
  if [[ $rc -ne 0 ]]; then
    status_str="fail"
    TOTAL_FAIL=$((TOTAL_FAIL + 1))
    OVERALL_STATUS="fail"
  else
    TOTAL_PASS=$((TOTAL_PASS + 1))
  fi

  # Extract summary line
  local summary
  summary="$(echo "$output" | grep -E '^summary:|^Status:' | tail -1 | sed 's/^[^:]*: *//')"
  [[ -z "$summary" ]] && summary="rc=$rc"
  summary="${summary//|//}"

  PHASE_RESULTS+=("${phase_name}|${status_str}|${run_key}|${summary}")

  if [[ "$status_str" == "fail" && "$CONTINUE_ON_ERROR" -eq 0 ]]; then
    echo "STOP: $phase_name failed (rc=$rc). Use --continue-on-error to proceed past failures." >&2
    write_report
    exit 1
  fi
}

skip_phase() {
  local phase_name="$1"
  PHASE_RESULTS+=("${phase_name}|skip|none|skipped by flag")
  TOTAL_SKIP=$((TOTAL_SKIP + 1))
}

write_report() {
  {
    echo "# Daily Lane Report"
    echo ""
    echo "- Timestamp: $TIMESTAMP"
    echo "- Overall: ${OVERALL_STATUS^^}"
    echo "- Phases: pass=$TOTAL_PASS fail=$TOTAL_FAIL skip=$TOTAL_SKIP"
    if [[ ${#WARNINGS[@]} -gt 0 ]]; then
      echo ""
      echo "## Warnings"
      echo ""
      for warning in "${WARNINGS[@]}"; do
        echo "- $warning"
      done
    fi
    echo ""
    echo "## Phase Results"
    echo ""
    echo "| Phase | Status | Run Key | Detail |"
    echo "|-------|--------|---------|--------|"
    for row in "${PHASE_RESULTS[@]}"; do
      local ph st rk dt
      ph="$(echo "$row" | cut -d'|' -f1)"
      st="$(echo "$row" | cut -d'|' -f2)"
      rk="$(echo "$row" | cut -d'|' -f3)"
      dt="$(echo "$row" | cut -d'|' -f4)"
      echo "| $ph | $st | \`$rk\` | $dt |"
    done
    echo ""
    echo "## Summary"
    echo ""
    echo "- Total phases: $((TOTAL_PASS + TOTAL_FAIL + TOTAL_SKIP))"
    echo "- Pass: $TOTAL_PASS"
    echo "- Fail: $TOTAL_FAIL"
    echo "- Skip: $TOTAL_SKIP"
    echo ""
    echo "## Artifacts"
    echo ""
    echo "- Timestamped markdown: \`$REPORT_FILE\`"
    echo "- Latest markdown: \`$LATEST_REPORT_FILE\`"
    echo "- Timestamped json: \`$REPORT_JSON_FILE\`"
    echo "- Latest json: \`$LATEST_REPORT_JSON_FILE\`"
    echo ""
    echo "---"
    echo "STOP"
  } > "$REPORT_FILE"

  cp "$REPORT_FILE" "$LATEST_REPORT_FILE"
}

write_json_report() {
  local phases_json
  phases_json="$(
    printf '%s\n' "${PHASE_RESULTS[@]}" \
      | jq -R -s '
          split("\n")
          | map(select(length > 0))
          | map(split("|"))
          | map({
              phase: .[0],
              status: .[1],
              run_key: .[2],
              detail: .[3]
            })
        '
  )"

  local warnings_json
  warnings_json="$(
    printf '%s\n' "${WARNINGS[@]}" \
      | jq -R -s 'split("\n") | map(select(length > 0))'
  )"

  jq -n \
    --arg timestamp "$TIMESTAMP" \
    --arg overall "$OVERALL_STATUS" \
    --argjson pass "$TOTAL_PASS" \
    --argjson fail "$TOTAL_FAIL" \
    --argjson skip "$TOTAL_SKIP" \
    --arg timestamped_markdown "$REPORT_FILE" \
    --arg latest_markdown "$LATEST_REPORT_FILE" \
    --arg timestamped_json "$REPORT_JSON_FILE" \
    --arg latest_json "$LATEST_REPORT_JSON_FILE" \
    --argjson phases "$phases_json" \
    --argjson warnings "$warnings_json" \
    '{
      capability: "lane.standard.run",
      lane: "daily",
      generated_at: $timestamp,
      overall: $overall,
      phases: {pass: $pass, fail: $fail, skip: $skip},
      checks: $phases,
      warnings: $warnings,
      artifacts: {
        timestamped_markdown: $timestamped_markdown,
        latest_markdown: $latest_markdown,
        timestamped_json: $timestamped_json,
        latest_json: $latest_json
      }
    }' > "$REPORT_JSON_FILE"

  cp "$REPORT_JSON_FILE" "$LATEST_REPORT_JSON_FILE"
}

# ── Execute sequence ──

# Phase 1: Stability snapshot
if [[ "$SKIP_SNAPSHOT" -eq 1 ]]; then
  skip_phase "stability.control.snapshot"
else
  run_phase "stability.control.snapshot" stability.control.snapshot
fi

# Phase 2: Core verify (core-8 gates — same as old pack.run core-operator)
run_phase "verify.core.run" verify.core.run

# Phase 3: Runtime checks
run_phase "services.health.status" services.health.status
run_phase "docker.compose.status docker-host" docker.compose.status docker-host
run_phase "docker.compose.status automation-stack" docker.compose.status automation-stack
run_phase "alerting.status" alerting.status

# ── Write report ──
write_report
write_json_report

# ── Output ──
if [[ "$JSON_MODE" -eq 1 ]]; then
  cat "$LATEST_REPORT_JSON_FILE"
else
  echo "lane.standard.run"
  echo "timestamp: $TIMESTAMP"
  echo "overall: ${OVERALL_STATUS^^}"
  echo "phases: pass=$TOTAL_PASS fail=$TOTAL_FAIL skip=$TOTAL_SKIP"
  echo "report_timestamped: $REPORT_FILE"
  echo "report_latest: $LATEST_REPORT_FILE"
  echo "report_json_timestamped: $REPORT_JSON_FILE"
  echo "report_json_latest: $LATEST_REPORT_JSON_FILE"
  if [[ ${#WARNINGS[@]} -gt 0 ]]; then
    for warning in "${WARNINGS[@]}"; do
      echo "warning: $warning"
    done
  fi
  echo ""
  for row in "${PHASE_RESULTS[@]}"; do
    ph="$(echo "$row" | cut -d'|' -f1)"
    st="$(echo "$row" | cut -d'|' -f2)"
    rk="$(echo "$row" | cut -d'|' -f3)"
    echo "  $ph: $st ($rk)"
  done
fi

if [[ "$OVERALL_STATUS" == "fail" ]]; then
  exit 1
fi
exit 0
