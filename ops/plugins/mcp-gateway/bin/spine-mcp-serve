#!/usr/bin/env python3
"""
Unified spine MCP gateway.

Exposes governed capabilities via stdio JSON-RPC (MCP) with:
  - cap_list
  - cap_run
  - agent_list / agent_info / agent_tools / route_resolve
  - rag_query / rag_retrieve / rag_health compatibility wrappers
"""

import json
import os
import re
import shlex
import subprocess
import sys
from typing import Any, Dict, List, Optional, Tuple


def _repo_root() -> str:
    return os.path.abspath(
        os.path.join(os.path.dirname(__file__), "..", "..", "..", "..")
    )


SPINE_ROOT = os.environ.get("SPINE_ROOT", _repo_root())
OPS_BIN = os.path.join(SPINE_ROOT, "bin", "ops")
CAPABILITIES_FILE = os.path.join(SPINE_ROOT, "ops", "capabilities.yaml")
SECRETS_EXEC = os.path.join(SPINE_ROOT, "ops", "plugins", "secrets", "bin", "secrets-exec")
RAG_BIN = os.path.join(SPINE_ROOT, "ops", "plugins", "rag", "bin", "rag")
AGENTS_REGISTRY_FILE = os.path.join(SPINE_ROOT, "ops", "bindings", "agents.registry.yaml")
AGENT_INFO_BIN = os.path.join(SPINE_ROOT, "ops", "plugins", "agent", "bin", "agent-info")
AGENT_TOOLS_BIN = os.path.join(SPINE_ROOT, "ops", "plugins", "agent", "bin", "agent-tools")
AGENT_ROUTE_BIN = os.path.join(SPINE_ROOT, "ops", "plugins", "agent", "bin", "agent-route")
SAFE_NAME = re.compile(r"^[A-Za-z0-9._-]+$")
RUNTIME_ENV = dict(os.environ)

TOOLS = [
    {
        "name": "cap_list",
        "description": (
            "List governed capabilities from ops/capabilities.yaml. "
            "Optional filters: substring match and safety level."
        ),
        "inputSchema": {
            "type": "object",
            "properties": {
                "filter": {
                    "type": "string",
                    "description": "Optional case-insensitive substring on capability name"
                },
                "safety": {
                    "type": "string",
                    "enum": ["read-only", "mutating", "destructive"],
                    "description": "Optional safety-level filter"
                }
            }
        }
    },
    {
        "name": "cap_run",
        "description": (
            "Run a governed capability through ./bin/ops cap run. "
            "Manual-approval capabilities require confirm=true."
        ),
        "inputSchema": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Capability name from ops/capabilities.yaml"
                },
                "args": {
                    "description": "Capability arguments as array (preferred) or shell-style string",
                    "oneOf": [
                        {"type": "array", "items": {"type": "string"}},
                        {"type": "string"}
                    ]
                },
                "confirm": {
                    "type": "boolean",
                    "description": "Set true to forward 'yes' for manual approval prompts"
                }
            },
            "required": ["name"]
        }
    },
    {
        "name": "agent_list",
        "description": "List agents from agents.registry.yaml with optional filters.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "filter": {
                    "type": "string",
                    "description": "Optional case-insensitive substring filter on agent id/domain/description",
                },
                "domain": {
                    "type": "string",
                    "description": "Optional exact domain filter",
                },
                "status": {
                    "type": "string",
                    "description": "Optional exact implementation_status filter",
                },
            },
        },
    },
    {
        "name": "agent_info",
        "description": "Fetch full machine-readable registry entry for one agent.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "agent_id": {"type": "string", "description": "Agent ID from agents.registry.yaml"}
            },
            "required": ["agent_id"],
        },
    },
    {
        "name": "agent_tools",
        "description": "Fetch tool/capability inventory for one agent.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "agent_id": {"type": "string", "description": "Agent ID from agents.registry.yaml"}
            },
            "required": ["agent_id"],
        },
    },
    {
        "name": "route_resolve",
        "description": "Resolve input to an agent using agent.route --json envelope contract.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "input": {"type": "string", "description": "Domain or keyword to resolve"},
            },
            "required": ["input"],
        },
    },
    {
        "name": "rag_query",
        "description": "Compatibility wrapper for legacy RAG MCP query tool.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "question": {"type": "string", "description": "Question for RAG workspace"}
            },
            "required": ["question"]
        }
    },
    {
        "name": "rag_retrieve",
        "description": "Compatibility wrapper for legacy RAG MCP retrieve tool.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "Search query"},
                "limit": {
                    "type": "integer",
                    "description": "Maximum results (default: 5)",
                    "default": 5
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "rag_health",
        "description": "Compatibility wrapper for legacy RAG MCP health tool.",
        "inputSchema": {"type": "object", "properties": {}}
    }
]


def read_message() -> Tuple[Optional[Dict[str, Any]], bool]:
    while True:
        line = sys.stdin.readline()
        if line == "":
            return None, True
        line = line.strip()
        if not line:
            continue
        try:
            return json.loads(line), False
        except json.JSONDecodeError:
            continue


def write_message(payload: Dict[str, Any]) -> None:
    sys.stdout.write(json.dumps(payload) + "\n")
    sys.stdout.flush()


def sanitize_noise(text: str) -> str:
    lines = []
    for line in (text or "").splitlines():
        lower = line.lower()
        if "new release of infisical" in lower:
            continue
        if "brew update" in lower:
            continue
        if line.startswith("INF "):
            continue
        if "Injecting" in line:
            continue
        lines.append(line)
    return "\n".join(lines).strip()


def run_cmd(
    args: List[str],
    *,
    stdin_text: Optional[str] = None,
    timeout: int = 180,
) -> Tuple[int, str, str]:
    result = subprocess.run(
        args,
        cwd=SPINE_ROOT,
        input=stdin_text,
        capture_output=True,
        text=True,
        env=RUNTIME_ENV,
        timeout=timeout,
    )
    stdout = sanitize_noise(result.stdout)
    stderr = sanitize_noise(result.stderr)
    return result.returncode, stdout, stderr


def load_capabilities() -> Dict[str, Any]:
    code, out, err = run_cmd(
        ["yq", "e", "-o=json", ".capabilities", CAPABILITIES_FILE],
        timeout=30,
    )
    if code != 0:
        raise RuntimeError(f"failed to read capability registry: {err or out}")
    try:
        parsed = json.loads(out or "{}")
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"invalid capabilities json output: {exc}") from exc
    if not isinstance(parsed, dict):
        raise RuntimeError("capability registry did not parse as an object")
    return parsed


def load_agents_registry() -> Dict[str, Any]:
    code, out, err = run_cmd(
        ["yq", "e", "-o=json", ".", AGENTS_REGISTRY_FILE],
        timeout=30,
    )
    if code != 0:
        raise RuntimeError(f"failed to read agent registry: {err or out}")
    try:
        parsed = json.loads(out or "{}")
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"invalid agent registry json output: {exc}") from exc
    if not isinstance(parsed, dict):
        raise RuntimeError("agent registry did not parse as an object")
    return parsed


def normalize_cap_args(raw: Any) -> List[str]:
    if raw is None:
        return []
    if isinstance(raw, list):
        return [str(x) for x in raw]
    if isinstance(raw, str):
        return shlex.split(raw)
    raise RuntimeError("args must be an array of strings or a string")


def run_capability(name: str, cap_args: List[str], confirm: bool) -> str:
    if not SAFE_NAME.match(name or ""):
        raise RuntimeError("invalid capability name")

    capabilities = load_capabilities()
    meta = capabilities.get(name)
    if not isinstance(meta, dict):
        raise RuntimeError(f"unknown capability: {name}")

    approval = str(meta.get("approval", "")).strip()
    cmd = [OPS_BIN, "cap", "run", name, *cap_args]
    stdin_text = None

    if approval == "manual":
        if not confirm:
            raise RuntimeError(
                f"capability '{name}' requires manual approval; "
                "rerun with confirm=true to forward approval"
            )
        stdin_text = "yes\n"

    code, out, err = run_cmd(cmd, stdin_text=stdin_text, timeout=600)
    if code != 0:
        detail = err or out or "no output"
        raise RuntimeError(f"cap_run failed for {name} (rc={code}): {detail}")
    if err:
        return f"{out}\n{err}".strip()
    return out or "(no output)"


def list_capabilities(filter_text: Optional[str], safety: Optional[str]) -> str:
    capabilities = load_capabilities()
    rows = []
    needle = (filter_text or "").strip().lower()
    safety_filter = (safety or "").strip()

    for name in sorted(capabilities.keys()):
        meta = capabilities.get(name) or {}
        cap_safety = str(meta.get("safety", "")).strip()
        if needle and needle not in name.lower():
            continue
        if safety_filter and cap_safety != safety_filter:
            continue
        rows.append({
            "name": name,
            "safety": cap_safety,
            "approval": str(meta.get("approval", "")).strip(),
            "description": str(meta.get("description", "")).strip(),
        })

    return json.dumps(
        {
            "count": len(rows),
            "capabilities": rows,
        },
        indent=2,
        sort_keys=False,
    )


def list_agents(filter_text: Optional[str], domain: Optional[str], status: Optional[str]) -> str:
    registry = load_agents_registry()
    agents = registry.get("agents") or []
    if not isinstance(agents, list):
        agents = []

    needle = (filter_text or "").strip().lower()
    domain_filter = (domain or "").strip()
    status_filter = (status or "").strip()

    rows: List[Dict[str, Any]] = []
    for agent in agents:
        if not isinstance(agent, dict):
            continue
        agent_id = str(agent.get("id", "")).strip()
        agent_domain = str(agent.get("domain", "")).strip()
        agent_status = str(agent.get("implementation_status", "")).strip()
        agent_description = str(agent.get("description", "")).strip()
        agent_contract = str(agent.get("contract", "")).strip()
        if domain_filter and agent_domain != domain_filter:
            continue
        if status_filter and agent_status != status_filter:
            continue
        if needle:
            haystack = f"{agent_id} {agent_domain} {agent_description}".lower()
            if needle not in haystack:
                continue
        rows.append(
            {
                "id": agent_id,
                "domain": agent_domain,
                "status": agent_status,
                "description": agent_description,
                "contract": agent_contract,
            }
        )

    rows.sort(key=lambda row: row.get("id", ""))
    return json.dumps(
        {
            "count": len(rows),
            "agents": rows,
        },
        indent=2,
        sort_keys=False,
    )


def _json_from_cmd(args: List[str], *, timeout: int = 120) -> Dict[str, Any]:
    code, out, err = run_cmd(args, timeout=timeout)
    text = (out or "").strip() or (err or "").strip()
    if not text:
        raise RuntimeError(f"empty output from command: {' '.join(args)}")
    try:
        parsed = json.loads(text)
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"expected JSON output from command: {' '.join(args)}") from exc
    if not isinstance(parsed, dict):
        raise RuntimeError(f"expected JSON object output from command: {' '.join(args)}")
    if code != 0:
        status = str(parsed.get("status", "")).strip()
        if status not in {"not_found", "error"}:
            raise RuntimeError(f"command failed (rc={code}): {text}")
    return parsed


def agent_info(agent_id: str) -> str:
    agent_id = (agent_id or "").strip()
    if not agent_id:
        raise RuntimeError("agent_id is required")
    payload = _json_from_cmd([AGENT_INFO_BIN, agent_id, "--json"])
    return json.dumps(payload, indent=2, sort_keys=False)


def agent_tools(agent_id: str) -> str:
    agent_id = (agent_id or "").strip()
    if not agent_id:
        raise RuntimeError("agent_id is required")
    payload = _json_from_cmd([AGENT_TOOLS_BIN, agent_id, "--json"])
    return json.dumps(payload, indent=2, sort_keys=False)


def route_resolve(input_value: str) -> str:
    input_value = (input_value or "").strip()
    if not input_value:
        raise RuntimeError("input is required")
    payload = _json_from_cmd([AGENT_ROUTE_BIN, "--json", input_value])
    return json.dumps(payload, indent=2, sort_keys=False)


def run_rag(subcommand: str, *args: str) -> str:
    cmd = [SECRETS_EXEC, "--", RAG_BIN, subcommand, *args]
    code, out, err = run_cmd(cmd, timeout=300)
    if code != 0:
        raise RuntimeError(f"rag {subcommand} failed (rc={code}): {err or out}")
    if err:
        return f"{out}\n{err}".strip()
    return out or "(no output)"


def handle_initialize(msg: Dict[str, Any]) -> Dict[str, Any]:
    return {
        "jsonrpc": "2.0",
        "id": msg["id"],
        "result": {
            "protocolVersion": "2024-11-05",
            "capabilities": {"tools": {}},
            "serverInfo": {"name": "spine-mcp-gateway", "version": "1.0.0"},
        },
    }


def handle_tools_list(msg: Dict[str, Any]) -> Dict[str, Any]:
    return {
        "jsonrpc": "2.0",
        "id": msg["id"],
        "result": {"tools": TOOLS},
    }


def handle_tools_call(msg: Dict[str, Any]) -> Dict[str, Any]:
    name = msg.get("params", {}).get("name")
    arguments = msg.get("params", {}).get("arguments", {})

    try:
        if name == "cap_list":
            text = list_capabilities(
                arguments.get("filter"),
                arguments.get("safety"),
            )
        elif name == "cap_run":
            cap_name = arguments.get("name", "")
            cap_args = normalize_cap_args(arguments.get("args"))
            confirm_raw = arguments.get("confirm", False)
            if not isinstance(confirm_raw, bool):
                raise RuntimeError("confirm must be a boolean")
            confirm = confirm_raw
            text = run_capability(cap_name, cap_args, confirm)
        elif name == "agent_list":
            text = list_agents(
                arguments.get("filter"),
                arguments.get("domain"),
                arguments.get("status"),
            )
        elif name == "agent_info":
            text = agent_info(str(arguments.get("agent_id", "")))
        elif name == "agent_tools":
            text = agent_tools(str(arguments.get("agent_id", "")))
        elif name == "route_resolve":
            text = route_resolve(str(arguments.get("input", "")))
        elif name == "rag_query":
            text = run_capability(
                "rag.anythingllm.ask",
                [arguments["question"]],
                False,
            )
        elif name == "rag_retrieve":
            limit = int(arguments.get("limit", 5))
            text = run_rag("retrieve", arguments["query"], "--limit", str(limit))
        elif name == "rag_health":
            text = run_capability("rag.health", [], False)
        else:
            return {
                "jsonrpc": "2.0",
                "id": msg["id"],
                "error": {"code": -32601, "message": f"Unknown tool: {name}"},
            }

        return {
            "jsonrpc": "2.0",
            "id": msg["id"],
            "result": {
                "content": [{"type": "text", "text": text}]
            },
        }
    except Exception as exc:
        return {
            "jsonrpc": "2.0",
            "id": msg.get("id"),
            "result": {
                "content": [{"type": "text", "text": f"Error: {exc}"}],
                "isError": True,
            },
        }


def main() -> int:
    terminal_role = (
        RUNTIME_ENV.get("OPS_TERMINAL_ROLE")
        or RUNTIME_ENV.get("SPINE_TERMINAL_ROLE")
        or RUNTIME_ENV.get("SPINE_TERMINAL_NAME")
        or "unset"
    )
    runtime_role = RUNTIME_ENV.get("SPINE_RUNTIME_ROLE") or "researcher"
    print(
        f"[spine-mcp-serve] terminal_role={terminal_role} runtime_role={runtime_role}",
        file=sys.stderr,
    )

    while True:
        msg, eof = read_message()
        if eof:
            break
        if msg is None:
            continue

        method = msg.get("method")
        msg_id = msg.get("id")

        if method == "initialize":
            write_message(handle_initialize(msg))
        elif method == "notifications/initialized":
            continue
        elif method == "tools/list":
            write_message(handle_tools_list(msg))
        elif method == "tools/call":
            write_message(handle_tools_call(msg))
        elif method == "ping":
            write_message({"jsonrpc": "2.0", "id": msg_id, "result": {}})
        elif msg_id is not None:
            write_message(
                {
                    "jsonrpc": "2.0",
                    "id": msg_id,
                    "error": {
                        "code": -32601,
                        "message": f"Method not found: {method}",
                    },
                }
            )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
