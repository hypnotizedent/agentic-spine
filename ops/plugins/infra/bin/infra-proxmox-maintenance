#!/usr/bin/env bash
# infra-proxmox-maintenance - Receipt-backed Proxmox maintenance helpers
#
# Modes:
#   --mode precheck   : capture current guest state + MD1400/PM8072 evidence
#   --mode shutdown   : (mutating) graceful shutdown guests, then optional host poweroff
#   --mode startup    : (mutating) start guests, then run spine health checks
#
# Safety gate:
#   By default, shutdown refuses to proceed unless network.oob.guard.status passes.
#
# Usage:
#   infra-proxmox-maintenance --mode precheck --host-id pve
#   infra-proxmox-maintenance --mode shutdown --host-id pve --execute
#   infra-proxmox-maintenance --mode shutdown --host-id pve --execute --poweroff
#   infra-proxmox-maintenance --mode startup  --host-id pve --execute
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"

if [[ ! -f "$SSH_BINDING" ]]; then
  echo "STOP (2): missing binding file: $SSH_BINDING"
  exit 2
fi
if ! command -v yq >/dev/null 2>&1; then
  echo "STOP (2): yq is required but not found"
  echo "Install: brew install yq"
  exit 2
fi
if ! command -v python3 >/dev/null 2>&1; then
  echo "STOP (2): python3 required but not found"
  exit 2
fi

MODE=""
HOST_ID="pve"
EXECUTE=0
POWEROFF=0
SKIP_OOB_GUARD=0
SHUTDOWN_TIMEOUT_SEC=180

while [[ $# -gt 0 ]]; do
  case "$1" in
    --)
      shift
      ;;
    --mode) MODE="${2:-}"; shift 2 ;;
    --host-id) HOST_ID="${2:-}"; shift 2 ;;
    --execute) EXECUTE=1; shift ;;
    --dry-run) EXECUTE=0; shift ;;
    --poweroff) POWEROFF=1; shift ;;
    --skip-oob-guard) SKIP_OOB_GUARD=1; shift ;;
    --shutdown-timeout-sec) SHUTDOWN_TIMEOUT_SEC="${2:-180}"; shift 2 ;;
    -h|--help)
      sed -n '1,60p' "$0" | sed 's/^# //'
      exit 0
      ;;
    *)
      echo "STOP (2): unknown arg: $1"
      exit 2
      ;;
  esac
done

[[ -n "$MODE" ]] || { echo "STOP (2): --mode required (precheck|shutdown|startup)"; exit 2; }

target_host="$(yq -r ".ssh.targets[] | select(.id==\"$HOST_ID\") | .host" "$SSH_BINDING" 2>/dev/null || true)"
target_user="$(yq -r ".ssh.targets[] | select(.id==\"$HOST_ID\") | .user // \"root\"" "$SSH_BINDING" 2>/dev/null || true)"
target_port="$(yq -r ".ssh.targets[] | select(.id==\"$HOST_ID\") | .port // 22" "$SSH_BINDING" 2>/dev/null || true)"
timeout="$(yq -r '.ssh.defaults.connect_timeout_sec // 5' "$SSH_BINDING" 2>/dev/null || echo "5")"
strict="$(yq -r '.ssh.defaults.strict_host_key_checking // "no"' "$SSH_BINDING" 2>/dev/null || echo "no")"
known_hosts="$(yq -r '.ssh.defaults.user_known_hosts_file // "/dev/null"' "$SSH_BINDING" 2>/dev/null || echo "/dev/null")"

if [[ -z "${target_host:-}" || "${target_host:-}" == "null" ]]; then
  echo "STOP (2): unknown host-id or missing host binding: $HOST_ID"
  exit 2
fi

ssh_opts=(
  -o "ConnectTimeout=${timeout}"
  -o "StrictHostKeyChecking=${strict}"
  -o "UserKnownHostsFile=${known_hosts}"
  -o "NumberOfPasswordPrompts=0"
  -o "LogLevel=ERROR"
  -o "BatchMode=yes"
)

ssh_pve() {
  ssh "${ssh_opts[@]}" -p "$target_port" "${target_user}@${target_host}" "$@"
}

echo "infra.proxmox.maintenance"
echo "mode: $MODE"
echo "host_id: $HOST_ID"
echo "target: ${target_user}@${target_host}:${target_port}"
echo "execute: $( [[ "$EXECUTE" -eq 1 ]] && echo true || echo false )"
echo "poweroff: $( [[ "$POWEROFF" -eq 1 ]] && echo true || echo false )"
echo

capture_guest_state() {
  echo "proxmox.guests"
  ssh_pve 'qm list 2>/dev/null || true'
  echo
  ssh_pve 'pct list 2>/dev/null || true'
  echo
  echo "proxmox.running_ids"
  ssh_pve "qm list 2>/dev/null | awk 'NR>1 && \$3==\"running\" {print \$1}' || true"
  ssh_pve "pct list 2>/dev/null | awk 'NR>1 && \$2==\"running\" {print \$1}' || true"
  echo
}

capture_md1400_evidence() {
  echo "md1400.evidence"
  echo "pm80xx.config"
  ssh_pve 'ls -la /etc/modules-load.d/pm80xx.conf /etc/modprobe.d/pm80xx.conf 2>/dev/null || true'
  ssh_pve 'echo "--- /etc/modules-load.d/pm80xx.conf"; sed -n "1,120p" /etc/modules-load.d/pm80xx.conf 2>/dev/null || true'
  ssh_pve 'echo "--- /etc/modprobe.d/pm80xx.conf"; sed -n "1,200p" /etc/modprobe.d/pm80xx.conf 2>/dev/null || true'
  echo
  echo "lspci.pm8072"
  ssh_pve 'lspci -nnk -s 82:00.0 2>/dev/null || echo "WARN: pm8072 not present at 82:00.0 (verify slot/bdf)"'
  echo
  echo "dmesg.pm80xx"
  ssh_pve 'dmesg -T 2>/dev/null | grep -En "pm80xx|pm8001|FW is not ready|chip_init failed|mpi_uninit_check|probe failed" || true'
  echo
  echo "lsblk"
  ssh_pve 'lsblk -e7 2>/dev/null || true'
  echo
  echo "scsi.scan"
  ssh_pve 'ls -la /sys/class/scsi_host 2>/dev/null || true'
  echo
}

oob_guard() {
  if [[ "$SKIP_OOB_GUARD" -eq 1 ]]; then
    echo "oob.guard: SKIP (requested)"
    echo
    return 0
  fi

  echo "oob.guard"
  set +e
  "$SPINE_ROOT/ops/plugins/network/bin/network-oob-guard-status"
  rc=$?
  set -e
  echo
  if [[ "$rc" -ne 0 ]]; then
    echo "STOP (2): OOB guard failed; refusing to proceed with shutdown"
    exit 2
  fi
}

shutdown_guests() {
  mapfile -t running_qm < <(ssh_pve "qm list 2>/dev/null | awk 'NR>1 && \$3==\"running\" {print \$1}'" || true)
  mapfile -t running_pct < <(ssh_pve "pct list 2>/dev/null | awk 'NR>1 && \$2==\"running\" {print \$1}'" || true)

  echo "shutdown.plan"
  echo "- qm_running: ${#running_qm[@]}"
  echo "- pct_running: ${#running_pct[@]}"
  echo "- shutdown_timeout_sec: $SHUTDOWN_TIMEOUT_SEC"
  echo

  if [[ "$EXECUTE" -ne 1 ]]; then
    echo "dry_run: would attempt graceful shutdown for all running guests, then force-stop any stragglers."
    return 0
  fi

  preferred=(210 209 207 206 205 202 201 200 204)

  declare -A is_running=()
  for id in "${running_qm[@]}"; do is_running["qm:$id"]=1; done
  for id in "${running_pct[@]}"; do is_running["pct:$id"]=1; done

  echo "shutdown.exec"

  for id in "${preferred[@]}"; do
    if [[ -n "${is_running["qm:$id"]:-}" ]]; then
      echo "- qm $id: shutdown"
      ssh_pve "qm shutdown $id --timeout $SHUTDOWN_TIMEOUT_SEC >/dev/null 2>&1 || true"
      state="$(ssh_pve "qm status $id 2>/dev/null | awk '{print \$2}'" || echo "unknown")"
      if [[ "$state" == "running" ]]; then
        echo "  qm $id: stop (still running after timeout)"
        ssh_pve "qm stop $id >/dev/null 2>&1 || true"
      fi
      unset 'is_running[qm:'"$id"']'
    fi
  done

  for key in "${!is_running[@]}"; do
    [[ "$key" == qm:* ]] || continue
    id="${key#qm:}"
    echo "- qm $id: shutdown (unordered)"
    ssh_pve "qm shutdown $id --timeout $SHUTDOWN_TIMEOUT_SEC >/dev/null 2>&1 || true"
    state="$(ssh_pve "qm status $id 2>/dev/null | awk '{print \$2}'" || echo "unknown")"
    if [[ "$state" == "running" ]]; then
      echo "  qm $id: stop (still running after timeout)"
      ssh_pve "qm stop $id >/dev/null 2>&1 || true"
    fi
  done

  for id in "${running_pct[@]}"; do
    echo "- pct $id: shutdown"
    ssh_pve "pct shutdown $id --timeout $SHUTDOWN_TIMEOUT_SEC >/dev/null 2>&1 || true"
    state="$(ssh_pve "pct status $id 2>/dev/null | awk '{print \$2}'" || echo "unknown")"
    if [[ "$state" == "running" ]]; then
      echo "  pct $id: stop (still running after timeout)"
      ssh_pve "pct stop $id >/dev/null 2>&1 || true"
    fi
  done

  echo
  echo "shutdown.verify"
  ssh_pve 'qm list 2>/dev/null || true'
  echo
  ssh_pve 'pct list 2>/dev/null || true'
  echo
}

startup_guests() {
  if [[ "$EXECUTE" -ne 1 ]]; then
    echo "dry_run: would start key guests in preferred order, then run spine checks."
    return 0
  fi

  preferred=(204 205 206 207 209 210 200 202 201)
  echo "startup.exec"
  for id in "${preferred[@]}"; do
    echo "- qm $id: start"
    ssh_pve "qm start $id >/dev/null 2>&1 || true"
  done

  echo
  echo "startup.verify"
  ssh_pve 'qm list 2>/dev/null || true'
  echo
}

case "$MODE" in
  precheck)
    capture_guest_state
    capture_md1400_evidence
    echo "status: OK"
    ;;

  shutdown)
    oob_guard
    capture_guest_state
    shutdown_guests
    if [[ "$EXECUTE" -eq 1 && "$POWEROFF" -eq 1 ]]; then
      echo "host.poweroff"
      echo "- action: poweroff $HOST_ID"
      echo "- note: if you need a *true* cold cycle, remove AC for 10-20s after shutdown (flea power drain)."
      ssh_pve 'poweroff' >/dev/null 2>&1 || true
    else
      echo "host.poweroff: SKIP (use --poweroff to poweroff the host after guests stop)"
    fi
    echo
    echo "status: OK"
    ;;

  startup)
    capture_md1400_evidence
    startup_guests
    echo "postchecks"
    echo "- run: ./bin/ops cap run spine.verify"
    echo "- run: ./bin/ops cap run ssh.target.status"
    echo "- run: ./bin/ops cap run docker.compose.status"
    echo "- run: ./bin/ops cap run services.health.status"
    echo
    echo "status: OK"
    ;;

  *)
    echo "STOP (2): unknown mode: $MODE"
    exit 2
    ;;
esac
