#!/usr/bin/env bash
# infra-maintenance-window - Checkpointed multisite maintenance transaction orchestrator.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
OPS="$SPINE_ROOT/bin/ops"
TX_CONTRACT="$SPINE_ROOT/ops/bindings/infra.maintenance.transaction.contract.yaml"
SEQ_BINDING="$SPINE_ROOT/ops/bindings/startup.sequencing.yaml"
SERVICES_BINDING="$SPINE_ROOT/ops/bindings/services.health.yaml"
SSH_STATUS_SCRIPT="$SPINE_ROOT/ops/plugins/ssh/bin/ssh-target-status"
DOCKER_STATUS_SCRIPT="$SPINE_ROOT/ops/plugins/docker/bin/docker-compose-status"
SERVICES_STATUS_SCRIPT="$SPINE_ROOT/ops/plugins/services/bin/services-health-status"

MODE=""
SITE=""
WINDOW_ID=""
RESUME_FROM=""
EXECUTE=0
ALLOW_OOB_LOSS=0
ACK_TOKEN=""
POWEROFF_SHOP=0
POWEROFF_HOME=0

usage() {
  cat <<'USAGE'
infra.maintenance.window

Usage:
  infra-maintenance-window --site <shop|home|both> --mode <precheck|shutdown|startup|recovery|verify|full>
                          [--window-id <id>] [--resume-from <phase>] [--execute|--dry-run]
                          [--allow-oob-loss] [--ack-token <token>] [--poweroff-shop] [--poweroff-home]
USAGE
}

fail() {
  echo "STOP (2): $*" >&2
  exit 2
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --)
      shift
      ;;
    --mode)
      MODE="${2:-}"
      shift 2
      ;;
    --site)
      SITE="${2:-}"
      shift 2
      ;;
    --window-id)
      WINDOW_ID="${2:-}"
      shift 2
      ;;
    --resume-from)
      RESUME_FROM="${2:-}"
      shift 2
      ;;
    --execute)
      EXECUTE=1
      shift
      ;;
    --dry-run)
      EXECUTE=0
      shift
      ;;
    --allow-oob-loss)
      ALLOW_OOB_LOSS=1
      shift
      ;;
    --ack-token)
      ACK_TOKEN="${2:-}"
      shift 2
      ;;
    --poweroff-shop)
      POWEROFF_SHOP=1
      shift
      ;;
    --poweroff-home)
      POWEROFF_HOME=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      fail "unknown arg: $1"
      ;;
  esac
done

[[ -n "$SITE" ]] || fail "--site required (shop|home|both)"
[[ -n "$MODE" ]] || fail "--mode required (precheck|shutdown|startup|recovery|verify|full)"
case "$SITE" in
  shop|home|both) ;;
  *) fail "--site must be shop|home|both" ;;
esac
case "$MODE" in
  precheck|shutdown|startup|recovery|verify|full) ;;
  *) fail "--mode must be precheck|shutdown|startup|recovery|verify|full" ;;
esac

[[ -x "$OPS" ]] || fail "missing executable: $OPS"
[[ -f "$TX_CONTRACT" ]] || fail "missing transaction contract: $TX_CONTRACT"
[[ -f "$SEQ_BINDING" ]] || fail "missing startup sequencing binding: $SEQ_BINDING"
[[ -f "$SERVICES_BINDING" ]] || fail "missing services health binding: $SERVICES_BINDING"
[[ -x "$SSH_STATUS_SCRIPT" ]] || fail "missing executable: $SSH_STATUS_SCRIPT"
[[ -x "$DOCKER_STATUS_SCRIPT" ]] || fail "missing executable: $DOCKER_STATUS_SCRIPT"
[[ -x "$SERVICES_STATUS_SCRIPT" ]] || fail "missing executable: $SERVICES_STATUS_SCRIPT"
command -v yq >/dev/null 2>&1 || fail "yq is required but not found"
command -v python3 >/dev/null 2>&1 || fail "python3 is required but not found"

mapfile -t PHASE_ORDER < <(yq -r '.phase_order[]' "$TX_CONTRACT")
[[ "${#PHASE_ORDER[@]}" -gt 0 ]] || fail "contract phase_order is empty"

ACK_TOKEN_REQUIRED="$(yq -r '.oob_policy.ack_token // ""' "$TX_CONTRACT")"
[[ -n "$ACK_TOKEN_REQUIRED" ]] || fail "contract oob_policy.ack_token is missing"

CHECKPOINT_TEMPLATE="$(yq -r '.checkpoint_path // ""' "$TX_CONTRACT")"
[[ -n "$CHECKPOINT_TEMPLATE" ]] || fail "contract checkpoint_path is missing"
[[ "$CHECKPOINT_TEMPLATE" == *"<window_id>"* ]] || fail "contract checkpoint_path must include <window_id>"

mapfile -t REQUIRED_POSTCHECKS < <(yq -r '.required_postchecks[]' "$TX_CONTRACT")
[[ "${#REQUIRED_POSTCHECKS[@]}" -gt 0 ]] || fail "contract required_postchecks is empty"

site_host() {
  local site_id="$1"
  yq -r ".sites[] | select(.id==\"$site_id\") | .host_id" "$TX_CONTRACT"
}

SHOP_HOST_ID="$(site_host shop)"
HOME_HOST_ID="$(site_host home)"
[[ -n "$SHOP_HOST_ID" && "$SHOP_HOST_ID" != "null" ]] || fail "missing shop host mapping in contract"
[[ -n "$HOME_HOST_ID" && "$HOME_HOST_ID" != "null" ]] || fail "missing home host mapping in contract"

if [[ -z "$WINDOW_ID" ]]; then
  WINDOW_ID="MW-$(date -u +%Y%m%dT%H%M%SZ)-$SITE"
fi

CHECKPOINT_PATH="$SPINE_ROOT/${CHECKPOINT_TEMPLATE//<window_id>/$WINDOW_ID}"
mkdir -p "$(dirname "$CHECKPOINT_PATH")"

phase_index() {
  local needle="$1"
  local i
  for i in "${!PHASE_ORDER[@]}"; do
    if [[ "${PHASE_ORDER[$i]}" == "$needle" ]]; then
      echo "$i"
      return 0
    fi
  done
  echo "-1"
  return 1
}

RESUME_INDEX=-1
if [[ -n "$RESUME_FROM" ]]; then
  RESUME_INDEX="$(phase_index "$RESUME_FROM")"
  [[ "$RESUME_INDEX" != "-1" ]] || fail "--resume-from phase not in contract: $RESUME_FROM"
fi

checkpoint_write() {
  local phase="$1"
  local status="$2"
  local note="$3"
  local phase_order_csv
  phase_order_csv="$(IFS=,; echo "${PHASE_ORDER[*]}")"

  python3 - "$CHECKPOINT_PATH" "$WINDOW_ID" "$SITE" "$MODE" "$EXECUTE" "$RESUME_FROM" "$ALLOW_OOB_LOSS" "$ACK_TOKEN" "$ACK_TOKEN_REQUIRED" "$phase_order_csv" "$phase" "$status" "$note" <<'PY'
from __future__ import annotations

from datetime import datetime, timezone
from pathlib import Path
import sys

import yaml

(
    checkpoint_raw,
    window_id,
    site,
    mode,
    execute_raw,
    resume_from,
    allow_oob_raw,
    ack_token,
    ack_required,
    phase_order_csv,
    phase,
    status,
    note,
) = sys.argv[1:14]

checkpoint = Path(checkpoint_raw).expanduser().resolve()
phase_order = [x for x in phase_order_csv.split(",") if x]
now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

if checkpoint.exists():
    data = yaml.safe_load(checkpoint.read_text(encoding="utf-8")) or {}
else:
    data = {}
if not isinstance(data, dict):
    data = {}

data["window_id"] = window_id
data["site"] = site
data["mode"] = mode
data["execute"] = execute_raw == "1"
data["resume_from"] = resume_from or None
data["updated_at"] = now
data["phase_order"] = phase_order
data["oob_ack"] = {
    "allow_oob_loss": allow_oob_raw == "1",
    "ack_token_provided": bool(ack_token),
    "ack_token_matches_contract": bool(ack_token and ack_token == ack_required),
}

phases = data.get("phases")
if not isinstance(phases, dict):
    phases = {}
for key in phase_order:
    row = phases.get(key)
    if not isinstance(row, dict):
        phases[key] = {"status": "pending"}

if phase:
    row = phases.get(phase, {})
    if not isinstance(row, dict):
        row = {}
    row["status"] = status
    row["updated_at"] = now
    if note:
        row["note"] = note
    phases[phase] = row
    data["current_phase"] = phase

data["phases"] = phases

checkpoint.write_text(yaml.safe_dump(data, sort_keys=False), encoding="utf-8")
PY
}

run_cap() {
  local phase="$1"
  local label="$2"
  shift 2
  echo "═══ ${phase} :: ${label} ═══"
  echo "command: $*"
  echo
  if ! "$@"; then
    checkpoint_write "$phase" failed "$label failed"
    return 1
  fi
  return 0
}

run_with_timeout() {
  local timeout_sec="$1"
  shift
  python3 - "$timeout_sec" "$@" <<'PY'
from __future__ import annotations

import shlex
import subprocess
import sys

timeout_sec = int(sys.argv[1])
cmd = sys.argv[2:]

try:
    completed = subprocess.run(cmd, check=False, timeout=timeout_sec)
    raise SystemExit(completed.returncode)
except subprocess.TimeoutExpired:
    rendered = " ".join(shlex.quote(part) for part in cmd)
    print(f"STOP (2): command timed out after {timeout_sec}s: {rendered}", file=sys.stderr)
    raise SystemExit(124)
PY
}

shutdown_sites() {
  case "$SITE" in
    shop) echo "shop" ;;
    home) echo "home" ;;
    both) echo "shop home" ;;
  esac
}

startup_sites() {
  case "$SITE" in
    shop) echo "shop" ;;
    home) echo "home" ;;
    both) echo "home shop" ;;
  esac
}

host_for_site() {
  case "$1" in
    shop) echo "$SHOP_HOST_ID" ;;
    home) echo "$HOME_HOST_ID" ;;
    *) return 1 ;;
  esac
}

site_preflight() {
  local site_id="$1"
  local host_id
  host_id="$(host_for_site "$site_id")"
  [[ -n "$host_id" ]] || fail "site_preflight_failed: unresolved host for site $site_id"
  echo "═══ site-preflight :: $site_id ($host_id) ═══"
  if ! run_with_timeout 20 "$SSH_STATUS_SCRIPT" --id "$host_id"; then
    fail "site_preflight_failed: $host_id"
  fi
  echo
}

site_targets_with_stacks() {
  local site_id="$1"
  python3 - "$SEQ_BINDING" "$site_id" <<'PY'
from __future__ import annotations

from pathlib import Path
import sys

import yaml

seq_path = Path(sys.argv[1]).expanduser().resolve()
site_id = sys.argv[2].strip()

doc = yaml.safe_load(seq_path.read_text(encoding="utf-8")) or {}
phases = doc.get("phases") if isinstance(doc.get("phases"), list) else []
seen = set()

for phase in phases:
    if not isinstance(phase, dict):
        continue
    if str(phase.get("site", "")).strip() != site_id:
        continue
    hosts = phase.get("hosts") if isinstance(phase.get("hosts"), list) else []
    for host in hosts:
        if not isinstance(host, dict):
            continue
        target = str(host.get("target", "")).strip()
        stacks = host.get("stacks") if isinstance(host.get("stacks"), list) else []
        if not target or len(stacks) == 0:
            continue
        if target in seen:
            continue
        seen.add(target)
        print(target)
PY
}

service_host_declared() {
  local host_id="$1"
  yq -e ".endpoints[] | select(.host == \"$host_id\")" "$SERVICES_BINDING" >/dev/null 2>&1
}

phase_precheck() {
  local site_id host_id
  for site_id in $(shutdown_sites); do
    host_id="$(host_for_site "$site_id")"
    site_preflight "$site_id"
    run_cap precheck "$site_id precheck" \
      "$OPS" cap run infra.proxmox.maintenance.precheck -- --mode precheck --host-id "$host_id"
  done
}

phase_shutdown() {
  local site_id host_id
  local args
  for site_id in $(shutdown_sites); do
    host_id="$(host_for_site "$site_id")"
    site_preflight "$site_id"
    args=("$OPS" cap run infra.proxmox.maintenance.shutdown -- --mode shutdown --host-id "$host_id")
    if [[ "$EXECUTE" -eq 1 ]]; then
      args+=(--execute)
    else
      args+=(--dry-run)
    fi
    if [[ "$ALLOW_OOB_LOSS" -eq 1 ]]; then
      args+=(--allow-oob-loss)
    fi
    if [[ -n "$ACK_TOKEN" ]]; then
      args+=(--ack-token "$ACK_TOKEN")
    fi
    if [[ "$EXECUTE" -eq 1 ]]; then
      if [[ "$site_id" == "shop" && "$POWEROFF_SHOP" -eq 1 ]]; then
        args+=(--poweroff)
      fi
      if [[ "$site_id" == "home" && "$POWEROFF_HOME" -eq 1 ]]; then
        args+=(--poweroff)
      fi
    fi
    run_cap shutdown "$site_id shutdown" "${args[@]}"
  done
}

phase_startup() {
  local site_id host_id
  local args
  for site_id in $(startup_sites); do
    host_id="$(host_for_site "$site_id")"
    site_preflight "$site_id"
    args=("$OPS" cap run infra.proxmox.maintenance.startup -- --mode startup --host-id "$host_id")
    if [[ "$EXECUTE" -eq 1 ]]; then
      args+=(--execute)
    else
      args+=(--dry-run)
    fi
    run_cap startup "$site_id startup" "${args[@]}"
  done
}

phase_recovery() {
  if [[ "$SITE" == "home" ]]; then
    echo "═══ recovery :: home site (no docker compose recovery required) ═══"
    echo
    return 0
  fi

  if [[ "$EXECUTE" -eq 1 ]]; then
    run_cap recovery "shop recovery execute" "$OPS" cap run infra.post_power.recovery
  else
    run_cap recovery "shop recovery dry-run status" "$OPS" cap run infra.post_power.recovery.status
  fi
}

phase_verify() {
  local -a verify_sites=()
  local -a stack_targets=()
  local -a service_hosts=()
  local site_id target host_id

  case "$SITE" in
    shop) verify_sites=(shop) ;;
    home) verify_sites=(home) ;;
    both) verify_sites=(shop home) ;;
    *) fail "verify phase does not support site '$SITE'" ;;
  esac

  for site_id in "${verify_sites[@]}"; do
    site_preflight "$site_id"
    while IFS= read -r target; do
      [[ -n "$target" ]] || continue
      if [[ " ${stack_targets[*]} " == *" $target "* ]]; then
        continue
      fi
      stack_targets+=("$target")
    done < <(site_targets_with_stacks "$site_id")
  done

  if [[ "${#stack_targets[@]}" -eq 0 ]]; then
    echo "═══ verify :: docker compose status (site-scoped) ═══"
    echo "status: SKIP (no compose targets for selected site scope)"
    echo
  else
    for target in "${stack_targets[@]}"; do
      run_cap verify "docker compose status $target" run_with_timeout 45 "$DOCKER_STATUS_SCRIPT" "$target"
      if [[ " ${service_hosts[*]} " != *" $target "* ]]; then
        service_hosts+=("$target")
      fi
    done
  fi

  if [[ "$SITE" == "home" || "$SITE" == "both" ]]; then
    if [[ " ${service_hosts[*]} " != *" ha "* ]]; then
      service_hosts+=("ha")
    fi
  fi

  if [[ "${#service_hosts[@]}" -eq 0 ]]; then
    echo "═══ verify :: services health status (site-scoped) ═══"
    echo "status: SKIP (no service hosts for selected site scope)"
    echo
  else
    for host_id in "${service_hosts[@]}"; do
      if ! service_host_declared "$host_id"; then
        echo "═══ verify :: services health $host_id ═══"
        echo "status: SKIP (no endpoint host mapping in services.health binding)"
        echo
        continue
      fi
      run_cap verify "services health $host_id" run_with_timeout 30 "$SERVICES_STATUS_SCRIPT" --host "$host_id"
    done
  fi

  run_cap verify "postcheck verify.core.run" run_with_timeout 90 "$OPS" cap run verify.core.run
}

run_phase() {
  local phase="$1"
  checkpoint_write "$phase" running "started"
  case "$phase" in
    precheck) phase_precheck ;;
    shutdown) phase_shutdown ;;
    startup) phase_startup ;;
    recovery) phase_recovery ;;
    verify) phase_verify ;;
    *) fail "unknown phase in dispatcher: $phase" ;;
  esac
  checkpoint_write "$phase" completed "completed"
}

echo "infra.maintenance.window"
echo "window_id: $WINDOW_ID"
echo "checkpoint_path: $CHECKPOINT_PATH"
echo "mode: $MODE"
echo "site: $SITE"
echo "execute: $( [[ "$EXECUTE" -eq 1 ]] && echo true || echo false )"
echo "resume_from: ${RESUME_FROM:-none}"
echo "allow_oob_loss: $( [[ "$ALLOW_OOB_LOSS" -eq 1 ]] && echo true || echo false )"
echo

selected_phases=()
case "$MODE" in
  precheck)
    selected_phases=(precheck)
    ;;
  shutdown)
    selected_phases=(shutdown)
    ;;
  startup)
    selected_phases=(startup recovery verify)
    ;;
  recovery)
    selected_phases=(recovery)
    ;;
  verify)
    selected_phases=(verify)
    ;;
  full)
    selected_phases=(precheck shutdown)
    ;;
esac

for phase in "${selected_phases[@]}"; do
  if [[ "$RESUME_INDEX" -ge 0 ]]; then
    idx="$(phase_index "$phase")"
    if [[ "$idx" -lt "$RESUME_INDEX" ]]; then
      continue
    fi
  fi
  run_phase "$phase"
done

if [[ "$MODE" == "full" ]]; then
  echo
  echo "maintenance_boundary: physical_maintenance_required"
  echo "resume_command: ./bin/ops cap run infra.maintenance.window -- --site $SITE --mode startup --execute --window-id $WINDOW_ID"
  echo "status: OK"
  exit 0
fi

echo "status: OK"
