#!/usr/bin/env bash
# infra-maintenance-window - Checkpointed multisite maintenance transaction orchestrator.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
OPS="$SPINE_ROOT/bin/ops"
TX_CONTRACT="$SPINE_ROOT/ops/bindings/infra.maintenance.transaction.contract.yaml"
SEQ_BINDING="$SPINE_ROOT/ops/bindings/startup.sequencing.yaml"
SERVICES_BINDING="$SPINE_ROOT/ops/bindings/services.health.yaml"
SSH_STATUS_SCRIPT="$SPINE_ROOT/ops/plugins/ssh/bin/ssh-target-status"
DOCKER_STATUS_SCRIPT="$SPINE_ROOT/ops/plugins/docker/bin/docker-compose-status"
SERVICES_STATUS_SCRIPT="$SPINE_ROOT/ops/plugins/services/bin/services-health-status"

MODE=""
SITE=""
WINDOW_ID=""
RESUME_FROM=""
EXECUTE=0
ALLOW_OOB_LOSS=0
ACK_TOKEN=""
POWEROFF_SHOP=0
POWEROFF_HOME=0
POWEROFF_SITE_ARGS=()

usage() {
  cat <<'USAGE'
infra.maintenance.window

Usage:
  infra-maintenance-window --site <site-id|site-id,site-id|all|both> --mode <precheck|shutdown|startup|recovery|verify|full>
                          [--window-id <id>] [--resume-from <phase>] [--execute|--dry-run]
                          [--allow-oob-loss] [--ack-token <token>] [--poweroff-shop] [--poweroff-home]
                          [--poweroff-site <site-id>]
USAGE
}

fail() {
  echo "STOP (2): $*" >&2
  exit 2
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --)
      shift
      ;;
    --mode)
      MODE="${2:-}"
      shift 2
      ;;
    --site)
      SITE="${2:-}"
      shift 2
      ;;
    --window-id)
      WINDOW_ID="${2:-}"
      shift 2
      ;;
    --resume-from)
      RESUME_FROM="${2:-}"
      shift 2
      ;;
    --execute)
      EXECUTE=1
      shift
      ;;
    --dry-run)
      EXECUTE=0
      shift
      ;;
    --allow-oob-loss)
      ALLOW_OOB_LOSS=1
      shift
      ;;
    --ack-token)
      ACK_TOKEN="${2:-}"
      shift 2
      ;;
    --poweroff-shop)
      POWEROFF_SHOP=1
      shift
      ;;
    --poweroff-home)
      POWEROFF_HOME=1
      shift
      ;;
    --poweroff-site)
      POWEROFF_SITE_ARGS+=("${2:-}")
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      fail "unknown arg: $1"
      ;;
  esac
done

[[ -n "$SITE" ]] || fail "--site required (site-id|csv|all|both)"
[[ -n "$MODE" ]] || fail "--mode required (precheck|shutdown|startup|recovery|verify|full)"
case "$MODE" in
  precheck|shutdown|startup|recovery|verify|full) ;;
  *) fail "--mode must be precheck|shutdown|startup|recovery|verify|full" ;;
esac

[[ -x "$OPS" ]] || fail "missing executable: $OPS"
[[ -f "$TX_CONTRACT" ]] || fail "missing transaction contract: $TX_CONTRACT"
[[ -f "$SEQ_BINDING" ]] || fail "missing startup sequencing binding: $SEQ_BINDING"
[[ -f "$SERVICES_BINDING" ]] || fail "missing services health binding: $SERVICES_BINDING"
[[ -x "$SSH_STATUS_SCRIPT" ]] || fail "missing executable: $SSH_STATUS_SCRIPT"
[[ -x "$DOCKER_STATUS_SCRIPT" ]] || fail "missing executable: $DOCKER_STATUS_SCRIPT"
[[ -x "$SERVICES_STATUS_SCRIPT" ]] || fail "missing executable: $SERVICES_STATUS_SCRIPT"
command -v yq >/dev/null 2>&1 || fail "yq is required but not found"
command -v python3 >/dev/null 2>&1 || fail "python3 is required but not found"

mapfile -t PHASE_ORDER < <(yq -r '.phase_order[]' "$TX_CONTRACT")
[[ "${#PHASE_ORDER[@]}" -gt 0 ]] || fail "contract phase_order is empty"

ACK_TOKEN_REQUIRED="$(yq -r '.oob_policy.ack_token // ""' "$TX_CONTRACT")"
[[ -n "$ACK_TOKEN_REQUIRED" ]] || fail "contract oob_policy.ack_token is missing"

CHECKPOINT_TEMPLATE="$(yq -r '.checkpoint_path // ""' "$TX_CONTRACT")"
[[ -n "$CHECKPOINT_TEMPLATE" ]] || fail "contract checkpoint_path is missing"
[[ "$CHECKPOINT_TEMPLATE" == *"<window_id>"* ]] || fail "contract checkpoint_path must include <window_id>"

mapfile -t REQUIRED_POSTCHECKS < <(yq -r '.required_postchecks[]' "$TX_CONTRACT")
[[ "${#REQUIRED_POSTCHECKS[@]}" -gt 0 ]] || fail "contract required_postchecks is empty"

verify_policy_key() {
  local key="$1"
  local mode_key="dry_run"
  local value=""
  if [[ "$EXECUTE" -eq 1 ]]; then
    mode_key="execute"
  fi
  value="$(yq -r ".verify_policy.${mode_key}.${key}" "$TX_CONTRACT" 2>/dev/null || true)"
  if [[ "$value" == "null" ]]; then
    value=""
  fi
  echo "$value"
}

VERIFY_DOCKER_TIMEOUT_SEC="$(verify_policy_key docker_timeout_sec)"
VERIFY_DOCKER_ATTEMPTS="$(verify_policy_key docker_attempts)"
VERIFY_DOCKER_BACKOFF_SEC="$(verify_policy_key docker_backoff_sec)"
VERIFY_SERVICES_TIMEOUT_SEC="$(verify_policy_key services_timeout_sec)"
VERIFY_SERVICES_ATTEMPTS="$(verify_policy_key services_attempts)"
VERIFY_SERVICES_BACKOFF_SEC="$(verify_policy_key services_backoff_sec)"
VERIFY_CORE_TIMEOUT_SEC="$(verify_policy_key verify_core_timeout_sec)"
VERIFY_STRICT_EXIT="$(verify_policy_key strict_exit)"
VERIFY_STARTUP_GRACE_SEC="$(verify_policy_key startup_grace_sec)"

for numeric_key in \
  VERIFY_DOCKER_TIMEOUT_SEC VERIFY_DOCKER_ATTEMPTS VERIFY_DOCKER_BACKOFF_SEC \
  VERIFY_SERVICES_TIMEOUT_SEC VERIFY_SERVICES_ATTEMPTS VERIFY_SERVICES_BACKOFF_SEC \
  VERIFY_CORE_TIMEOUT_SEC
do
  value="${!numeric_key:-}"
  [[ "$value" =~ ^[0-9]+$ ]] || fail "verify_policy.${numeric_key} must be a non-negative integer"
done

if [[ -z "$VERIFY_STARTUP_GRACE_SEC" || "$VERIFY_STARTUP_GRACE_SEC" == "null" ]]; then
  VERIFY_STARTUP_GRACE_SEC=0
fi
[[ "$VERIFY_STARTUP_GRACE_SEC" =~ ^[0-9]+$ ]] || fail "verify_policy.startup_grace_sec must be a non-negative integer"
[[ "$VERIFY_STRICT_EXIT" == "true" || "$VERIFY_STRICT_EXIT" == "false" ]] || fail "verify_policy.strict_exit must be true|false"

site_host() {
  local site_id="$1"
  yq -r ".sites[] | select(.id==\"$site_id\") | .host_id" "$TX_CONTRACT"
}

mapfile -t SITE_IDS < <(yq -r '.sites[].id' "$TX_CONTRACT")
[[ "${#SITE_IDS[@]}" -gt 0 ]] || fail "contract sites list is empty"

site_in_contract() {
  local needle="$1"
  local site_id
  for site_id in "${SITE_IDS[@]}"; do
    if [[ "$site_id" == "$needle" ]]; then
      return 0
    fi
  done
  return 1
}

for site_id in "${SITE_IDS[@]}"; do
  host_id="$(site_host "$site_id")"
  [[ -n "$host_id" && "$host_id" != "null" ]] || fail "missing host mapping in contract for site '$site_id'"
done

if [[ "$SITE" == "both" ]]; then
  SITE="all"
fi

SELECTED_SITE_IDS=()
if [[ "$SITE" == "all" ]]; then
  SELECTED_SITE_IDS=("${SITE_IDS[@]}")
else
  IFS=',' read -r -a requested_sites <<< "$SITE"
  for requested in "${requested_sites[@]}"; do
    site_id="$(echo "$requested" | xargs)"
    [[ -n "$site_id" ]] || continue
    site_in_contract "$site_id" || fail "--site contains unknown site id: $site_id (known: $(IFS=,; echo "${SITE_IDS[*]}"))"
    if [[ " ${SELECTED_SITE_IDS[*]} " != *" $site_id "* ]]; then
      SELECTED_SITE_IDS+=("$site_id")
    fi
  done
fi
[[ "${#SELECTED_SITE_IDS[@]}" -gt 0 ]] || fail "--site resolved to zero sites"

if [[ "$POWEROFF_SHOP" -eq 1 ]]; then
  POWEROFF_SITE_ARGS+=("shop")
fi
if [[ "$POWEROFF_HOME" -eq 1 ]]; then
  POWEROFF_SITE_ARGS+=("home")
fi

POWEROFF_SITE_IDS=()
for requested in "${POWEROFF_SITE_ARGS[@]}"; do
  site_id="$(echo "$requested" | xargs)"
  [[ -n "$site_id" ]] || fail "--poweroff-site requires non-empty site id"
  site_in_contract "$site_id" || fail "--poweroff-site contains unknown site id: $site_id"
  if [[ " ${POWEROFF_SITE_IDS[*]} " != *" $site_id "* ]]; then
    POWEROFF_SITE_IDS+=("$site_id")
  fi
done

if [[ -z "$WINDOW_ID" ]]; then
  WINDOW_ID="MW-$(date -u +%Y%m%dT%H%M%SZ)-$SITE"
fi

CHECKPOINT_PATH="$SPINE_ROOT/${CHECKPOINT_TEMPLATE//<window_id>/$WINDOW_ID}"
mkdir -p "$(dirname "$CHECKPOINT_PATH")"

phase_index() {
  local needle="$1"
  local i
  for i in "${!PHASE_ORDER[@]}"; do
    if [[ "${PHASE_ORDER[$i]}" == "$needle" ]]; then
      echo "$i"
      return 0
    fi
  done
  echo "-1"
  return 1
}

RESUME_INDEX=-1
if [[ -n "$RESUME_FROM" ]]; then
  RESUME_INDEX="$(phase_index "$RESUME_FROM")"
  [[ "$RESUME_INDEX" != "-1" ]] || fail "--resume-from phase not in contract: $RESUME_FROM"
fi

checkpoint_write() {
  local phase="$1"
  local status="$2"
  local note="$3"
  local phase_order_csv
  phase_order_csv="$(IFS=,; echo "${PHASE_ORDER[*]}")"

  python3 - "$CHECKPOINT_PATH" "$WINDOW_ID" "$SITE" "$MODE" "$EXECUTE" "$RESUME_FROM" "$ALLOW_OOB_LOSS" "$ACK_TOKEN" "$ACK_TOKEN_REQUIRED" "$phase_order_csv" "$phase" "$status" "$note" <<'PY'
from __future__ import annotations

from datetime import datetime, timezone
from pathlib import Path
import sys

import yaml

(
    checkpoint_raw,
    window_id,
    site,
    mode,
    execute_raw,
    resume_from,
    allow_oob_raw,
    ack_token,
    ack_required,
    phase_order_csv,
    phase,
    status,
    note,
) = sys.argv[1:14]

checkpoint = Path(checkpoint_raw).expanduser().resolve()
phase_order = [x for x in phase_order_csv.split(",") if x]
now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

if checkpoint.exists():
    data = yaml.safe_load(checkpoint.read_text(encoding="utf-8")) or {}
else:
    data = {}
if not isinstance(data, dict):
    data = {}

data["window_id"] = window_id
data["site"] = site
data["mode"] = mode
data["execute"] = execute_raw == "1"
data["resume_from"] = resume_from or None
data["updated_at"] = now
data["phase_order"] = phase_order
data["oob_ack"] = {
    "allow_oob_loss": allow_oob_raw == "1",
    "ack_token_provided": bool(ack_token),
    "ack_token_matches_contract": bool(ack_token and ack_token == ack_required),
}

phases = data.get("phases")
if not isinstance(phases, dict):
    phases = {}
for key in phase_order:
    row = phases.get(key)
    if not isinstance(row, dict):
        phases[key] = {"status": "pending"}

if phase:
    row = phases.get(phase, {})
    if not isinstance(row, dict):
        row = {}
    row["status"] = status
    row["updated_at"] = now
    if note:
        row["note"] = note
    phases[phase] = row
    data["current_phase"] = phase

data["phases"] = phases

checkpoint.write_text(yaml.safe_dump(data, sort_keys=False), encoding="utf-8")
PY
}

run_cap() {
  local phase="$1"
  local label="$2"
  shift 2
  echo "═══ ${phase} :: ${label} ═══"
  echo "command: $*"
  echo
  if ! "$@"; then
    checkpoint_write "$phase" failed "$label failed"
    return 1
  fi
  return 0
}

run_with_timeout() {
  local timeout_sec="$1"
  shift
  python3 - "$timeout_sec" "$@" <<'PY'
from __future__ import annotations

import shlex
import subprocess
import sys

timeout_sec = int(sys.argv[1])
cmd = sys.argv[2:]

try:
    completed = subprocess.run(cmd, check=False, timeout=timeout_sec)
    raise SystemExit(completed.returncode)
except subprocess.TimeoutExpired:
    rendered = " ".join(shlex.quote(part) for part in cmd)
    print(f"STOP (2): command timed out after {timeout_sec}s: {rendered}", file=sys.stderr)
    raise SystemExit(124)
PY
}

run_verify_with_retry() {
  local label="$1"
  local timeout_sec="$2"
  local attempts="$3"
  local backoff_sec="$4"
  shift 4
  local attempt=0
  local rc=0

  [[ "$attempts" =~ ^[0-9]+$ ]] || fail "invalid attempts for retry wrapper: $attempts"
  [[ "$attempts" -ge 1 ]] || fail "retry attempts must be >= 1"

  for (( attempt=1; attempt<=attempts; attempt++ )); do
    echo "verify.attempt: ${attempt}/${attempts} label=${label}"
    set +e
    run_with_timeout "$timeout_sec" "$@"
    rc=$?
    set -e
    if [[ "$rc" -eq 0 ]]; then
      return 0
    fi
    if [[ "$rc" -eq 2 ]]; then
      echo "verify.precondition_fail: label=${label} rc=${rc}"
      return "$rc"
    fi
    if [[ "$attempt" -lt "$attempts" ]]; then
      echo "verify.retry: label=${label} rc=${rc} backoff=${backoff_sec}s"
      sleep "$backoff_sec"
    fi
  done

  echo "verify.final_fail: label=${label} rc=${rc}"
  return "$rc"
}

shutdown_sites() {
  printf '%s\n' "${SELECTED_SITE_IDS[@]}"
}

startup_sites() {
  local idx
  for (( idx=${#SELECTED_SITE_IDS[@]}-1; idx>=0; idx-- )); do
    echo "${SELECTED_SITE_IDS[$idx]}"
  done
}

host_for_site() {
  site_host "$1"
}

site_should_poweroff() {
  local site_id="$1"
  if [[ "${#POWEROFF_SITE_IDS[@]}" -eq 0 ]]; then
    return 1
  fi
  if [[ " ${POWEROFF_SITE_IDS[*]} " == *" $site_id "* ]]; then
    return 0
  fi
  return 1
}

site_preflight() {
  local site_id="$1"
  local host_id
  host_id="$(host_for_site "$site_id")"
  [[ -n "$host_id" ]] || fail "site_preflight_failed: unresolved host for site $site_id"
  echo "═══ site-preflight :: $site_id ($host_id) ═══"
  if ! run_with_timeout 20 "$SSH_STATUS_SCRIPT" --id "$host_id"; then
    fail "site_preflight_failed: $host_id"
  fi
  echo
}

site_targets_with_stacks() {
  local site_id="$1"
  python3 - "$SEQ_BINDING" "$site_id" <<'PY'
from __future__ import annotations

from pathlib import Path
import sys

import yaml

seq_path = Path(sys.argv[1]).expanduser().resolve()
site_id = sys.argv[2].strip()

doc = yaml.safe_load(seq_path.read_text(encoding="utf-8")) or {}
phases = doc.get("phases") if isinstance(doc.get("phases"), list) else []
seen = set()

for phase in phases:
    if not isinstance(phase, dict):
        continue
    if str(phase.get("site", "")).strip() != site_id:
        continue
    hosts = phase.get("hosts") if isinstance(phase.get("hosts"), list) else []
    for host in hosts:
        if not isinstance(host, dict):
            continue
        target = str(host.get("target", "")).strip()
        stacks = host.get("stacks") if isinstance(host.get("stacks"), list) else []
        if not target or len(stacks) == 0:
            continue
        if target in seen:
            continue
        seen.add(target)
        print(target)
PY
}

service_host_declared() {
  local host_id="$1"
  yq -e ".endpoints[] | select(.host == \"$host_id\")" "$SERVICES_BINDING" >/dev/null 2>&1
}

phase_precheck() {
  local site_id host_id
  for site_id in $(shutdown_sites); do
    host_id="$(host_for_site "$site_id")"
    site_preflight "$site_id"
    run_cap precheck "$site_id precheck" \
      "$OPS" cap run infra.proxmox.maintenance.precheck -- --host-id "$host_id"
  done
}

phase_shutdown() {
  local site_id host_id
  local args
  for site_id in $(shutdown_sites); do
    host_id="$(host_for_site "$site_id")"
    site_preflight "$site_id"
    args=("$OPS" cap run infra.proxmox.maintenance.shutdown -- --host-id "$host_id")
    if [[ "$EXECUTE" -eq 1 ]]; then
      args+=(--execute)
    else
      args+=(--dry-run)
    fi
    if [[ "$ALLOW_OOB_LOSS" -eq 1 ]]; then
      args+=(--allow-oob-loss)
    fi
    if [[ -n "$ACK_TOKEN" ]]; then
      args+=(--ack-token "$ACK_TOKEN")
    fi
    if [[ "$EXECUTE" -eq 1 ]] && site_should_poweroff "$site_id"; then
      args+=(--poweroff)
    fi
    run_cap shutdown "$site_id shutdown" "${args[@]}"
  done
}

phase_startup() {
  local site_id host_id
  local args
  for site_id in $(startup_sites); do
    host_id="$(host_for_site "$site_id")"
    site_preflight "$site_id"
    args=("$OPS" cap run infra.proxmox.maintenance.startup -- --host-id "$host_id")
    if [[ "$EXECUTE" -eq 1 ]]; then
      args+=(--execute)
    else
      args+=(--dry-run)
    fi
    run_cap startup "$site_id startup" "${args[@]}"
  done
}

phase_recovery() {
  local site_id target
  local needs_recovery=0
  for site_id in "${SELECTED_SITE_IDS[@]}"; do
    while IFS= read -r target; do
      [[ -n "$target" ]] || continue
      needs_recovery=1
      break
    done < <(site_targets_with_stacks "$site_id")
    if [[ "$needs_recovery" -eq 1 ]]; then
      break
    fi
  done

  if [[ "$needs_recovery" -eq 0 ]]; then
    echo "═══ recovery :: selected site scope has no docker compose targets ═══"
    echo
    return 0
  fi

  if [[ "$EXECUTE" -eq 1 ]]; then
    run_cap recovery "recovery execute (site-scoped stacks present)" "$OPS" cap run infra.post_power.recovery
  else
    run_cap recovery "recovery dry-run status (site-scoped stacks present)" "$OPS" cap run infra.post_power.recovery.status
  fi
}

phase_verify() {
  local -a verify_sites=()
  local -a stack_targets=()
  local -a service_hosts=()
  local -a docker_cmd=()
  local -a services_cmd=()
  local site_id target host_id

  verify_sites=("${SELECTED_SITE_IDS[@]}")

  for site_id in "${verify_sites[@]}"; do
    site_preflight "$site_id"
    while IFS= read -r target; do
      [[ -n "$target" ]] || continue
      if [[ " ${stack_targets[*]} " == *" $target "* ]]; then
        continue
      fi
      stack_targets+=("$target")
    done < <(site_targets_with_stacks "$site_id")
  done

  if [[ "$EXECUTE" -eq 1 && "$MODE" == "startup" && "$VERIFY_STARTUP_GRACE_SEC" -gt 0 ]]; then
    echo "verify.startup_grace_sec: ${VERIFY_STARTUP_GRACE_SEC}s"
    sleep "$VERIFY_STARTUP_GRACE_SEC"
    echo
  fi

  if [[ "${#stack_targets[@]}" -eq 0 ]]; then
    echo "═══ verify :: docker compose status (site-scoped) ═══"
    echo "status: SKIP (no compose targets for selected site scope)"
    echo
  else
    for target in "${stack_targets[@]}"; do
      docker_cmd=("$DOCKER_STATUS_SCRIPT" "$target")
      if [[ "$VERIFY_STRICT_EXIT" == "true" ]]; then
        docker_cmd+=(--strict-exit)
      fi
      run_cap verify "docker compose status $target" \
        run_verify_with_retry "docker:${target}" "$VERIFY_DOCKER_TIMEOUT_SEC" "$VERIFY_DOCKER_ATTEMPTS" "$VERIFY_DOCKER_BACKOFF_SEC" \
        "${docker_cmd[@]}"
      if [[ " ${service_hosts[*]} " != *" $target "* ]]; then
        service_hosts+=("$target")
      fi
    done
  fi

  if [[ " ${SELECTED_SITE_IDS[*]} " == *" home "* ]]; then
    if [[ " ${service_hosts[*]} " != *" ha "* ]]; then
      service_hosts+=("ha")
    fi
  fi

  if [[ "${#service_hosts[@]}" -eq 0 ]]; then
    echo "═══ verify :: services health status (site-scoped) ═══"
    echo "status: SKIP (no service hosts for selected site scope)"
    echo
  else
    for host_id in "${service_hosts[@]}"; do
      if ! service_host_declared "$host_id"; then
        echo "═══ verify :: services health $host_id ═══"
        echo "status: SKIP (no endpoint host mapping in services.health binding)"
        echo
        continue
      fi
      services_cmd=("$SERVICES_STATUS_SCRIPT" --host "$host_id")
      if [[ "$VERIFY_STRICT_EXIT" == "true" ]]; then
        services_cmd+=(--strict-exit)
      fi
      run_cap verify "services health $host_id" \
        run_verify_with_retry "services:${host_id}" "$VERIFY_SERVICES_TIMEOUT_SEC" "$VERIFY_SERVICES_ATTEMPTS" "$VERIFY_SERVICES_BACKOFF_SEC" \
        "${services_cmd[@]}"
    done
  fi

  run_cap verify "postcheck verify.core.run" \
    run_verify_with_retry "verify.core.run" "$VERIFY_CORE_TIMEOUT_SEC" 1 0 \
    "$OPS" cap run verify.core.run
}

run_phase() {
  local phase="$1"
  checkpoint_write "$phase" running "started"
  case "$phase" in
    precheck) phase_precheck ;;
    shutdown) phase_shutdown ;;
    startup) phase_startup ;;
    recovery) phase_recovery ;;
    verify) phase_verify ;;
    *) fail "unknown phase in dispatcher: $phase" ;;
  esac
  checkpoint_write "$phase" completed "completed"
}

echo "infra.maintenance.window"
echo "window_id: $WINDOW_ID"
echo "checkpoint_path: $CHECKPOINT_PATH"
echo "mode: $MODE"
echo "site: $SITE"
echo "execute: $( [[ "$EXECUTE" -eq 1 ]] && echo true || echo false )"
echo "resume_from: ${RESUME_FROM:-none}"
echo "allow_oob_loss: $( [[ "$ALLOW_OOB_LOSS" -eq 1 ]] && echo true || echo false )"
echo

selected_phases=()
case "$MODE" in
  precheck)
    selected_phases=(precheck)
    ;;
  shutdown)
    selected_phases=(shutdown)
    ;;
  startup)
    selected_phases=(startup recovery verify)
    ;;
  recovery)
    selected_phases=(recovery)
    ;;
  verify)
    selected_phases=(verify)
    ;;
  full)
    selected_phases=(precheck shutdown)
    ;;
esac

for phase in "${selected_phases[@]}"; do
  if [[ "$RESUME_INDEX" -ge 0 ]]; then
    idx="$(phase_index "$phase")"
    if [[ "$idx" -lt "$RESUME_INDEX" ]]; then
      continue
    fi
  fi
  run_phase "$phase"
done

if [[ "$MODE" == "full" ]]; then
  echo
  echo "maintenance_boundary: physical_maintenance_required"
  echo "resume_command: ./bin/ops cap run infra.maintenance.window -- --site $SITE --mode startup --execute --window-id $WINDOW_ID"
  echo "status: OK"
  exit 0
fi

echo "status: OK"
