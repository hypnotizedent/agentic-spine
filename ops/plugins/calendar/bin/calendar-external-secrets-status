#!/usr/bin/env python3
"""calendar-external-secrets-status - validate external calendar provider secret refs contract."""

from __future__ import annotations

import argparse
import json
import os
import time
from pathlib import Path
from typing import Any

import yaml


def fail(msg: str, code: int = 1) -> None:
    print(f"ERROR: {msg}")
    raise SystemExit(code)


def load_yaml(path: Path) -> dict[str, Any]:
    if not path.is_file():
        fail(f"missing contract: {path}")
    try:
        payload = yaml.safe_load(path.read_text(encoding="utf-8")) or {}
    except Exception as exc:
        fail(f"unable to parse YAML {path}: {exc}")
    if not isinstance(payload, dict):
        fail(f"YAML root must be mapping: {path}")
    return payload


def get_nested(doc: dict[str, Any], path: str) -> str:
    node: Any = doc
    for key in path.split("."):
        if not isinstance(node, dict):
            return ""
        node = node.get(key)
    return str(node).strip() if node is not None else ""


def main() -> None:
    parser = argparse.ArgumentParser(description="Validate external calendar provider secret refs.")
    parser.add_argument("--json", action="store_true", help="Emit JSON output")
    args = parser.parse_args()

    script_dir = Path(__file__).resolve().parent
    root = Path(os.environ.get("SPINE_ROOT", str(script_dir.parents[3]))).expanduser().resolve()
    contract_path = root / "ops/bindings/calendar.external.providers.contract.yaml"
    doc = load_yaml(contract_path)

    providers = doc.get("providers") if isinstance(doc.get("providers"), dict) else {}
    provider_mode = doc.get("provider_mode") if isinstance(doc.get("provider_mode"), dict) else {}

    required: dict[str, list[str]] = {
        "icloud": [
            "endpoint.caldav_url_ref",
            "auth.username_ref",
            "auth.app_specific_password_ref",
        ],
        "google": [
            "oauth.client_id_ref",
            "oauth.client_secret_ref",
            "oauth.refresh_token_ref",
            "allowlist.calendar_ids_ref",
        ],
    }

    checks: list[str] = []
    errors: list[str] = []
    refs: dict[str, dict[str, str]] = {}

    if provider_mode.get("external_ingest_mode") != "read-only":
        errors.append("provider_mode.external_ingest_mode must be read-only")
    else:
        checks.append("provider_mode.external_ingest_mode=read-only")

    if provider_mode.get("writeback_enabled") is not False:
        errors.append("provider_mode.writeback_enabled must be false")
    else:
        checks.append("provider_mode.writeback_enabled=false")

    for provider, paths in required.items():
        block = providers.get(provider)
        if not isinstance(block, dict):
            errors.append(f"providers.{provider} block missing")
            continue
        refs[provider] = {}

        for ref_path in paths:
            value = get_nested(block, ref_path)
            refs[provider][ref_path] = value
            field_name = f"providers.{provider}.{ref_path}"
            if not value:
                errors.append(f"{field_name} missing")
            elif not value.startswith("infisical://"):
                errors.append(f"{field_name} must use infisical:// ref")
            else:
                checks.append(f"{field_name} present")

    payload = {
        "capability": "calendar.external.secrets.status",
        "status": "ok" if not errors else "fail",
        "generated_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "data": {
            "contract_path": str(contract_path),
            "providers_configured": sorted(required.keys()),
            "checks": checks,
            "errors": errors,
            "refs": refs,
        },
    }

    if args.json:
        print(json.dumps(payload, indent=2, sort_keys=True))
    else:
        print("calendar.external.secrets.status")
        print(f"contract: {contract_path}")
        print(f"providers_configured: {sorted(required.keys())}")
        print(f"checks_passed: {len(checks)}")
        print(f"errors: {len(errors)}")
        if errors:
            print("status: FAIL")
            raise SystemExit(1)
        print("status: OK")


if __name__ == "__main__":
    main()
