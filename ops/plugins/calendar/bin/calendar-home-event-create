#!/usr/bin/env python3
"""calendar-home-event-create - add event to governed local calendar home (Radicale)."""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import shlex
import subprocess
import sys
import time
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

import yaml


def fail(msg: str, code: int = 1) -> None:
    print(f"ERROR: {msg}", file=sys.stderr)
    raise SystemExit(code)


def load_yaml(path: Path) -> dict[str, Any]:
    if not path.is_file():
        fail(f"missing contract: {path}")
    try:
        payload = yaml.safe_load(path.read_text(encoding="utf-8")) or {}
    except Exception as exc:  # pragma: no cover - runtime guard
        fail(f"unable to parse YAML {path}: {exc}")
    if not isinstance(payload, dict):
        fail(f"YAML root must be mapping: {path}")
    return payload


def parse_iso_dt(raw: str, field: str) -> datetime:
    try:
        dt = datetime.fromisoformat(raw)
    except ValueError as exc:
        fail(f"invalid {field} datetime (ISO-8601 required): {raw}")
    if dt.tzinfo is None:
        fail(f"{field} must include timezone offset: {raw}")
    return dt


def to_ics_utc(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).strftime("%Y%m%dT%H%M%SZ")


def escape_ics_text(value: str) -> str:
    return (
        value.replace("\\", "\\\\")
        .replace(";", "\\;")
        .replace(",", "\\,")
        .replace("\r\n", "\\n")
        .replace("\n", "\\n")
    )


def event_ics(*, uid: str, title: str, description: str, start: datetime, end: datetime) -> str:
    dtstamp = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
    lines = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//agentic-spine//calendar-home-v1//EN",
        "CALSCALE:GREGORIAN",
        "METHOD:PUBLISH",
        "BEGIN:VEVENT",
        f"UID:{uid}",
        f"DTSTAMP:{dtstamp}",
        f"DTSTART:{to_ics_utc(start)}",
        f"DTEND:{to_ics_utc(end)}",
        f"SUMMARY:{escape_ics_text(title)}",
        f"DESCRIPTION:{escape_ics_text(description)}",
        "END:VEVENT",
        "END:VCALENDAR",
        "",
    ]
    return "\r\n".join(lines)


def read_secret_var(name: str) -> str:
    val = os.environ.get(name, "").strip()
    if val:
        return val
    file_var = os.environ.get(f"{name}_FILE", "").strip()
    if file_var:
        try:
            return Path(file_var).expanduser().read_text(encoding="utf-8").strip()
        except Exception as exc:  # pragma: no cover - runtime guard
            fail(f"unable to read secret file for {name}: {exc}")
    return ""


def main() -> None:
    script_dir = Path(__file__).resolve().parent
    root = Path(os.environ.get("SPINE_ROOT", str(script_dir.parents[3]))).expanduser().resolve()

    parser = argparse.ArgumentParser(description="Create governed local calendar home event")
    parser.add_argument("--title", required=True, help="Event title")
    parser.add_argument("--start", required=True, help="Start datetime (ISO-8601 with timezone)")
    parser.add_argument("--end", required=True, help="End datetime (ISO-8601 with timezone)")
    parser.add_argument("--description", default="", help="Event description")
    parser.add_argument("--calendar-id", default="spine", help="Local calendar collection id")
    parser.add_argument("--local-only", action="store_true", help="Write local store only (skip Radicale PUT)")
    parser.add_argument("--json", action="store_true", help="Emit JSON summary")
    args = parser.parse_args()

    home_contract_path = root / "ops/bindings/calendar.home.contract.yaml"
    sync_contract_path = root / "ops/bindings/calendar.sync.contract.yaml"

    home = load_yaml(home_contract_path)
    sync = load_yaml(sync_contract_path)

    home_section = home.get("home") if isinstance(home.get("home"), dict) else {}
    endpoint = home_section.get("endpoint") if isinstance(home_section.get("endpoint"), dict) else {}

    provider = str(home_section.get("provider", "")).strip()
    host = str(home_section.get("host", "")).strip()
    remote_stack_path = str(home_section.get("remote_stack_path", "")).strip()
    write_mode = str(home_section.get("write_mode", "")).strip()
    if provider != "communications-calendar":
        fail(f"calendar home provider must be communications-calendar (actual={provider!r})")
    if host != "communications-stack":
        fail(f"calendar home host must be communications-stack (actual={host!r})")
    if write_mode != "local-only":
        fail(f"calendar home write_mode must be local-only (actual={write_mode!r})")

    sync_push_caps = (
        sync.get("sync_contracts", {}).get("push_write_capabilities", [])
        if isinstance(sync.get("sync_contracts"), dict)
        else []
    )
    if not isinstance(sync_push_caps, list) or sync_push_caps:
        fail(f"calendar sync push_write_capabilities must remain empty (actual={sync_push_caps!r})")

    start_dt = parse_iso_dt(args.start, "start")
    end_dt = parse_iso_dt(args.end, "end")
    if end_dt <= start_dt:
        fail("end must be after start")

    local_store_rel = str(
        sync.get("local_calendar_store", {}).get("path", "mailroom/state/calendar-sync/writable")
    ).strip()
    local_store_root = (root / local_store_rel).resolve()
    local_events_dir = local_store_root / "events"
    local_events_dir.mkdir(parents=True, exist_ok=True)

    seed = f"{args.title}|{args.start}|{args.end}|{uuid.uuid4()}"
    event_uid = hashlib.sha1(seed.encode("utf-8")).hexdigest()[:20] + "@spine-calendar-home"
    description = args.description.strip() or "Created via calendar.home.event.create"
    ics_payload = event_ics(
        uid=event_uid,
        title=args.title.strip(),
        description=description,
        start=start_dt,
        end=end_dt,
    )

    event_filename = f"{start_dt.strftime('%Y%m%dT%H%M%S')}-{event_uid}.ics"
    event_path = local_events_dir / event_filename
    event_path.write_text(ics_payload, encoding="utf-8")

    base_url = str(endpoint.get("base_url", "")).strip().rstrip("/")
    collection = str(endpoint.get("calendar_collection", "/spine/")).strip()
    if not collection.startswith("/"):
        collection = "/" + collection
    if not collection.endswith("/"):
        collection = collection + "/"

    remote_url = f"{base_url}{collection}{event_uid}.ics"
    remote_put = {"attempted": False, "ok": False, "output": "", "url": remote_url, "auth_source": "none"}

    if not args.local_only:
        username = read_secret_var("CALENDAR_HOME_USERNAME") or read_secret_var("RADICALE_ADMIN_USERNAME")
        password = read_secret_var("CALENDAR_HOME_PASSWORD") or read_secret_var("RADICALE_ADMIN_PASSWORD")
        if not base_url:
            fail("calendar.home.contract endpoint.base_url is required for remote write")

        remote_put["attempted"] = True
        if username and password:
            remote_put["auth_source"] = "env"
            remote_cmd = (
                "curl -fsS -u "
                + shlex.quote(f"{username}:{password}")
                + " -X PUT -H 'Content-Type: text/calendar; charset=utf-8' --data-binary @- "
                + shlex.quote(remote_url)
                + " >/dev/null"
            )
        else:
            if not remote_stack_path:
                fail(
                    "missing calendar home credentials and home.remote_stack_path unavailable for host auth fallback"
                )
            remote_put["auth_source"] = "host_env"
            remote_cmd = (
                "set -a; source "
                + shlex.quote(f"{remote_stack_path}/.env")
                + "; set +a; "
                + "curl -fsS -u \"$RADICALE_ADMIN_USERNAME:$RADICALE_ADMIN_PASSWORD\" "
                + "-X PUT -H 'Content-Type: text/calendar; charset=utf-8' --data-binary @- "
                + shlex.quote(remote_url)
                + " >/dev/null"
            )

        ssh_cmd = [
            "ssh",
            "-o",
            "BatchMode=yes",
            "-o",
            "ConnectTimeout=10",
            host,
            remote_cmd,
        ]
        proc = subprocess.run(ssh_cmd, input=ics_payload, capture_output=True, text=True, check=False)
        remote_put["output"] = (proc.stdout or proc.stderr or "").strip()
        if proc.returncode != 0:
            fail(f"remote calendar write failed: {remote_put['output'] or 'curl returned non-zero'}")
        remote_put["ok"] = True

    payload = {
        "capability": "calendar.home.event.create",
        "status": "ok",
        "generated_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "data": {
            "title": args.title,
            "start": args.start,
            "end": args.end,
            "calendar_id": args.calendar_id,
            "event_uid": event_uid,
            "local_event_path": str(event_path),
            "local_store_path": str(local_store_root),
            "provider": provider,
            "host": host,
            "write_mode": write_mode,
            "remote_put": remote_put,
        },
    }

    if args.json:
        print(json.dumps(payload, indent=2, sort_keys=True))
    else:
        print("calendar.home.event.create")
        print(f"provider: {provider}")
        print(f"write_mode: {write_mode}")
        print(f"title: {args.title}")
        print(f"start: {args.start}")
        print(f"end: {args.end}")
        print(f"event_uid: {event_uid}")
        print(f"local_event_path: {event_path}")
        print(f"remote_put_attempted: {str(remote_put['attempted']).lower()}")
        print(f"remote_put_ok: {str(remote_put['ok']).lower()}")
        if remote_put["attempted"]:
            print(f"remote_auth_source: {remote_put['auth_source']}")
            print(f"remote_url: {remote_url}")
        print("status: OK")


if __name__ == "__main__":
    main()
