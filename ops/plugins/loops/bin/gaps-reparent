#!/usr/bin/env bash
# gaps-reparent — Bulk reparent open gaps from one parent_loop to another.
#
# Usage:
#   gaps-reparent --from-parent-loop <LOOP-ID> --to-parent-loop <LOOP-ID> [--ids GAP-OP-1,GAP-OP-2] [--reason <text>]
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
GAPS_FILE="$ROOT/ops/bindings/operational.gaps.yaml"
LOCK_FILE="/tmp/spine-gaps-reparent.lock"

FROM_LOOP=""
TO_LOOP=""
IDS_FILTER=""
REASON=""
DRY_RUN=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --) shift ;;
    --from-parent-loop) FROM_LOOP="${2:-}"; shift 2 ;;
    --to-parent-loop) TO_LOOP="${2:-}"; shift 2 ;;
    --ids) IDS_FILTER="${2:-}"; shift 2 ;;
    --reason) REASON="${2:-}"; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    -h|--help)
      cat <<'USAGE'
gaps-reparent — Bulk reparent open gaps between parent loops.

Usage:
  gaps-reparent --from-parent-loop <FROM> --to-parent-loop <TO> [--ids GAP-OP-1,GAP-OP-2] [--reason <text>] [--dry-run]

Options:
  --from-parent-loop  Source parent_loop to match (required)
  --to-parent-loop    Target parent_loop to set (required)
  --ids               Comma-separated gap IDs to filter (optional; default: all matching)
  --reason            Reason for reparenting (optional; appended to notes)
  --dry-run           Preview changes without modifying the file
USAGE
      exit 0
      ;;
    *) echo "ERROR: unknown arg: $1" >&2; exit 1 ;;
  esac
done

[[ -n "$FROM_LOOP" ]] || { echo "ERROR: --from-parent-loop required" >&2; exit 1; }
[[ -n "$TO_LOOP" ]] || { echo "ERROR: --to-parent-loop required" >&2; exit 1; }
[[ -f "$GAPS_FILE" ]] || { echo "ERROR: gaps file not found: $GAPS_FILE" >&2; exit 1; }

# Parse IDs filter into array
declare -a ID_FILTER_ARR=()
if [[ -n "$IDS_FILTER" ]]; then
  IFS=',' read -r -a ID_FILTER_ARR <<< "$IDS_FILTER"
fi

# Use Python for safe YAML manipulation (preserves formatting better than yq in-place)
REPARENT_RESULT="$(python3 - "$GAPS_FILE" "$FROM_LOOP" "$TO_LOOP" "$IDS_FILTER" "$REASON" "$DRY_RUN" <<'PY'
import sys
import re
from pathlib import Path

gaps_file = Path(sys.argv[1])
from_loop = sys.argv[2]
to_loop = sys.argv[3]
ids_filter_raw = sys.argv[4]
reason = sys.argv[5]
dry_run = sys.argv[6] == "1"

ids_filter = set()
if ids_filter_raw:
    ids_filter = {x.strip() for x in ids_filter_raw.split(",") if x.strip()}

content = gaps_file.read_text(encoding="utf-8")
lines = content.split("\n")

reparented = []
i = 0
new_lines = []
while i < len(lines):
    line = lines[i]
    stripped = line.strip()

    # Detect gap block start: `  - id: "GAP-OP-XXXX"`
    if re.match(r'^\s+-\s+id:\s+"(GAP-OP-\d+)"', stripped) or re.match(r'^\s+-\s+id:\s+"(GAP-OP-\d+)"', line):
        m = re.search(r'"(GAP-OP-\d+)"', line)
        if m:
            gap_id = m.group(1)
        else:
            new_lines.append(line)
            i += 1
            continue

        # Collect the full gap block (until next `  - id:` or end of file)
        block_start = i
        i += 1
        while i < len(lines):
            next_stripped = lines[i].strip()
            if next_stripped.startswith("- id:"):
                break
            i += 1
        block_end = i
        block_lines = lines[block_start:block_end]
        block_text = "\n".join(block_lines)

        # Check if this gap matches: status=open, parent_loop=from_loop
        has_open = bool(re.search(r'status:\s*open', block_text))
        has_from_loop = f'parent_loop: "{from_loop}"' in block_text
        matches_id = (not ids_filter) or (gap_id in ids_filter)

        if has_open and has_from_loop and matches_id:
            reparented.append(gap_id)
            if not dry_run:
                # Replace parent_loop
                updated_block = []
                for bl in block_lines:
                    if f'parent_loop: "{from_loop}"' in bl:
                        updated_block.append(bl.replace(f'parent_loop: "{from_loop}"', f'parent_loop: "{to_loop}"'))
                    else:
                        updated_block.append(bl)

                # Append reparent note to notes field if reason provided
                if reason:
                    note_added = False
                    final_block = []
                    for bl in updated_block:
                        if bl.strip().startswith("notes:"):
                            existing_note = bl.split("notes:", 1)[1].strip().strip('"')
                            new_note = f'{existing_note} Reparented: {reason}.'
                            indent = bl[:len(bl) - len(bl.lstrip())]
                            final_block.append(f'{indent}notes: "{new_note}"')
                            note_added = True
                        else:
                            final_block.append(bl)
                    if not note_added:
                        # Add notes field before parent_loop
                        final_block2 = []
                        for bl in final_block:
                            if f'parent_loop: "{to_loop}"' in bl:
                                indent = bl[:len(bl) - len(bl.lstrip())]
                                final_block2.append(f'{indent}notes: "Reparented: {reason}."')
                            final_block2.append(bl)
                        final_block = final_block2
                    new_lines.extend(final_block)
                else:
                    new_lines.extend(updated_block)
            else:
                new_lines.extend(block_lines)
        else:
            new_lines.extend(block_lines)
    else:
        new_lines.append(line)
        i += 1

if not dry_run and reparented:
    gaps_file.write_text("\n".join(new_lines), encoding="utf-8")

for gid in reparented:
    print(f"reparented: {gid}")
print(f"total: {len(reparented)}")
print(f"from: {from_loop}")
print(f"to: {to_loop}")
print(f"dry_run: {dry_run}")
PY
)"

echo "gaps.reparent"
echo "$REPARENT_RESULT"

total="$(echo "$REPARENT_RESULT" | sed -n 's/^total: //p')"
if [[ "${total:-0}" -eq 0 ]]; then
  echo ""
  echo "No matching gaps found."
fi
