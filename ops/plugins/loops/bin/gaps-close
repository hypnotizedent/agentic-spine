#!/usr/bin/env bash
set -euo pipefail

# gaps.close â€” Close or fix a gap (atomic, git-locked)
#
# Usage: gaps-close --id <GAP_ID> --status <fixed|closed> \
#                   [--fixed-in "reference"] [--notes "description"] \
#                   [--regression-lock-id "D###|LOCK-ID"]
#
# Acquires git-lock, validates claim ownership (if claimed),
# updates gap status in operational.gaps.yaml, commits, cleans up claim.

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)"
source "$ROOT/ops/lib/git-lock.sh"
source "$ROOT/ops/plugins/loops/lib/gap-claims.sh"

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  echo "Usage: gaps-close --id <GAP_ID> --status <fixed|closed> [--fixed-in \"ref\"] [--notes \"desc\"] [--regression-lock-id \"id\"]"
  exit 0
fi

GAP_ID=""
STATUS="" FIXED_IN="" NOTES=""
REGRESSION_LOCK_ID=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --) shift ;;
    --id)       GAP_ID="${2:?--id requires a value}"; shift 2 ;;
    --status)   STATUS="${2:?--status requires a value}"; shift 2 ;;
    --fixed-in) FIXED_IN="${2:?--fixed-in requires a value}"; shift 2 ;;
    --notes)    NOTES="${2:?--notes requires a value}"; shift 2 ;;
    --regression-lock-id) REGRESSION_LOCK_ID="${2:?--regression-lock-id requires a value}"; shift 2 ;;
    -h|--help)
      echo "Usage: gaps-close --id <GAP_ID> --status <fixed|closed> [--fixed-in \"ref\"] [--notes \"desc\"] [--regression-lock-id \"id\"]"
      exit 0 ;;
    *) echo "FAIL: unknown arg: $1" >&2; exit 2 ;;
  esac
done

# Validate required fields
[[ -n "$GAP_ID" ]] || { echo "FAIL: --id required" >&2; exit 2; }
[[ -n "$STATUS" ]] || { echo "FAIL: --status required (fixed or closed)" >&2; exit 2; }

case "$STATUS" in
  fixed|closed) ;;
  *) echo "FAIL: --status must be 'fixed' or 'closed' (got '$STATUS')" >&2; exit 2 ;;
esac

# Validate gap exists and is open
gap_exists "$GAP_ID" || { echo "FAIL: $GAP_ID does not exist in gap registry" >&2; exit 1; }
gap_is_open "$GAP_ID" || { echo "FAIL: $GAP_ID is not open (current status is not 'open')" >&2; exit 1; }

GAP_SEVERITY="$(yq e -r ".gaps[] | select(.id == \"$GAP_ID\") | .severity // \"\"" "$GAPS_FILE" 2>/dev/null | head -n1)"
EXISTING_LOCK_ID="$(yq e -r ".gaps[] | select(.id == \"$GAP_ID\") | .regression_lock_id // \"\"" "$GAPS_FILE" 2>/dev/null | head -n1)"

# Enforce fix-to-lock discipline for high/critical closures.
if [[ "$GAP_SEVERITY" == "high" || "$GAP_SEVERITY" == "critical" ]]; then
  if [[ -z "$REGRESSION_LOCK_ID" && -z "$EXISTING_LOCK_ID" ]]; then
    echo "FAIL: $GAP_ID severity=$GAP_SEVERITY requires --regression-lock-id (or existing regression_lock_id)" >&2
    exit 1
  fi
fi

# Verify claim ownership (no claim = Terminal C direct, allowed)
verify_claim_ownership "$GAP_ID" || exit 1

# Acquire git lock
acquire_git_lock gaps || exit 1

trap 'release_git_lock' EXIT INT TERM

TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

# Update status
yq e -i "(.gaps[] | select(.id == \"$GAP_ID\")).status = \"$STATUS\"" "$GAPS_FILE" || {
  echo "FAIL: yq status update failed" >&2
  exit 1
}

# Update fixed_in if provided
if [[ -n "$FIXED_IN" ]]; then
  yq e -i "(.gaps[] | select(.id == \"$GAP_ID\")).fixed_in = \"$FIXED_IN\"" "$GAPS_FILE"
fi

# Update notes if provided
if [[ -n "$NOTES" ]]; then
  yq e -i "(.gaps[] | select(.id == \"$GAP_ID\")).notes = \"$NOTES\"" "$GAPS_FILE"
fi

# Update regression lock id if provided
if [[ -n "$REGRESSION_LOCK_ID" ]]; then
  yq e -i "(.gaps[] | select(.id == \"$GAP_ID\")).regression_lock_id = \"$REGRESSION_LOCK_ID\"" "$GAPS_FILE"
fi

# Update file timestamp
yq e -i ".updated = \"$TIMESTAMP\"" "$GAPS_FILE"

# Commit
git -C "$ROOT" add "$GAPS_FILE"
git -C "$ROOT" commit -m "$(cat <<EOF
fix($GAP_ID): mark $STATUS via gaps.close

Closed via atomic gaps.close capability.
${FIXED_IN:+Fixed in: $FIXED_IN}

Gap-Mutation: capability
Gap-Capability: gaps.close
Gap-Run-Key: ${SPINE_CAP_RUN_KEY:-manual}
${REGRESSION_LOCK_ID:+Regression-Lock-ID: $REGRESSION_LOCK_ID}
Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"

# Clean up claim file if it exists
local_claim=$(claim_file "$GAP_ID")
if [[ -f "$local_claim" ]]; then
  rm -f "$local_claim"
  echo "Claim cleaned up for $GAP_ID"
fi

echo "CLOSED: $GAP_ID (status=$STATUS${FIXED_IN:+, fixed_in=$FIXED_IN})"
