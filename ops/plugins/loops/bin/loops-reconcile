#!/usr/bin/env bash
set -euo pipefail

# loops-reconcile - Conservative auto-close for stale machine-generated loops
#
# Algorithm (locked):
#   1. Only eligible loops: loop_id starts OL_, title starts "Run failed:", owner is unassigned
#   2. Parse capability from run_key format: ...__<capability>__...
#   3. Find latest receipt for that capability after loop created_at
#   4. Auto-close only when latest receipt status is pass-class (done|ok|pass|success)
#   5. Append closure record with closed_reason=superseded_by_pass
#   6. NEVER auto-close LOOP-* manual loops
#
# Usage:
#   loops-reconcile              Run reconciliation (default: dry-run)
#   loops-reconcile --dry-run    Show what would be closed (no writes)
#   loops-reconcile --execute    Actually close eligible loops

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
LOOPS_FILE="$SPINE_REPO/mailroom/state/open_loops.jsonl"
RECEIPTS_DIR="$SPINE_REPO/receipts/sessions"

MODE="${1:---dry-run}"

usage() {
    cat <<'EOF'
loops-reconcile - Conservative auto-close for stale run-failure loops

Usage:
  loops-reconcile              Dry-run: show what would be closed
  loops-reconcile --dry-run    Same as above
  loops-reconcile --execute    Actually close eligible loops

Eligibility criteria (all must be true):
  - loop_id starts with OL_ (not LOOP-*)
  - title starts with "Run failed:"
  - owner is "unassigned"
  - A newer receipt for the same capability shows pass status

Exit codes:
  0  Success (or no eligible loops)
  1  Error
EOF
}

case "$MODE" in
    --dry-run|--execute)
        ;;
    -h|--help)
        usage
        exit 0
        ;;
    *)
        echo "ERROR: Unknown mode: $MODE" >&2
        usage
        exit 1
        ;;
esac

if [[ ! -s "$LOOPS_FILE" ]]; then
    echo "No loops to reconcile."
    exit 0
fi

# Python reconciliation logic
python3 - "$LOOPS_FILE" "$RECEIPTS_DIR" "$MODE" <<'PY'
import json
import sys
import os
import re
from datetime import datetime
from pathlib import Path

loops_file = sys.argv[1]
receipts_dir = sys.argv[2]
mode = sys.argv[3]

# Load and dedupe loops
rows = []
with open(loops_file, "r", encoding="utf-8") as f:
    for line in f:
        line = line.strip()
        if line:
            try:
                rows.append(json.loads(line))
            except json.JSONDecodeError:
                continue

# Deduplicate by loop_id (keep latest)
latest = {}
for row in rows:
    loop_id = row.get("loop_id")
    if loop_id:
        latest[loop_id] = row

# Filter to eligible loops
eligible = []
for loop_id, loop in latest.items():
    # Must be open
    if loop.get("status") != "open":
        continue
    # Must be OL_* (not LOOP-*)
    if not loop_id.startswith("OL_"):
        continue
    # Must be "Run failed:" title
    title = loop.get("title", "")
    if not title.startswith("Run failed:"):
        continue
    # Must be unassigned owner
    if loop.get("owner") != "unassigned":
        continue

    eligible.append(loop)

if not eligible:
    print("No eligible loops for reconciliation.")
    sys.exit(0)

print(f"Found {len(eligible)} eligible loop(s) for reconciliation check\n")

# Extract capability from run_key
def extract_capability(run_key):
    """Extract capability name from run_key format: ...__<capability>__..."""
    match = re.search(r'__([a-z][a-z0-9_.]+)__', run_key)
    if match:
        return match.group(1)
    return None

# Parse ISO timestamp
def parse_ts(ts_str):
    """Parse ISO timestamp, handling various formats."""
    if not ts_str:
        return None
    try:
        # Try standard format
        if ts_str.endswith('Z'):
            ts_str = ts_str[:-1] + '+00:00'
        return datetime.fromisoformat(ts_str.replace('Z', '+00:00'))
    except:
        return None

# Find latest receipt for a capability
def find_latest_receipt(capability, after_ts):
    """Find latest receipt for capability created after given timestamp."""
    receipts_path = Path(receipts_dir)
    if not receipts_path.exists():
        return None, None

    latest_receipt = None
    latest_status = None
    latest_time = None

    # Pattern: RCAP-YYYYMMDD-HHMMSS__capability__Rxxxxx
    pattern = re.compile(rf'RCAP-(\d{{8}})-(\d{{6}})__{re.escape(capability)}__R')

    for entry in receipts_path.iterdir():
        if not entry.is_dir():
            continue

        match = pattern.match(entry.name)
        if not match:
            continue

        # Parse receipt timestamp
        date_str = match.group(1)
        time_str = match.group(2)
        try:
            receipt_ts = datetime.strptime(f"{date_str}{time_str}", "%Y%m%d%H%M%S")
        except:
            continue

        # Skip if before loop creation
        if after_ts and receipt_ts <= after_ts.replace(tzinfo=None):
            continue

        # Read receipt status
        receipt_file = entry / "receipt.md"
        if not receipt_file.exists():
            continue

        try:
            content = receipt_file.read_text()
            status_match = re.search(r'\| Status \| *(\w+)', content)
            if status_match:
                status = status_match.group(1).lower()
                if latest_time is None or receipt_ts > latest_time:
                    latest_time = receipt_ts
                    latest_status = status
                    latest_receipt = str(entry / "receipt.md")
        except:
            continue

    return latest_receipt, latest_status

# Pass-class statuses
PASS_STATUSES = {'done', 'ok', 'pass', 'success'}

# Process eligible loops
to_close = []
for loop in eligible:
    loop_id = loop.get("loop_id")
    run_key = loop.get("run_key", "")
    created_at = parse_ts(loop.get("created_at"))

    capability = extract_capability(run_key)
    if not capability:
        print(f"  SKIP {loop_id}: cannot extract capability from run_key")
        continue

    receipt_path, receipt_status = find_latest_receipt(capability, created_at)

    if not receipt_path:
        print(f"  SKIP {loop_id}: no newer receipt found for {capability}")
        continue

    if receipt_status not in PASS_STATUSES:
        print(f"  SKIP {loop_id}: latest {capability} status is '{receipt_status}' (not pass-class)")
        continue

    print(f"  CLOSE {loop_id}: {capability} now passes (evidence: {receipt_path})")
    to_close.append({
        "loop": loop,
        "capability": capability,
        "receipt_path": receipt_path,
        "receipt_status": receipt_status
    })

print()

if not to_close:
    print("No loops eligible for auto-close.")
    sys.exit(0)

if mode == "--dry-run":
    print(f"DRY-RUN: Would close {len(to_close)} loop(s)")
    print("Run with --execute to apply changes.")
    sys.exit(0)

# Execute closures
print(f"Closing {len(to_close)} loop(s)...")

closed_at = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

with open(loops_file, "a", encoding="utf-8") as f:
    for item in to_close:
        loop = item["loop"]
        closure = {
            **loop,
            "status": "closed",
            "closed_at": closed_at,
            "closed_reason": "superseded_by_pass",
            "closed_by": "loops.reconcile",
            "superseding_receipt": item["receipt_path"]
        }
        f.write(json.dumps(closure) + "\n")
        print(f"  CLOSED: {loop.get('loop_id')}")

print(f"\nReconciliation complete: {len(to_close)} loop(s) closed.")
PY
