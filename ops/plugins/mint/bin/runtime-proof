#!/usr/bin/env bash
# runtime-proof - Deep runtime behavior proof for mint modules on VM 213.
#
# Read-only checks proving module behavior is not a stale stub.
# Fails (exit 1) if any proof check fails.
# STOP=2 for precondition/input errors.
#
# Checks:
#   - pricing health
#   - shipping live API semantics (shop-address not placeholder)
#   - suppliers search + stock parity
#   - artwork upload/prepare parity
#   - payment health

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
PROBE_BINDING="$SPINE_ROOT/ops/bindings/mint.probe.targets.yaml"

stop(){ echo "STOP (2): $*" >&2; exit 2; }

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v ssh >/dev/null 2>&1 || stop "missing dependency: ssh"
command -v curl >/dev/null 2>&1 || stop "missing dependency: curl"
command -v jq >/dev/null 2>&1 || stop "missing dependency: jq"
[[ -f "$SSH_BINDING" ]] || stop "missing binding: $SSH_BINDING"
[[ -f "$PROBE_BINDING" ]] || stop "missing binding: $PROBE_BINDING"

APP_TARGET_ID="$(yq -r '.targets.app_plane.ssh_target // ""' "$PROBE_BINDING")"
DATA_TARGET_ID="$(yq -r '.targets.data_plane.ssh_target // ""' "$PROBE_BINDING")"
[[ -n "$APP_TARGET_ID" && "$APP_TARGET_ID" != "null" ]] || stop "missing app plane target in $PROBE_BINDING"
[[ -n "$DATA_TARGET_ID" && "$DATA_TARGET_ID" != "null" ]] || stop "missing data plane target in $PROBE_BINDING"

MINT_APPS_HOST="$(yq -r ".ssh.targets[] | select(.id == \"$APP_TARGET_ID\") | .host" "$SSH_BINDING" | head -n1)"
MINT_APPS_USER="$(yq -r ".ssh.targets[] | select(.id == \"$APP_TARGET_ID\") | .user // \"ubuntu\"" "$SSH_BINDING" | head -n1)"
MINT_DATA_HOST="$(yq -r ".ssh.targets[] | select(.id == \"$DATA_TARGET_ID\") | .host" "$SSH_BINDING" | head -n1)"
MINT_DATA_USER="$(yq -r ".ssh.targets[] | select(.id == \"$DATA_TARGET_ID\") | .user // \"ubuntu\"" "$SSH_BINDING" | head -n1)"
[[ -n "$MINT_APPS_HOST" && "$MINT_APPS_HOST" != "null" ]] || stop "$APP_TARGET_ID not found in ssh.targets"
[[ -n "$MINT_DATA_HOST" && "$MINT_DATA_HOST" != "null" ]] || stop "$DATA_TARGET_ID not found in ssh.targets"

service_port() {
  local service="$1"
  yq -r ".targets.app_plane.http_checks[] | select(.id == \"$service\") | .port // \"\"" "$PROBE_BINDING" | head -n1
}

service_health_path() {
  local service="$1"
  yq -r ".targets.app_plane.http_checks[] | select(.id == \"$service\") | .health_path // \"\"" "$PROBE_BINDING" | head -n1
}

proof_route() {
  local key="$1"
  yq -r ".proof_routes.$key // \"\"" "$PROBE_BINDING" | head -n1
}

require_value() {
  local value="$1" label="$2"
  [[ -n "$value" && "$value" != "null" ]] || stop "missing $label in $PROBE_BINDING"
}

PRICING_PORT="$(service_port pricing)"
PRICING_HEALTH="$(service_health_path pricing)"
SHIPPING_PORT="$(service_port shipping)"
SUPPLIERS_PORT="$(service_port suppliers)"
FILES_PORT="$(service_port files-api)"
PAYMENT_PORT="$(service_port payment)"
PAYMENT_HEALTH="$(service_health_path payment)"
SHIPPING_SHOP_PATH="$(proof_route shipping_shop_address_path)"
SUPPLIERS_SEARCH_PATH="$(proof_route suppliers_search_path)"
SUPPLIERS_STOCK_TEMPLATE="$(proof_route suppliers_stock_path_template)"
ARTWORK_PREPARE_PATH="$(proof_route artwork_upload_prepare_path)"

require_value "$PRICING_PORT" "pricing port"
require_value "$PRICING_HEALTH" "pricing health path"
require_value "$SHIPPING_PORT" "shipping port"
require_value "$SUPPLIERS_PORT" "suppliers port"
require_value "$FILES_PORT" "files-api port"
require_value "$PAYMENT_PORT" "payment port"
require_value "$PAYMENT_HEALTH" "payment health path"
require_value "$SHIPPING_SHOP_PATH" "shipping_shop_address_path"
require_value "$SUPPLIERS_SEARCH_PATH" "suppliers_search_path"
require_value "$SUPPLIERS_STOCK_TEMPLATE" "suppliers_stock_path_template"
require_value "$ARTWORK_PREPARE_PATH" "artwork_upload_prepare_path"

SSH_OPTS=(-o ConnectTimeout=6 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes -o LogLevel=ERROR)

fail=0

emit_row() {
  local check="$1" state="$2" note="$3"
  printf "%-28s %-8s %s\n" "$check" "$state" "$note"
}

http_json_check() {
  local name="$1" url="$2" jq_expr="$3" pass_note="$4"
  local tmp http
  tmp="$(mktemp)"
  set +e
  http="$(curl -sS -m 10 -o "$tmp" -w "%{http_code}" "$url")"
  local rc=$?
  set -e
  if [[ "$rc" -ne 0 ]]; then
    emit_row "$name" "FAIL" "curl_rc=$rc url=$url"
    fail=1
    rm -f "$tmp"
    return
  fi
  if [[ "$http" != "200" ]]; then
    emit_row "$name" "FAIL" "http=$http url=$url"
    fail=1
    rm -f "$tmp"
    return
  fi
  if ! jq -e "$jq_expr" "$tmp" >/dev/null 2>&1; then
    emit_row "$name" "FAIL" "http=200 json_assert_failed"
    fail=1
    rm -f "$tmp"
    return
  fi
  emit_row "$name" "PASS" "$pass_note"
  rm -f "$tmp"
}

get_container_key() {
  local container="$1"
  ssh "${SSH_OPTS[@]}" "${MINT_APPS_USER}@${MINT_APPS_HOST}" \
    "docker inspect $container --format '{{range .Config.Env}}{{println .}}{{end}}' | awk -F= '/^API_KEY=/{sub(/^API_KEY=/,\"\" ); print; exit}'"
}

container_env_present() {
  local container="$1" key="$2"
  ssh "${SSH_OPTS[@]}" "${MINT_APPS_USER}@${MINT_APPS_HOST}" \
    "docker inspect $container --format '{{range .Config.Env}}{{println .}}{{end}}' | awk -F= -v K='$key' '\$1==K && \$2!=\"\"{found=1} END{exit found?0:1}'"
}

echo "mint.runtime.proof"
echo "probe.binding: $PROBE_BINDING"
echo "$APP_TARGET_ID: ${MINT_APPS_USER}@${MINT_APPS_HOST}"
echo "$DATA_TARGET_ID: ${MINT_DATA_USER}@${MINT_DATA_HOST}"
echo
printf "%-28s %-8s %s\n" "CHECK" "STATE" "DETAIL"

# 1) Pricing health
http_json_check \
  "pricing.health" \
  "http://${MINT_APPS_HOST}:${PRICING_PORT}${PRICING_HEALTH}" \
  '.status == "ok" and ((.service // .name // "") | test("pricing"; "i"))' \
  "pricing health json ok"

# 2) Shipping must not be placeholder stub
shipping_key="$(get_container_key shipping || true)"
if [[ -z "$shipping_key" ]]; then
  emit_row "shipping.api_key" "FAIL" "missing API_KEY from shipping container"
  fail=1
else
  tmp_ship="$(mktemp)"
  set +e
  ship_http="$(curl -sS -m 10 -o "$tmp_ship" -w "%{http_code}" -H "x-api-key: $shipping_key" "http://${MINT_APPS_HOST}:${SHIPPING_PORT}${SHIPPING_SHOP_PATH}")"
  ship_rc=$?
  set -e
  if [[ "$ship_rc" -ne 0 || "$ship_http" != "200" ]]; then
    emit_row "shipping.shop_address" "FAIL" "curl_rc=$ship_rc http=$ship_http"
    fail=1
  elif jq -e '.address.street1 | test("Print Shop Lane"; "i")' "$tmp_ship" >/dev/null 2>&1; then
    emit_row "shipping.shop_address" "FAIL" "placeholder address detected"
    fail=1
  else
    emit_row "shipping.shop_address" "PASS" "non-placeholder address"
  fi
  rm -f "$tmp_ship"
fi

# 3) Suppliers search + stock parity (behavioral; do not require seeded catalog rows)
suppliers_key="$(get_container_key suppliers || true)"
if [[ -z "$suppliers_key" ]]; then
  emit_row "suppliers.api_key" "FAIL" "missing API_KEY from suppliers container"
  fail=1
else
  tmp_search="$(mktemp)"
  set +e
  search_http="$(curl -sS -m 10 -o "$tmp_search" -w "%{http_code}" -H "x-api-key: $suppliers_key" "http://${MINT_APPS_HOST}:${SUPPLIERS_PORT}${SUPPLIERS_SEARCH_PATH}?q=PC61&limit=1")"
  search_rc=$?
  set -e
  if [[ "$search_rc" -ne 0 || "$search_http" != "200" ]]; then
    emit_row "suppliers.search" "FAIL" "curl_rc=$search_rc http=$search_http"
    fail=1
  elif ! jq -e '.query != null and (.results | type == "array") and (.total | type == "number")' "$tmp_search" >/dev/null 2>&1; then
    emit_row "suppliers.search" "FAIL" "search payload shape invalid"
    fail=1
  elif jq -e '(.results | length) == 0' "$tmp_search" >/dev/null 2>&1; then
    emit_row "suppliers.search" "PASS" "search endpoint healthy (no seeded catalog rows)"
    emit_row "suppliers.stock" "PASS" "skipped (no sku from search result)"
  else
    emit_row "suppliers.search" "PASS" "search returned sku"
    sku="$(jq -r '.results[0].supplier_sku' "$tmp_search")"
    code="$(jq -r '.results[0].supplier_code // "sanmar"' "$tmp_search")"
    stock_path="${SUPPLIERS_STOCK_TEMPLATE/\{code\}/$code}"
    stock_path="${stock_path/\{sku\}/$sku}"
    tmp_stock="$(mktemp)"
    set +e
    stock_http="$(curl -sS -m 10 -o "$tmp_stock" -w "%{http_code}" -H "x-api-key: $suppliers_key" "http://${MINT_APPS_HOST}:${SUPPLIERS_PORT}${stock_path}")"
    stock_rc=$?
    set -e
    if [[ "$stock_rc" -ne 0 || "$stock_http" != "200" ]]; then
      emit_row "suppliers.stock" "FAIL" "curl_rc=$stock_rc http=$stock_http code=$code sku=$sku"
      fail=1
    elif ! jq -e '(.variants | length) > 0 and (.total_available // 0) >= 0' "$tmp_stock" >/dev/null 2>&1; then
      emit_row "suppliers.stock" "FAIL" "missing variants"
      fail=1
    else
      emit_row "suppliers.stock" "PASS" "stock variants returned"
    fi
    rm -f "$tmp_stock"
  fi
  rm -f "$tmp_search"
fi

# 4) Artwork upload prepare parity (legacy alias + fresh behavior)
files_key="$(get_container_key files-api || true)"
if [[ -z "$files_key" ]]; then
  emit_row "artwork.api_key" "FAIL" "missing API_KEY from files-api container"
  fail=1
else
  tmp_art="$(mktemp)"
  set +e
  art_http="$(curl -sS -m 10 -o "$tmp_art" -w "%{http_code}" \
    -H "x-api-key: $files_key" \
    -H "content-type: application/json" \
    -d '{"visual_id":"30100","kind":"original","filename":"proof.png","content_type":"image/png","size_bytes":1024}' \
    "http://${MINT_APPS_HOST}:${FILES_PORT}${ARTWORK_PREPARE_PATH}")"
  art_rc=$?
  set -e
  if [[ "$art_rc" -ne 0 || "$art_http" != "200" ]]; then
    details="$(head -c 120 "$tmp_art" | tr '\n' ' ')"
    emit_row "artwork.upload_prepare" "FAIL" "curl_rc=$art_rc http=$art_http body=$details"
    fail=1
  elif ! jq -e '(.upload_id // "") != "" and (.presigned_url // "") != ""' "$tmp_art" >/dev/null 2>&1; then
    emit_row "artwork.upload_prepare" "FAIL" "missing upload_id/presigned_url"
    fail=1
  else
    emit_row "artwork.upload_prepare" "PASS" "prepare returns presigned payload"
  fi
  rm -f "$tmp_art"
fi

# 5) Payment health
missing_payment_env=()
for req_key in API_KEY DATABASE_URL STRIPE_SECRET_KEY STRIPE_WEBHOOK_SECRET JWT_SECRET; do
  if ! container_env_present payment "$req_key"; then
    missing_payment_env+=("$req_key")
  fi
done
if [[ "${#missing_payment_env[@]}" -gt 0 ]]; then
  emit_row "payment.env" "FAIL" "missing ${missing_payment_env[*]}"
  fail=1
else
  emit_row "payment.env" "PASS" "required env present"
fi

http_json_check \
  "payment.health" \
  "http://${MINT_APPS_HOST}:${PAYMENT_PORT}${PAYMENT_HEALTH}" \
  '.status == "ok" and ((.service // "") | test("payment"; "i"))' \
  "payment health json ok"

echo
if [[ "$fail" -eq 1 ]]; then
  echo "status: FAIL (runtime proof blockers present)"
  exit 1
fi
echo "status: OK (runtime proof checks passed)"
exit 0
