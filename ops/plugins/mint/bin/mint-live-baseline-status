#!/usr/bin/env bash
# mint-live-baseline-status - Enforce mint live baseline with dual auth-state semantics.
#
# Read-only status surface:
#   - live_health_green: mint.modules.health status line must be OK
#   - contract_parity_green: D222 + mint quoteflow guard must pass
#   - agent_smoke_green: mint.runtime.proof must pass
#   - queue_marker_green:
#       mode A (deferred): execution queue must explicitly block EQ-1 by D225
#       mode B (extracted_complete): queue block markers become N/A-green when EQ-1 is completed
#
# Usage:
#   mint-live-baseline-status
#   mint-live-baseline-status --strict
#
# Exit codes:
#   0 = all green (or non-strict mode with red checks)
#   1 = one or more checks red (strict mode)
#   2 = precondition/configuration failure

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
CONTRACT="$SPINE_ROOT/ops/bindings/mint.module.sequence.contract.yaml"
PROBE_BINDING="$SPINE_ROOT/ops/bindings/mint.probe.targets.yaml"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
MINT_MODULES_ROOT="${MINT_MODULES_ROOT:-$HOME/code/mint-modules}"

STRICT=0
if [[ "${1:-}" == "--strict" ]]; then
  STRICT=1
fi

stop(){ echo "STOP (2): $*" >&2; exit 2; }

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v rg >/dev/null 2>&1 || stop "missing dependency: rg"
[[ -f "$CONTRACT" ]] || stop "missing contract: $CONTRACT"
[[ -f "$PROBE_BINDING" ]] || stop "missing binding: $PROBE_BINDING"
[[ -f "$SSH_BINDING" ]] || stop "missing binding: $SSH_BINDING"

QUEUE_FILE="$(yq -r '.queue_contract.file // ""' "$CONTRACT")"
[[ -n "$QUEUE_FILE" && "$QUEUE_FILE" != "null" ]] || stop "queue_contract.file missing in contract"
[[ -f "$QUEUE_FILE" ]] || stop "queue file not found: $QUEUE_FILE"

auth_state="$(yq -r '.auth_module.state // ""' "$CONTRACT")"
blocked_gate="$(yq -r '.auth_module.blocked_by_gate // ""' "$CONTRACT")"
accepted_states="$(yq -r '.auth_module.accepted_states[]? // ""' "$CONTRACT" || true)"
[[ -n "$auth_state" && "$auth_state" != "null" ]] || stop "auth_module.state missing in contract"
[[ "$blocked_gate" == "D225" ]] || stop "auth_module.blocked_by_gate must be D225 (actual=$blocked_gate)"

if [[ -n "$accepted_states" ]]; then
  if ! printf '%s\n' "$accepted_states" | rg -qx "$auth_state"; then
    stop "auth_module.state not allowed by auth_module.accepted_states (state=$auth_state)"
  fi
else
  case "$auth_state" in
    deferred|extracted_complete) ;;
    *) stop "unsupported auth_module.state (actual=$auth_state)" ;;
  esac
fi

deferred_marker_a="$(yq -r '.auth_module.deferred_markers[0] // .queue_contract.required_markers[0] // "BLOCKED_BY_D225"' "$CONTRACT")"
deferred_marker_b="$(yq -r '.auth_module.deferred_markers[1] // .queue_contract.required_markers[1] // "AUTH_DEFERRED_UNTIL_LIVE_BASELINE"' "$CONTRACT")"
completion_heading="$(yq -r '.auth_module.completion.heading // "### EQ-1: Auth Module"' "$CONTRACT")"
completion_status_pattern="$(yq -r '.auth_module.completion.status_pattern // "Execution status.*COMPLETED"' "$CONTRACT")"

for prereq in live_health_green contract_parity_green agent_smoke_green; do
  if ! yq -e ".prerequisites.$prereq" "$CONTRACT" >/dev/null 2>&1; then
    stop "missing prerequisite in contract: $prereq"
  fi
done

run_and_capture() {
  local outfile="$1"
  shift
  set +e
  "$@" >"$outfile" 2>&1
  local rc=$?
  set -e
  return "$rc"
}

report_row() {
  printf "%-24s %-8s %s\n" "$1" "$2" "$3"
}

overall_red=0

echo "mint.live.baseline.status"
echo "contract: $CONTRACT"
echo "queue: $QUEUE_FILE"
echo "probe.binding: $PROBE_BINDING"
echo
printf "%-24s %-8s %s\n" "CHECK" "STATE" "DETAIL"

app_target_id="$(yq -r '.targets.app_plane.ssh_target // ""' "$PROBE_BINDING")"
data_target_id="$(yq -r '.targets.data_plane.ssh_target // ""' "$PROBE_BINDING")"
app_host="$(yq -r ".ssh.targets[] | select(.id == \"$app_target_id\") | .host // \"\"" "$SSH_BINDING" | head -n1)"
data_host="$(yq -r ".ssh.targets[] | select(.id == \"$data_target_id\") | .host // \"\"" "$SSH_BINDING" | head -n1)"
if [[ -z "$app_target_id" || "$app_target_id" == "null" || -z "$data_target_id" || "$data_target_id" == "null" || -z "$app_host" || "$app_host" == "null" || -z "$data_host" || "$data_host" == "null" ]]; then
  report_row "probe_target_green" "RED" "invalid mint.probe.targets or ssh target mapping"
  overall_red=1
else
  report_row "probe_target_green" "GREEN" "app=${app_target_id}@${app_host} data=${data_target_id}@${data_host}"
fi

# 1) live_health_green
tmp_live="$(mktemp)"
if run_and_capture "$tmp_live" "$SPINE_ROOT/ops/plugins/mint/bin/modules-health"; then
  if rg -q '^status: OK' "$tmp_live"; then
    report_row "live_health_green" "GREEN" "mint.modules.health status OK"
  else
    detail="$(rg '^status:' "$tmp_live" | tail -n1 || true)"
    report_row "live_health_green" "RED" "${detail:-status line missing}"
    overall_red=1
  fi
else
  report_row "live_health_green" "RED" "mint.modules.health execution failed"
  overall_red=1
fi
rm -f "$tmp_live"

# 2) contract_parity_green
parity_red=0
tmp_d222="$(mktemp)"
if run_and_capture "$tmp_d222" "$SPINE_ROOT/surfaces/verify/d222-quote-alert-provider-boundary-lock.sh"; then
  :
else
  parity_red=1
fi
rm -f "$tmp_d222"

tmp_quote="$(mktemp)"
if run_and_capture "$tmp_quote" "$MINT_MODULES_ROOT/scripts/guard/quoteflow-baseline-lock.sh" "$MINT_MODULES_ROOT"; then
  :
else
  parity_red=1
fi
rm -f "$tmp_quote"

if [[ "$parity_red" -eq 0 ]]; then
  report_row "contract_parity_green" "GREEN" "D222 + quoteflow guard pass"
else
  report_row "contract_parity_green" "RED" "one or more parity checks failed"
  overall_red=1
fi

# 3) agent_smoke_green
tmp_smoke="$(mktemp)"
if run_and_capture "$tmp_smoke" "$SPINE_ROOT/ops/plugins/mint/bin/runtime-proof"; then
  if rg -q '^status: OK' "$tmp_smoke"; then
    report_row "agent_smoke_green" "GREEN" "mint.runtime.proof status OK"
  else
    detail="$(rg '^status:' "$tmp_smoke" | tail -n1 || true)"
    report_row "agent_smoke_green" "RED" "${detail:-status line missing}"
    overall_red=1
  fi
else
  report_row "agent_smoke_green" "RED" "mint.runtime.proof failed"
  overall_red=1
fi
rm -f "$tmp_smoke"

# 4) queue marker alignment (state-aware)
eq1_heading_present=0
eq1_status_complete=0
eq1_section="$(awk -v heading="$completion_heading" '
  index($0, heading) {in_section=1}
  in_section {
    if ($0 ~ /^### EQ-[0-9]+:/ && index($0, heading) == 0) exit
    print
  }
' "$QUEUE_FILE")"

if [[ -n "$eq1_section" ]]; then
  eq1_heading_present=1
fi
if [[ -n "$eq1_section" ]] && printf '%s\n' "$eq1_section" | rg -q "$completion_status_pattern"; then
  eq1_status_complete=1
fi

if [[ "$auth_state" == "deferred" ]]; then
  if rg -q "$deferred_marker_a" "$QUEUE_FILE" && rg -q "$deferred_marker_b" "$QUEUE_FILE"; then
    report_row "queue_marker_green" "GREEN" "deferred mode markers present ($deferred_marker_a + $deferred_marker_b)"
  else
    report_row "queue_marker_green" "RED" "deferred mode missing $deferred_marker_a/$deferred_marker_b markers"
    overall_red=1
  fi
elif [[ "$auth_state" == "extracted_complete" ]]; then
  if [[ "$eq1_heading_present" -eq 1 && "$eq1_status_complete" -eq 1 ]]; then
    report_row "queue_marker_green" "GREEN" "N/A-green (EQ-1 completed; deferred markers not required)"
  else
    report_row "queue_marker_green" "RED" "auth extracted_complete but EQ-1 completion evidence missing in queue"
    overall_red=1
  fi
else
  report_row "queue_marker_green" "RED" "unsupported auth_state=$auth_state"
  overall_red=1
fi

echo
if [[ "$overall_red" -eq 0 ]]; then
  echo "status: OK (live modules baseline is green; auth_state=$auth_state)"
  exit 0
fi

echo "status: FAIL (live baseline is red; auth remains blocked)"
if [[ "$STRICT" -eq 1 ]]; then
  exit 1
fi
exit 0
