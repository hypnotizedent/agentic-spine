#!/usr/bin/env bash
set -euo pipefail

# network.home.dhcp.dns.set â€” set home UDR7 DHCP DNS server(s) via UniFi API
# Mutating/manual capability for deterministic home DNS cutovers.

SPINE_ROOT="${SPINE_ROOT:-$HOME/code/agentic-spine}"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
INFISICAL_AGENT="$SPINE_ROOT/ops/tools/infisical-agent.sh"

SITE="default"
PRIMARY_DNS=""
SECONDARY_DNS=""
EXECUTE=0

usage() {
  cat <<'EOF'
network-home-dhcp-dns-set

Usage:
  network-home-dhcp-dns-set --primary-dns <IPv4> [--secondary-dns <IPv4>] [--site default] [--execute]

Behavior:
  - Reads current LAN networkconf from home UDR7 via proxmox-home.
  - Prints current and proposed DHCP DNS settings.
  - Dry-run by default. Use --execute to apply.

Examples:
  network-home-dhcp-dns-set --primary-dns 10.0.0.53
  network-home-dhcp-dns-set --primary-dns 10.0.0.53 --secondary-dns 10.0.0.1 --execute
EOF
}

is_ipv4() {
  local ip="$1"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  local IFS=.
  local -a oct
  read -r -a oct <<< "$ip"
  for n in "${oct[@]}"; do
    [[ "$n" =~ ^[0-9]+$ ]] || return 1
    (( n >= 0 && n <= 255 )) || return 1
  done
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --primary-dns)
      PRIMARY_DNS="${2:-}"
      shift 2
      ;;
    --secondary-dns)
      SECONDARY_DNS="${2:-}"
      shift 2
      ;;
    --site)
      SITE="${2:-default}"
      shift 2
      ;;
    --execute)
      EXECUTE=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "FAIL: unknown argument: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

[[ -n "$PRIMARY_DNS" ]] || { echo "FAIL: --primary-dns is required" >&2; exit 2; }
is_ipv4 "$PRIMARY_DNS" || { echo "FAIL: invalid IPv4 for --primary-dns: $PRIMARY_DNS" >&2; exit 2; }
if [[ -n "$SECONDARY_DNS" ]]; then
  is_ipv4 "$SECONDARY_DNS" || { echo "FAIL: invalid IPv4 for --secondary-dns: $SECONDARY_DNS" >&2; exit 2; }
fi

command -v yq >/dev/null 2>&1 || { echo "STOP (2): missing dependency: yq" >&2; exit 2; }
command -v jq >/dev/null 2>&1 || { echo "STOP (2): missing dependency: jq" >&2; exit 2; }
command -v ssh >/dev/null 2>&1 || { echo "STOP (2): missing dependency: ssh" >&2; exit 2; }
[[ -f "$SSH_BINDING" ]] || { echo "STOP (2): missing binding: $SSH_BINDING" >&2; exit 2; }

PROXY_HOST="$(yq -r '.ssh.targets[] | select(.id == "proxmox-home") | .host' "$SSH_BINDING")"
PROXY_USER="$(yq -r '.ssh.targets[] | select(.id == "proxmox-home") | .user // "root"' "$SSH_BINDING")"
UDR_HOST="$(yq -r '.ssh.targets[] | select(.id == "udr-home") | .host' "$SSH_BINDING")"
[[ -n "$PROXY_HOST" && "$PROXY_HOST" != "null" ]] || { echo "STOP (2): proxmox-home host missing in ssh.targets" >&2; exit 2; }
[[ -n "$UDR_HOST" && "$UDR_HOST" != "null" ]] || { echo "STOP (2): udr-home host missing in ssh.targets" >&2; exit 2; }

API_KEY="${UNIFI_HOME_API_KEY:-}"
if [[ -z "$API_KEY" && -x "$INFISICAL_AGENT" ]]; then
  API_KEY="$("$INFISICAL_AGENT" get-cached home-assistant prod UNIFI_HOME_API_KEY 2>/dev/null || true)"
fi
[[ -n "$API_KEY" ]] || { echo "STOP (2): UNIFI_HOME_API_KEY unavailable" >&2; exit 2; }

API_B64="$(printf '%s' "$API_KEY" | base64)"

fetch_networks() {
  ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes -o LogLevel=ERROR \
    "${PROXY_USER}@${PROXY_HOST}" "bash -s" <<EOF
set -euo pipefail
api_key="\$(echo '$API_B64' | base64 -d)"
curl -sk "https://${UDR_HOST}/proxy/network/api/s/${SITE}/rest/networkconf" \
  -H "X-API-KEY: \$api_key" \
  -H "Accept: application/json" 2>/dev/null
EOF
}

echo "network.home.dhcp.dns.set"
echo "proxy: ${PROXY_USER}@${PROXY_HOST}"
echo "udr-home: ${UDR_HOST}"
echo "site: $SITE"
echo

RAW="$(fetch_networks)"
NETWORK_JSON="$(echo "$RAW" | jq -c '.data[] | select(.purpose=="corporate" and (.networkgroup=="LAN" or .name=="Default"))' | head -n1)"
[[ -n "$NETWORK_JSON" ]] || { echo "FAIL: LAN corporate networkconf not found" >&2; exit 1; }

NETWORK_ID="$(echo "$NETWORK_JSON" | jq -r '._id')"
NETWORK_NAME="$(echo "$NETWORK_JSON" | jq -r '.name')"
CUR_ENABLED="$(echo "$NETWORK_JSON" | jq -r '.dhcpd_dns_enabled // false')"
CUR_DNS1="$(echo "$NETWORK_JSON" | jq -r '.dhcpd_dns_1 // ""')"
CUR_DNS2="$(echo "$NETWORK_JSON" | jq -r '.dhcpd_dns_2 // ""')"

echo "current:"
echo "  network: $NETWORK_NAME ($NETWORK_ID)"
echo "  dhcpd_dns_enabled: $CUR_ENABLED"
echo "  dhcpd_dns_1: ${CUR_DNS1:-<null>}"
echo "  dhcpd_dns_2: ${CUR_DNS2:-<null>}"
echo
echo "proposed:"
echo "  dhcpd_dns_enabled: true"
echo "  dhcpd_dns_1: $PRIMARY_DNS"
echo "  dhcpd_dns_2: ${SECONDARY_DNS:-<null>}"
echo

if [[ "$EXECUTE" -ne 1 ]]; then
  echo "DRY-RUN: no changes applied. Re-run with --execute to mutate."
  exit 0
fi

PAYLOAD="$(PRIMARY_DNS="$PRIMARY_DNS" SECONDARY_DNS="$SECONDARY_DNS" python3 - <<'PY'
import json, os
payload = {
    "dhcpd_dns_enabled": True,
    "dhcpd_dns_1": os.environ["PRIMARY_DNS"],
    "dhcpd_dns_2": os.environ["SECONDARY_DNS"] if os.environ["SECONDARY_DNS"] else None,
}
print(json.dumps(payload, separators=(",", ":")))
PY
)"
PAYLOAD_B64="$(printf '%s' "$PAYLOAD" | base64)"

RESULT="$(
  ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes -o LogLevel=ERROR \
    "${PROXY_USER}@${PROXY_HOST}" "bash -s" <<EOF
set -euo pipefail
api_key="\$(echo '$API_B64' | base64 -d)"
payload="\$(echo '$PAYLOAD_B64' | base64 -d)"
printf '%s' "\$payload" | curl -sk -X PUT "https://${UDR_HOST}/proxy/network/api/s/${SITE}/rest/networkconf/${NETWORK_ID}" \
  -H "X-API-KEY: \$api_key" \
  -H "Content-Type: application/json" \
  --data-binary @- \
  -w '\n%{http_code}' 2>/dev/null
EOF
)"

HTTP_CODE="$(echo "$RESULT" | tail -n1)"
HTTP_BODY="$(echo "$RESULT" | sed '$d')"
if [[ "$HTTP_CODE" != "200" ]]; then
  echo "FAIL: UniFi API returned HTTP $HTTP_CODE" >&2
  echo "$HTTP_BODY" | jq . 2>/dev/null || echo "$HTTP_BODY"
  exit 1
fi

UPDATED_RAW="$(fetch_networks)"
UPDATED="$(echo "$UPDATED_RAW" | jq -c --arg id "$NETWORK_ID" '.data[] | select(._id==$id)' | head -n1)"
NEW_ENABLED="$(echo "$UPDATED" | jq -r '.dhcpd_dns_enabled // false')"
NEW_DNS1="$(echo "$UPDATED" | jq -r '.dhcpd_dns_1 // ""')"
NEW_DNS2="$(echo "$UPDATED" | jq -r '.dhcpd_dns_2 // ""')"

echo "applied: OK (HTTP 200)"
echo "verified:"
echo "  dhcpd_dns_enabled: $NEW_ENABLED"
echo "  dhcpd_dns_1: ${NEW_DNS1:-<null>}"
echo "  dhcpd_dns_2: ${NEW_DNS2:-<null>}"
