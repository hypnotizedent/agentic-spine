#!/usr/bin/env bash
# network-pve-post-cutover-harden - Post-cutover hardening for shop Proxmox host (pve)
#
# Mutations (only with --execute):
# - Disable accepting subnet routes on pve (tailscale set --accept-routes=false) to
#   prevent stale/foreign LAN routes (e.g., 192.168.12.0/24) from hijacking local traffic.
# - Fix Tailscale's captured "system DNS" backup to the new shop DNS (Pi-hole on infra-core).
# - Prune stale NFS export entries that reference missing paths.
#
# Default is dry-run.
#
# Usage:
#   network-pve-post-cutover-harden [--dry-run|--execute]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"

SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"

usage() {
  cat <<'EOF'
network-pve-post-cutover-harden - Post-cutover hardening for pve

Usage:
  network-pve-post-cutover-harden [--dry-run|--execute]

Notes:
  - pve is reached via ops/bindings/ssh.targets.yaml (id: pve)
  - default is dry-run
EOF
}

stop(){ echo "STOP (2): $*" >&2; exit 2; }
fail(){ echo "FAIL: $*" >&2; exit 1; }

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v ssh >/dev/null 2>&1 || stop "missing dependency: ssh"

[[ -f "$SSH_BINDING" ]] || stop "missing binding: $SSH_BINDING"

EXECUTE=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    --execute) EXECUTE=1; shift ;;
    --dry-run) EXECUTE=0; shift ;;
    -h|--help) usage; exit 0 ;;
    *) fail "unknown argument: $1" ;;
  esac
done

DEF_USER="$(yq -r '.ssh.defaults.user // "root"' "$SSH_BINDING")"
DEF_PORT="$(yq -r '.ssh.defaults.port // 22' "$SSH_BINDING")"
DEF_TO="$(yq -r '.ssh.defaults.connect_timeout_sec // 5' "$SSH_BINDING")"
DEF_BATCH="$(yq -r '.ssh.defaults.batch_mode // true' "$SSH_BINDING")"
DEF_STRICT="$(yq -r '.ssh.defaults.strict_host_key_checking // "no"' "$SSH_BINDING")"
DEF_KNOWN_HOSTS="$(yq -r '.ssh.defaults.user_known_hosts_file // "/dev/null"' "$SSH_BINDING")"

pve_host="$(yq -r '.ssh.targets[] | select(.id == "pve") | .host // ""' "$SSH_BINDING" | head -n1)"
pve_user="$(yq -r '.ssh.targets[] | select(.id == "pve") | .user // "'"$DEF_USER"'"' "$SSH_BINDING" | head -n1)"
pve_port="$(yq -r '.ssh.targets[] | select(.id == "pve") | .port // '"$DEF_PORT"'' "$SSH_BINDING" | head -n1)"
pve_to="$(yq -r '.ssh.targets[] | select(.id == "pve") | .connect_timeout_sec // '"$DEF_TO"'' "$SSH_BINDING" | head -n1)"

[[ -n "$pve_host" && "$pve_host" != "null" ]] || stop "ssh target 'pve' missing host in $SSH_BINDING"
[[ -n "$pve_user" && "$pve_user" != "null" ]] || pve_user="$DEF_USER"
[[ -n "$pve_port" && "$pve_port" != "null" ]] || pve_port="$DEF_PORT"
[[ -n "$pve_to" && "$pve_to" != "null" ]] || pve_to="$DEF_TO"

ssh_opts=(
  -o "ConnectTimeout=${pve_to}"
  -o "StrictHostKeyChecking=${DEF_STRICT}"
  -o "UserKnownHostsFile=${DEF_KNOWN_HOSTS}"
  -o "NumberOfPasswordPrompts=0"
  -o "LogLevel=ERROR"
)
if [[ "$DEF_BATCH" == "true" ]]; then
  ssh_opts+=(-o "BatchMode=yes")
fi

echo "network.pve.post_cutover.harden"
echo "mode: $([[ "$EXECUTE" -eq 1 ]] && echo execute || echo dry-run)"
echo "target: pve (${pve_user}@${pve_host}:${pve_port})"
echo

remote_readonly='
set -euo pipefail
echo "== tailscale prefs (summary) =="
tailscale debug prefs | python3 -c "import json,sys; j=json.load(sys.stdin); print(f\"RouteAll={j.get('RouteAll')} CorpDNS={j.get('CorpDNS')} AdvertiseRoutes={j.get('AdvertiseRoutes')}\")" 2>/dev/null || true
echo
echo "== tailscale dns status (system) =="
tailscale dns status 2>/dev/null | sed -n "1,120p" || true
echo
echo "== tailscale health =="
tailscale status 2>/dev/null | sed -n "1,120p" || true
echo
echo "== routes in table 52 (192.168.*) =="
ip route show table 52 2>/dev/null | egrep "^192\\.168\\." || true
echo
echo "== /etc/resolv.pre-tailscale-backup.conf =="
if [[ -f /etc/resolv.pre-tailscale-backup.conf ]]; then
  sed -n "1,40p" /etc/resolv.pre-tailscale-backup.conf
else
  echo "missing"
fi
echo
echo "== /etc/exports (stale easystore line) =="
grep -n "^/mnt/easystore/backups" /etc/exports 2>/dev/null || echo "none"
echo
'

set +e
probe_out="$(ssh "${ssh_opts[@]}" -p "$pve_port" "${pve_user}@${pve_host}" "bash -lc $(printf "%q" "$remote_readonly")" 2>&1)"
probe_rc=$?
set -e
if [[ "$probe_rc" -ne 0 ]]; then
  echo "$probe_out"
  fail "unable to reach pve via ssh target"
fi
echo "$probe_out"

if [[ "$EXECUTE" -ne 1 ]]; then
  echo "DRY-RUN: no changes applied."
  exit 0
fi

echo "== APPLY =="

remote_apply='
set -euo pipefail

echo "[1/3] tailscale: disable accept-routes (RouteAll=false)"
tailscale set --accept-routes=false >/dev/null 2>&1 || true

echo "[2/3] tailscale DNS upstream: update /etc/resolv.pre-tailscale-backup.conf"
if [[ -f /etc/resolv.pre-tailscale-backup.conf ]]; then
  cp /etc/resolv.pre-tailscale-backup.conf "/etc/resolv.pre-tailscale-backup.conf.bak.$(date +%Y%m%d%H%M%S)"
fi
cat > /etc/resolv.pre-tailscale-backup.conf <<EOF
search mintprints
nameserver 192.168.1.204
nameserver 1.1.1.1
EOF

echo "[3/3] nfs exports: prune missing /mnt/easystore/backups export"
if grep -q "^/mnt/easystore/backups" /etc/exports 2>/dev/null; then
  cp /etc/exports "/etc/exports.bak.$(date +%Y%m%d%H%M%S)"
  tmp="$(mktemp /tmp/exports.XXXXXX)"
  grep -v "^/mnt/easystore/backups" /etc/exports > "$tmp"
  mv "$tmp" /etc/exports
  exportfs -ra >/dev/null 2>&1 || true
fi

echo
echo "== POSTCHECKS =="
echo "-- tailscale prefs --"
tailscale debug prefs | python3 -c "import json,sys; j=json.load(sys.stdin); print(f\"RouteAll={j.get('RouteAll')} CorpDNS={j.get('CorpDNS')} AdvertiseRoutes={j.get('AdvertiseRoutes')}\")" 2>/dev/null || true
echo
echo "-- tailscale dns status (system) --"
tailscale dns status 2>/dev/null | sed -n "1,140p" || true
echo
echo "-- tailscale debug resolve google.com --"
tailscale debug resolve google.com 2>/dev/null || true
echo
echo "-- ip route table 52 (192.168.*) --"
ip route show table 52 2>/dev/null | egrep "^192\\.168\\." || true
echo
echo "-- exportfs -v (easystore should be absent) --"
exportfs -v 2>/dev/null | sed -n "1,220p" || true
'

set +e
apply_out="$(ssh "${ssh_opts[@]}" -p "$pve_port" "${pve_user}@${pve_host}" "bash -lc $(printf "%q" "$remote_apply")" 2>&1)"
apply_rc=$?
set -e
if [[ "$apply_rc" -ne 0 ]]; then
  echo "$apply_out"
  fail "apply failed"
fi
echo "$apply_out"

echo "DONE"
exit 0

