#!/usr/bin/env bash
# network-oob-guard-status - Ensure shop LAN is reachable *without* relying on pve
#
# Read-only guard intended to run on the operator machine (this spine runtime).
# It checks:
#   1) A Tailscale peer other than pve is advertising routes covering the shop LAN
#   2) Core LAN-only devices (iDRAC/switch/NVR) are reachable from here (TCP probes)
#
# This is a safety gate for unattended maintenance: if pve is powered off and it
# was the only subnet router, you would strand yourself from iDRAC.
#
# Usage:
#   network-oob-guard-status
#   network-oob-guard-status --subnet 192.168.1.0/24
#   network-oob-guard-status --allow-pve-only-router   # bypass "non-pve router" requirement
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"

if [[ ! -f "$SSH_BINDING" ]]; then
  echo "STOP (2): missing binding file: $SSH_BINDING"
  exit 2
fi
if ! command -v yq >/dev/null 2>&1; then
  echo "STOP (2): yq is required but not found"
  echo "Install: brew install yq"
  exit 2
fi
if ! command -v tailscale >/dev/null 2>&1; then
  echo "STOP (2): tailscale CLI required but not found"
  exit 2
fi
if ! command -v python3 >/dev/null 2>&1; then
  echo "STOP (2): python3 required for JSON parsing but not found"
  exit 2
fi

SUBNET="192.168.1.0/24"
REQUIRE_NON_PVE_ROUTER=1

while [[ $# -gt 0 ]]; do
  case "$1" in
    --subnet)
      SUBNET="${2:-}"
      [[ -n "$SUBNET" ]] || { echo "STOP (2): --subnet requires a value"; exit 2; }
      shift 2
      ;;
    --allow-pve-only-router)
      REQUIRE_NON_PVE_ROUTER=0
      shift
      ;;
    -h|--help)
      sed -n '1,40p' "$0" | sed 's/^# //'
      exit 0
      ;;
    *)
      echo "STOP (2): unknown arg: $1"
      exit 2
      ;;
  esac
done

pve_ts_ip="$(yq -r '.ssh.targets[] | select(.id=="pve") | .host' "$SSH_BINDING" 2>/dev/null || true)"
[[ -n "${pve_ts_ip:-}" && "${pve_ts_ip:-}" != "null" ]] || pve_ts_ip=""

echo "network.oob.guard.status"
echo "binding: $SSH_BINDING"
echo "subnet: $SUBNET"
echo "require_non_pve_router: $( [[ "$REQUIRE_NON_PVE_ROUTER" -eq 1 ]] && echo true || echo false )"
echo "pve_ts_ip: ${pve_ts_ip:-unknown}"
echo

ts_json="$(tailscale status --json 2>/dev/null || true)"
if [[ -z "$ts_json" ]]; then
  echo "status: FAIL (tailscale status --json returned empty output)"
  exit 1
fi

routers_report="$(python3 -c 'import json,sys
subnet=sys.argv[1]
pve_ip=sys.argv[2] if len(sys.argv)>2 else ""
data=json.load(sys.stdin)

def covers(a:str)->bool:
  if a==subnet:
    return True
  if subnet.endswith("/24") and a.startswith(subnet.split("/")[0].rsplit(".",1)[0]+"."):
    return True
  return False

peers=[]
pm=data.get("Peer",{}) or {}
for _k,p in pm.items():
  allowed=p.get("AllowedIPs") or []
  if any(covers(x) for x in allowed):
    peers.append({
      "dns": (p.get("DNSName","") or "").rstrip("."),
      "host": p.get("HostName","") or "",
      "ips": p.get("TailscaleIPs") or [],
      "online": bool(p.get("Online", False)),
      "allowed": allowed,
    })

def is_pve(peer)->bool:
  if not pve_ip:
    name=(peer.get("host","") or "")+" "+(peer.get("dns","") or "")
    return "pve" in name.lower()
  return pve_ip in (peer.get("ips") or [])

non_pve=[p for p in peers if not is_pve(p)]
pve_only=[p for p in peers if is_pve(p)]

print(json.dumps({
  "subnet": subnet,
  "routers_total": len(peers),
  "routers_non_pve": len(non_pve),
  "routers_pve": len(pve_only),
  "routers": peers,
}))' "$SUBNET" "$pve_ts_ip" <<<"$ts_json")"

if [[ -z "$routers_report" ]]; then
  echo "status: FAIL (unable to parse tailscale status JSON)"
  exit 1
fi

routers_total="$(python3 -c 'import json,sys; print(json.load(sys.stdin)["routers_total"])' <<<"$routers_report")"
routers_non_pve="$(python3 -c 'import json,sys; print(json.load(sys.stdin)["routers_non_pve"])' <<<"$routers_report")"

echo "tailscale.subnet_routers"
echo "- routers_total: $routers_total"
echo "- routers_non_pve: $routers_non_pve"
python3 -c 'import json,sys
data=json.load(sys.stdin)
for p in data.get("routers", []):
  dns=p.get("dns") or "unknown"
  host=p.get("host") or "unknown"
  ips=",".join(p.get("ips") or [])
  online="online" if p.get("online") else "offline"
  print(f"- {dns} ({host}) ips=[{ips}] {online}")' <<<"$routers_report"
echo

if [[ "$routers_total" -eq 0 ]]; then
  echo "status: FAIL (no subnet router advertises coverage for $SUBNET)"
  exit 1
fi
if [[ "$REQUIRE_NON_PVE_ROUTER" -eq 1 && "$routers_non_pve" -lt 1 ]]; then
  echo "status: FAIL (only pve appears to advertise $SUBNET; powering off pve would strand OOB access)"
  exit 1
fi

echo "lan_only.probes"

probe_tcp() {
  local host="$1"
  local port="$2"
  if command -v nc >/dev/null 2>&1; then
    nc -z -w 2 "$host" "$port" >/dev/null 2>&1
    return $?
  fi
  if command -v timeout >/dev/null 2>&1; then
    timeout 2 bash -c "cat < /dev/null > /dev/tcp/$host/$port" >/dev/null 2>&1
    return $?
  fi
  bash -c "cat < /dev/null > /dev/tcp/$host/$port" >/dev/null 2>&1
}

fail=0
lan_ids=(idrac-shop switch-shop nvr-shop)
for id in "${lan_ids[@]}"; do
  ip="$(yq -r ".ssh.targets[] | select(.id==\"$id\") | .host" "$SSH_BINDING" 2>/dev/null || true)"
  if [[ -z "${ip:-}" || "${ip:-}" == "null" ]]; then
    echo "- id: $id -> FAIL reason=missing_ip_binding"
    fail=1
    continue
  fi

  if [[ "$(uname -s)" == "Darwin" ]]; then
    gw="$(route -n get "$ip" 2>/dev/null | awk '/gateway:/{print $2}' | head -1 || true)"
    iface="$(route -n get "$ip" 2>/dev/null | awk '/interface:/{print $2}' | head -1 || true)"
    [[ -n "$gw" || -n "$iface" ]] && echo "- id: $id ip: $ip route: gw=${gw:-?} iface=${iface:-?}"
  fi

  ok=0
  case "$id" in
    idrac-shop)
      if probe_tcp "$ip" 443; then ok=1; fi
      ;;
    switch-shop)
      if probe_tcp "$ip" 22 || probe_tcp "$ip" 443 || probe_tcp "$ip" 80; then ok=1; fi
      ;;
    nvr-shop)
      if probe_tcp "$ip" 443 || probe_tcp "$ip" 80; then ok=1; fi
      ;;
    *)
      if probe_tcp "$ip" 443 || probe_tcp "$ip" 22 || probe_tcp "$ip" 80; then ok=1; fi
      ;;
  esac

  if [[ "$ok" -eq 1 ]]; then
    echo "- id: $id ip: $ip -> OK"
  else
    echo "- id: $id ip: $ip -> FAIL reason=tcp_probe_failed"
    fail=1
  fi
done

echo
if [[ "$fail" -eq 1 ]]; then
  echo "status: FAIL (OOB guard not satisfied)"
  exit 1
fi

echo "status: OK (safe to proceed; OOB path exists independent of pve)"
exit 0
