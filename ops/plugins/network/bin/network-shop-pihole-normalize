#!/usr/bin/env bash
set -euo pipefail

# network.shop.pihole.normalize
# Normalize shop Pi-hole stack/runtime configuration on infra-core from staged SSOT.

SPINE_ROOT="${SPINE_ROOT:-$HOME/code/agentic-spine}"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
STAGED_COMPOSE="$SPINE_ROOT/ops/staged/pihole/docker-compose.yml"
REMOTE_COMPOSE="/opt/stacks/pihole/docker-compose.yml"

EXECUTE=0
UPSTREAM_PRIMARY="1.1.1.1"
UPSTREAM_SECONDARY="1.0.0.1"

usage() {
  cat <<'EOF'
network-shop-pihole-normalize

Usage:
  network-shop-pihole-normalize [--execute] [--upstream-primary <IPv4>] [--upstream-secondary <IPv4>]

Behavior:
  - Shows staged-vs-live compose key lines and current Pi-hole runtime DNS config.
  - Dry-run by default.
  - With --execute:
    1) syncs staged compose to infra-core:/opt/stacks/pihole/docker-compose.yml
    2) runs docker compose up -d for pihole stack
    3) enforces runtime FTL DNS policy (upstreams, DNSSEC, listening mode)

Examples:
  network-shop-pihole-normalize
  network-shop-pihole-normalize --execute
  network-shop-pihole-normalize --execute --upstream-primary 9.9.9.9 --upstream-secondary 149.112.112.112
EOF
}

is_ipv4() {
  local ip="$1"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  local IFS=.
  local -a oct
  read -r -a oct <<< "$ip"
  for n in "${oct[@]}"; do
    [[ "$n" =~ ^[0-9]+$ ]] || return 1
    (( n >= 0 && n <= 255 )) || return 1
  done
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --execute)
      EXECUTE=1
      shift
      ;;
    --upstream-primary)
      UPSTREAM_PRIMARY="${2:-}"
      shift 2
      ;;
    --upstream-secondary)
      UPSTREAM_SECONDARY="${2:-}"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "FAIL: unknown argument: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

is_ipv4 "$UPSTREAM_PRIMARY" || { echo "FAIL: invalid --upstream-primary: $UPSTREAM_PRIMARY" >&2; exit 2; }
is_ipv4 "$UPSTREAM_SECONDARY" || { echo "FAIL: invalid --upstream-secondary: $UPSTREAM_SECONDARY" >&2; exit 2; }

command -v yq >/dev/null 2>&1 || { echo "STOP (2): missing dependency: yq" >&2; exit 2; }
command -v ssh >/dev/null 2>&1 || { echo "STOP (2): missing dependency: ssh" >&2; exit 2; }
[[ -f "$SSH_BINDING" ]] || { echo "STOP (2): missing binding: $SSH_BINDING" >&2; exit 2; }
[[ -f "$STAGED_COMPOSE" ]] || { echo "STOP (2): missing staged compose: $STAGED_COMPOSE" >&2; exit 2; }

INFRA_HOST="$(yq -r '.ssh.targets[] | select(.id == "infra-core") | .host' "$SSH_BINDING")"
INFRA_USER="$(yq -r '.ssh.targets[] | select(.id == "infra-core") | .user // "ubuntu"' "$SSH_BINDING")"
[[ -n "$INFRA_HOST" && "$INFRA_HOST" != "null" ]] || { echo "STOP (2): infra-core host missing in ssh.targets" >&2; exit 2; }

SSH_OPTS=(
  -o ConnectTimeout=10
  -o StrictHostKeyChecking=no
  -o UserKnownHostsFile=/dev/null
  -o BatchMode=yes
  -o LogLevel=ERROR
)

show_staged() {
  echo "-- staged compose key lines --"
  rg -n "FTLCONF_|PIHOLE_DNS_|DNSMASQ_LISTENING|DNSSEC|QUERY_LOGGING|WEBPASSWORD" "$STAGED_COMPOSE" || true
}

show_remote() {
  echo "-- live compose key lines (infra-core) --"
  ssh "${SSH_OPTS[@]}" "${INFRA_USER}@${INFRA_HOST}" "sudo sh -lc 'grep -nE \"FTLCONF_|PIHOLE_DNS_|DNSMASQ_LISTENING|DNSSEC|QUERY_LOGGING|WEBPASSWORD\" \"$REMOTE_COMPOSE\" || true'"
}

show_runtime() {
  echo "-- pihole runtime config (infra-core) --"
  ssh "${SSH_OPTS[@]}" "${INFRA_USER}@${INFRA_HOST}" "sudo bash -s" <<'EOF'
set -euo pipefail
C="$(docker ps --format "{{.Names}}" | grep pihole | head -n1)"
if [[ -z "$C" ]]; then
  echo "FAIL: no running pihole container found"
  exit 1
fi
echo "container=$C"
for key in dns.upstreams dns.dnssec dns.listeningMode webserver.port; do
  printf "%s=" "$key"
  docker exec "$C" pihole-FTL --config "$key" 2>/dev/null || echo "<unsupported>"
done
docker exec "$C" pihole status | sed -n '1,24p'
EOF
}

echo "network.shop.pihole.normalize"
echo "target: ${INFRA_USER}@${INFRA_HOST}"
echo "staged: $STAGED_COMPOSE"
echo "remote: $REMOTE_COMPOSE"
echo "upstreams: $UPSTREAM_PRIMARY,$UPSTREAM_SECONDARY"
echo

show_staged
echo
show_remote
echo
show_runtime
echo

if [[ "$EXECUTE" -ne 1 ]]; then
  echo "DRY-RUN: no changes applied. Re-run with --execute to mutate."
  exit 0
fi

echo "apply: syncing staged compose -> infra-core"
ssh "${SSH_OPTS[@]}" "${INFRA_USER}@${INFRA_HOST}" "sudo tee '$REMOTE_COMPOSE' >/dev/null" < "$STAGED_COMPOSE"

echo "apply: docker compose up -d (infra-core/pihole)"
ssh "${SSH_OPTS[@]}" "${INFRA_USER}@${INFRA_HOST}" "sudo sh -lc 'cd /opt/stacks/pihole && docker compose up -d'"

echo "apply: waiting for pihole FTL readiness"
ssh "${SSH_OPTS[@]}" "${INFRA_USER}@${INFRA_HOST}" "sudo bash -s" <<'EOF'
set -euo pipefail
C="$(docker ps --format "{{.Names}}" | grep pihole | head -n1)"
[[ -n "$C" ]] || { echo "FAIL: no pihole container after compose up"; exit 1; }
for _ in $(seq 1 30); do
  if docker exec "$C" pihole-FTL --config webserver.port >/dev/null 2>&1; then
    echo "ready: $C"
    exit 0
  fi
  sleep 2
done
echo "FAIL: pihole FTL did not become ready within timeout"
exit 1
EOF

echo "apply: verifying runtime FTL policy (env-backed/read-only keys)"
ssh "${SSH_OPTS[@]}" "${INFRA_USER}@${INFRA_HOST}" "sudo bash -s" <<EOF
set -euo pipefail
C="\$(docker ps --format "{{.Names}}" | grep pihole | head -n1)"
[[ -n "\$C" ]] || { echo "FAIL: no pihole container after compose up"; exit 1; }
UPSTREAMS_RAW="\$(docker exec "\$C" pihole-FTL --config dns.upstreams 2>/dev/null || true)"
DNSSEC_RAW="\$(docker exec "\$C" pihole-FTL --config dns.dnssec 2>/dev/null || true)"
LISTEN_RAW="\$(docker exec "\$C" pihole-FTL --config dns.listeningMode 2>/dev/null || true)"
PORT_RAW="\$(docker exec "\$C" pihole-FTL --config webserver.port 2>/dev/null || true)"

echo "container=\$C"
echo "dns.upstreams=\$UPSTREAMS_RAW"
echo "dns.dnssec=\$DNSSEC_RAW"
echo "dns.listeningMode=\$LISTEN_RAW"
echo "webserver.port=\$PORT_RAW"

echo "\$UPSTREAMS_RAW" | grep -Eq "(^|[^0-9])$UPSTREAM_PRIMARY([^0-9]|$)" || { echo "FAIL: primary upstream mismatch"; exit 1; }
echo "\$UPSTREAMS_RAW" | grep -Eq "(^|[^0-9])$UPSTREAM_SECONDARY([^0-9]|$)" || { echo "FAIL: secondary upstream mismatch"; exit 1; }
[[ "\$DNSSEC_RAW" == "true" ]] || { echo "FAIL: dns.dnssec is not true"; exit 1; }
[[ "\$LISTEN_RAW" == "ALL" ]] || { echo "FAIL: dns.listeningMode is not ALL"; exit 1; }
echo "\$PORT_RAW" | grep -q "8053" || { echo "FAIL: webserver.port missing 8053"; exit 1; }

docker exec "\$C" pihole status | sed -n '1,24p'
docker exec "\$C" sh -lc "nslookup example.com 127.0.0.1 | sed -n '1,14p'"
EOF

echo "DONE: shop pihole normalization applied."
