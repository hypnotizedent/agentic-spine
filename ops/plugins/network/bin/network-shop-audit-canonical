#!/usr/bin/env bash
# network-shop-audit-canonical — Canonical shop network audit
#
# Combines:
#  1. Local SSOT parity (delegates to network-shop-audit-status)
#  2. Live truth validation via pve (ping, ARP/neigh, TCP probes)
#  3. Doc IP trace (shop-scoped, detects stale/unowned references)
#  4. Optional UniFi client enrichment (MAC→IP mapping for moved devices)
#
# Exit:
#  0  PASS (no drift)
#  1  FAIL (drift findings)
#  2  STOP (missing deps, pve unreachable)
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"

SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
SSOT_DEVICE="$SPINE_ROOT/docs/governance/DEVICE_IDENTITY_SSOT.md"
GOV_DIR="$SPINE_ROOT/docs/governance"
UNIFI_AGENT="$SPINE_ROOT/ops/tools/unifi-agent.sh"
PARITY_SCRIPT="$SCRIPT_DIR/network-shop-audit-status"

stop(){ echo "STOP (2): $*" >&2; exit 2; }

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v python3 >/dev/null 2>&1 || stop "missing dependency: python3"
command -v ssh >/dev/null 2>&1 || stop "missing dependency: ssh"
[[ -f "$SSH_BINDING" ]] || stop "missing binding: $SSH_BINDING"
[[ -f "$SSOT_DEVICE" ]] || stop "missing SSOT: $SSOT_DEVICE"
[[ -f "$PARITY_SCRIPT" ]] || stop "missing parity script: $PARITY_SCRIPT"

tmpdir="$(mktemp -d /tmp/network-shop-audit-canonical.XXXXXX)"
cleanup(){ rm -rf "$tmpdir" 2>/dev/null || true; }
trap cleanup EXIT INT TERM

findings=0

echo "network.shop.audit.canonical"
echo "binding: $SSH_BINDING"
echo "ssot-device: $SSOT_DEVICE"
echo

# ══════════════════════════════════════════════════════════════════════════
# STEP 1: Local parity (delegate to existing audit)
# ══════════════════════════════════════════════════════════════════════════

echo "== local.parity =="
set +e
SPINE_ROOT="$SPINE_ROOT" bash "$PARITY_SCRIPT" > "$tmpdir/parity.txt" 2>&1
parity_rc=$?
set -e

cat "$tmpdir/parity.txt"
echo

if [[ "$parity_rc" -eq 2 ]]; then
  echo "STOP: local parity audit returned STOP"
  exit 2
elif [[ "$parity_rc" -ne 0 ]]; then
  parity_drifts="$(grep -c 'DRIFT:' "$tmpdir/parity.txt" 2>/dev/null || echo 0)"
  findings=$((findings + parity_drifts))
fi

# ══════════════════════════════════════════════════════════════════════════
# STEP 2: Load canonical expected shop map from DEVICE_IDENTITY_SSOT.md
# ══════════════════════════════════════════════════════════════════════════

# Parse "LAN-only endpoints (Shop)" section
canonical_map="$tmpdir/canonical_map.tsv"
python3 - "$SSOT_DEVICE" > "$canonical_map" <<'PY'
import re, sys

path = sys.argv[1]
lines = open(path, 'r', encoding='utf-8', errors='ignore').readlines()

devices = {}

# Parse LAN-only endpoints (Shop) — format: "- `id` — IP"
in_lan_section = False
for line in lines:
    if 'LAN-only endpoints (Shop)' in line:
        in_lan_section = True
        continue
    if in_lan_section:
        if line.startswith('---') or (line.startswith('#') and 'LAN-only' not in line):
            in_lan_section = False
            continue
        m = re.match(r'^-\s+`([a-z0-9-]+)`\s+.*?(\d+\.\d+\.\d+\.\d+)', line)
        if m:
            devices[m.group(1)] = m.group(2)

# Parse "Shop VM LAN IPs" table
in_vm_section = False
for line in lines:
    if 'Shop VM LAN IPs' in line:
        in_vm_section = True
        continue
    if in_vm_section:
        if line.startswith('---') or (line.startswith('#') and 'VM LAN' not in line):
            in_vm_section = False
            continue
        if not line.startswith('|'):
            continue
        parts = [p.strip() for p in line.strip().split('|')[1:-1]]
        if len(parts) < 4:
            continue
        name_col = parts[1].strip('`').strip()
        ip_col = parts[2].strip()
        if not re.match(r'^\d+\.\d+\.\d+\.\d+$', ip_col):
            continue
        if name_col and name_col not in ('Canonical Name', '----'):
            devices[name_col] = ip_col

for dev, ip in sorted(devices.items()):
    print(f"{dev}\t{ip}")
PY

echo "== canonical.map =="
while IFS=$'\t' read -r dev ip; do
  echo "  $dev -> $ip"
done < "$canonical_map"
echo

# Expected MACs for LAN-only devices (identity lock)
expected_macs="$tmpdir/expected_macs.tsv"
yq -r '.ssh.targets[] | select(.access_method == "lan_only") | [.id, (.mac // "")] | @tsv' "$SSH_BINDING" \
  | awk -F'\t' 'NF>=2 && $2!="" && $2!="null" {print $1 "\t" tolower($2)}' \
  > "$expected_macs"

# ══════════════════════════════════════════════════════════════════════════
# STEP 3: Live truth validation via pve
# ══════════════════════════════════════════════════════════════════════════

echo "== live.truth =="

# Resolve pve SSH
PVE_HOST="$(yq -r '.ssh.targets[] | select(.id == "pve") | .host' "$SSH_BINDING")"
PVE_USER="$(yq -r '.ssh.targets[] | select(.id == "pve") | .user // "root"' "$SSH_BINDING")"
[[ -n "$PVE_HOST" && "$PVE_HOST" != "null" ]] || stop "pve not found in ssh.targets.yaml"

DEF_STRICT="$(yq -r '.ssh.defaults.strict_host_key_checking // "no"' "$SSH_BINDING")"
DEF_KNOWN_HOSTS="$(yq -r '.ssh.defaults.user_known_hosts_file // "/dev/null"' "$SSH_BINDING")"
DEF_TO="$(yq -r '.ssh.defaults.connect_timeout_sec // 5' "$SSH_BINDING")"

ssh_opts=(
  -o "ConnectTimeout=${DEF_TO}"
  -o "StrictHostKeyChecking=${DEF_STRICT}"
  -o "UserKnownHostsFile=${DEF_KNOWN_HOSTS}"
  -o "BatchMode=yes"
  -o "LogLevel=ERROR"
)

# Test pve reachability
if ! ssh "${ssh_opts[@]}" "${PVE_USER}@${PVE_HOST}" "echo ok" >/dev/null 2>&1; then
  echo "STOP (2): cannot reach pve at ${PVE_USER}@${PVE_HOST}"
  echo "hint: ensure Tailscale is connected and pve is online"
  exit 2
fi

# Device type to TCP ports mapping
get_tcp_ports() {
  local dev="$1"
  case "$dev" in
    nvr-shop)      echo "80 8000 554" ;;
    idrac-shop)    echo "443" ;;
    switch-shop)   echo "22 80 443" ;;
    ap-shop)       echo "22 80 443" ;;
    udr-shop)      echo "443" ;;
    pve)           echo "22 8006" ;;
    *)             echo "22" ;;
  esac
}

# Build a single remote script that probes all devices at once (one SSH session)
probe_script="$tmpdir/probe.sh"
cat > "$probe_script" <<'PROBE_HEADER'
#!/bin/bash
set -e
PROBE_HEADER

while IFS=$'\t' read -r dev ip; do
  ports="$(get_tcp_ports "$dev")"
  cat >> "$probe_script" <<PROBE_DEVICE
echo "DEVICE:${dev}"
echo "IP:${ip}"
if ping -c1 -W2 ${ip} >/dev/null 2>&1; then
  echo "PING:ok"
else
  echo "PING:fail"
fi
neigh_line="\$(ip neigh show ${ip} 2>/dev/null | head -1)"
if [[ -n "\$neigh_line" ]]; then
  mac="\$(echo "\$neigh_line" | grep -oP '([0-9a-f]{2}:){5}[0-9a-f]{2}' || echo 'unknown')"
  echo "MAC:\$mac"
else
  echo "MAC:unknown"
fi
PROBE_DEVICE

  for port in $ports; do
    cat >> "$probe_script" <<PROBE_TCP
if timeout 2 bash -c "cat < /dev/null > /dev/tcp/${ip}/${port}" 2>/dev/null; then
  echo "TCP:${port}:open"
else
  echo "TCP:${port}:closed"
fi
PROBE_TCP
  done

  echo 'echo "---"' >> "$probe_script"
done < "$canonical_map"

# Execute single SSH session with all probes
probe_output="$tmpdir/probe_output.txt"
ssh "${ssh_opts[@]}" "${PVE_USER}@${PVE_HOST}" "bash -s" < "$probe_script" > "$probe_output" 2>/dev/null || {
  echo "WARN: probe script had errors (partial results may follow)"
}

# Parse probe output and report
live_drifts="$tmpdir/live_drifts.txt"
> "$live_drifts"

current_dev=""
current_ip=""
current_ping=""
current_mac=""
tcp_results=""

report_device() {
  if [[ -z "$current_dev" ]]; then return; fi

  local status_line="  $current_dev ($current_ip): ping=$current_ping mac=$current_mac"
  if [[ -n "$tcp_results" ]]; then
    status_line="$status_line $tcp_results"
  fi
  echo "$status_line"

  # Check for drift
  if [[ "$current_ping" == "fail" ]]; then
    echo "$current_dev\texpected=$current_ip\tactual=UNREACHABLE" >> "$live_drifts"
    return
  fi

  # MAC identity lock for LAN-only devices
  expected_mac="$(awk -F'\t' -v d="$current_dev" '$1==d {print $2; exit}' "$expected_macs" 2>/dev/null || true)"
  if [[ -n "${expected_mac:-}" ]]; then
    obs_mac="$(echo "${current_mac:-}" | tr 'A-F' 'a-f')"
    if [[ -z "${obs_mac:-}" || "$obs_mac" == "unknown" ]]; then
      echo "$current_dev\texpected=$current_ip\tactual=MAC_UNKNOWN expected_mac=$expected_mac" >> "$live_drifts"
    elif [[ "$obs_mac" != "$expected_mac" ]]; then
      echo "$current_dev\texpected=$current_ip\tactual=MAC_MISMATCH observed=$obs_mac expected_mac=$expected_mac" >> "$live_drifts"
    fi
  fi
}

while IFS= read -r line; do
  case "$line" in
    DEVICE:*)
      report_device
      current_dev="${line#DEVICE:}"
      current_ip=""
      current_ping=""
      current_mac=""
      tcp_results=""
      ;;
    IP:*)       current_ip="${line#IP:}" ;;
    PING:*)     current_ping="${line#PING:}" ;;
    MAC:*)      current_mac="${line#MAC:}" ;;
    TCP:*)
      port_info="${line#TCP:}"
      tcp_results="$tcp_results tcp:$port_info"
      ;;
    ---) ;;
  esac
done < "$probe_output"
report_device  # flush last device

echo

# ══════════════════════════════════════════════════════════════════════════
# STEP 3b: Optional UniFi enrichment (best-effort)
# ══════════════════════════════════════════════════════════════════════════

unifi_clients="$tmpdir/unifi_clients.json"
unifi_available=0

if [[ -x "$UNIFI_AGENT" ]]; then
  echo "== unifi.enrichment =="
  set +e
  "$UNIFI_AGENT" clients --json > "$unifi_clients" 2>/dev/null
  unifi_rc=$?
  set -e

  if [[ "$unifi_rc" -eq 0 && -s "$unifi_clients" ]]; then
    unifi_available=1
    client_count="$(jq 'length' "$unifi_clients" 2>/dev/null || echo 0)"
    echo "  clients: $client_count devices"

    # For any unreachable device, try to find it by MAC in UniFi
    if [[ -s "$live_drifts" ]]; then
      while IFS=$'\t' read -r dev expected rest; do
        known_mac="$(awk -F'\t' -v d="$dev" '$1==d {print $2; exit}' "$expected_macs" 2>/dev/null || true)"

        if [[ -n "$known_mac" ]]; then
          found_ip="$(jq -r --arg mac "$known_mac" '.[] | select(.mac == $mac) | .ip // empty' "$unifi_clients" 2>/dev/null || true)"
          if [[ -n "$found_ip" ]]; then
            echo "  $dev: expected at ${expected#expected=} but found at $found_ip (by MAC $known_mac)"
            # Update drift message
            sed -i.bak "s|^${dev}.*|${dev}\t${expected}\tactual=UNREACHABLE (found at ${found_ip} by MAC ${known_mac})|" "$live_drifts" 2>/dev/null || true
          fi
        fi
      done < "$live_drifts"
    fi
  else
    echo "  skip (UniFi creds not available or query failed — audit continues with pve probes only)"
  fi
  echo
fi

# Count live truth drifts
if [[ -s "$live_drifts" ]]; then
  live_drift_count="$(wc -l < "$live_drifts" | tr -d ' ')"
  findings=$((findings + live_drift_count))

  echo "== live.drift =="
  while IFS=$'\t' read -r dev expected actual; do
    echo "  DRIFT: $dev $expected $actual"
  done < "$live_drifts"
  echo
fi

# ══════════════════════════════════════════════════════════════════════════
# STEP 4: Doc IP trace (shop-scoped)
# ══════════════════════════════════════════════════════════════════════════

echo "== doc.references =="

# Build canonical IP set from our map
canonical_ips="$tmpdir/canonical_ips.txt"
awk -F'\t' '{print $2}' "$canonical_map" | sort -u > "$canonical_ips"

# Also include well-known shop IPs that aren't device-specific
cat >> "$canonical_ips" <<'KNOWN'
192.168.1.0
192.168.1.100
192.168.1.199
192.168.1.255
KNOWN
sort -u -o "$canonical_ips" "$canonical_ips"

doc_drifts="$tmpdir/doc_drifts.txt"
> "$doc_drifts"

python3 - "$GOV_DIR" "$canonical_ips" "$doc_drifts" <<'PY'
import os, re, sys

gov_dir=sys.argv[1]
canonical_path=sys.argv[2]
drifts_out=sys.argv[3]

canonical=set()
for line in open(canonical_path,'r',encoding='utf-8',errors='ignore'):
    v=line.strip()
    if v:
        canonical.add(v)

ip_re=re.compile(r"\b192\.168\.\d{1,3}\.\d{1,3}\b")

per_file_refs={}
per_file_drifts={}
drifts=[]

for fname in sorted(os.listdir(gov_dir)):
    if not fname.endswith(".md"):
        continue
    path=os.path.join(gov_dir,fname)
    try:
        lines=open(path,'r',encoding='utf-8',errors='ignore').read().splitlines()
    except OSError:
        continue

    refs=0
    drift=0
    for i,line in enumerate(lines, start=1):
        for ip in ip_re.findall(line):
            refs += 1

            if ip in canonical:
                continue
            if ip.startswith("192.168.254."):
                continue
            if ip.startswith("192.168.12."):
                drifts.append((f"{fname}:{i}","stale_subnet_reference",ip))
                drift += 1
                continue
            if ip.startswith("192.168.1."):
                drifts.append((f"{fname}:{i}","unowned_ip_reference",ip))
                drift += 1
                continue

    if refs > 0:
        per_file_refs[fname]=refs
        per_file_drifts[fname]=drift

for fname in sorted(per_file_refs.keys()):
    refs=per_file_refs[fname]
    drift=per_file_drifts.get(fname,0)
    if drift > 0:
        print(f"  {fname}: {refs} references ({drift} DRIFT)")
    else:
        print(f"  {fname}: {refs} references (all canonical)")

with open(drifts_out,'w',encoding='utf-8') as f:
    for loc,kind,ip in drifts:
        f.write(f"{loc}\t{kind}\t{ip}\n")
PY

echo

if [[ -s "$doc_drifts" ]]; then
  doc_drift_count="$(wc -l < "$doc_drifts" | tr -d ' ')"
  findings=$((findings + doc_drift_count))

  echo "== doc.drift =="
  while IFS=$'\t' read -r location kind ip; do
    echo "  DRIFT: $location $kind $ip"
  done < "$doc_drifts"
  echo
fi

# ══════════════════════════════════════════════════════════════════════════
# SUMMARY
# ══════════════════════════════════════════════════════════════════════════

echo "DRIFT FINDINGS: $findings"
echo

if [[ "$findings" -eq 0 ]]; then
  echo "result: PASS"
  exit 0
fi

echo "result: FAIL ($findings drift finding(s))"
exit 1
