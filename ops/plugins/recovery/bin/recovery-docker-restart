#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"
BINDING="$SPINE_ROOT/ops/bindings/docker.compose.targets.yaml"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"

usage() {
  cat <<'USAGE'
recovery-docker-restart

Usage:
  recovery-docker-restart --target <target> --stack <stack> [--service <svc>]... [--probe-url <url>] [--dry-run]
USAGE
}

stop() {
  echo "recovery.docker.restart FAIL: $*" >&2
  exit 1
}

TARGET=""
STACK=""
PROBE_URL=""
DRY_RUN=0
declare -a SERVICES=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --) shift ;;
    --target) TARGET="${2:-}"; shift 2 ;;
    --stack) STACK="${2:-}"; shift 2 ;;
    --service) SERVICES+=("${2:-}"); shift 2 ;;
    --probe-url) PROBE_URL="${2:-}"; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) stop "unknown argument: $1" ;;
  esac
done

[[ -n "$TARGET" ]] || stop "--target is required"
[[ -n "$STACK" ]] || stop "--stack is required"

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v ssh >/dev/null 2>&1 || stop "missing dependency: ssh"
[[ -f "$BINDING" ]] || stop "missing binding: $BINDING"
[[ -f "$SSH_BINDING" ]] || stop "missing binding: $SSH_BINDING"

ssh_target_id="$(yq -r ".targets.\"$TARGET\".ssh_target // \"\"" "$BINDING")"
[[ -n "$ssh_target_id" && "$ssh_target_id" != "null" ]] || stop "unknown target: $TARGET"
stack_path="$(yq -r ".targets.\"$TARGET\".stacks[] | select(.name == \"$STACK\") | .path" "$BINDING" 2>/dev/null | head -n1 || true)"
[[ -n "$stack_path" && "$stack_path" != "null" ]] || stop "unknown stack '$STACK' for target '$TARGET'"

DEF_USER="$(yq -r '.ssh.defaults.user // "root"' "$SSH_BINDING")"
DEF_PORT="$(yq -r '.ssh.defaults.port // 22' "$SSH_BINDING")"
DEF_TO="$(yq -r '.ssh.defaults.connect_timeout_sec // 5' "$SSH_BINDING")"
DEF_BATCH="$(yq -r '.ssh.defaults.batch_mode // true' "$SSH_BINDING")"
DEF_STRICT="$(yq -r '.ssh.defaults.strict_host_key_checking // "no"' "$SSH_BINDING")"
DEF_KNOWN_HOSTS="$(yq -r '.ssh.defaults.user_known_hosts_file // "/dev/null"' "$SSH_BINDING")"

ssh_host="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .host // \"\"" "$SSH_BINDING" | head -n1)"
ssh_user="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .user // \"\"" "$SSH_BINDING" | head -n1)"
ssh_port="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .port // $DEF_PORT" "$SSH_BINDING" | head -n1)"
ssh_to="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .connect_timeout_sec // $DEF_TO" "$SSH_BINDING" | head -n1)"

[[ -n "$ssh_host" && "$ssh_host" != "null" ]] || stop "ssh target '$ssh_target_id' missing host"
[[ -n "$ssh_user" && "$ssh_user" != "null" ]] || ssh_user="$DEF_USER"
[[ -n "$ssh_port" && "$ssh_port" != "null" ]] || ssh_port="$DEF_PORT"
[[ -n "$ssh_to" && "$ssh_to" != "null" ]] || ssh_to="$DEF_TO"

if [[ "$DRY_RUN" -eq 1 ]]; then
  echo "recovery.docker.restart"
  echo "target: $TARGET"
  echo "stack: $STACK"
  echo "ssh_target: $ssh_target_id"
  echo "stack_path: $stack_path"
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    echo "services: ${SERVICES[*]}"
  fi
  [[ -n "$PROBE_URL" ]] && echo "probe_url: $PROBE_URL"
  echo "result: dry-run"
  exit 0
fi

ssh_opts=(
  -o "ConnectTimeout=$ssh_to"
  -o "StrictHostKeyChecking=$DEF_STRICT"
  -o "UserKnownHostsFile=$DEF_KNOWN_HOSTS"
  -o "NumberOfPasswordPrompts=0"
  -o "LogLevel=ERROR"
)
if [[ "$DEF_BATCH" == "true" ]]; then
  ssh_opts+=( -o "BatchMode=yes" )
fi

remote_script='set -euo pipefail
PATHX="$1"; shift
SERVICES=("$@")

case "$PATHX" in
  "~/"*) PATHX="$HOME/${PATHX:2}" ;;
  "~") PATHX="$HOME" ;;
esac

[[ -d "$PATHX" ]] || { echo "missing stack dir: $PATHX" >&2; exit 2; }
cd "$PATHX"

FILE=""
[[ -f docker-compose.yml ]] && FILE="docker-compose.yml"
[[ -z "$FILE" && -f compose.yml ]] && FILE="compose.yml"
[[ -n "$FILE" ]] || { echo "compose file missing" >&2; exit 2; }

DOCKER_CMD=(docker)
if ! docker info >/dev/null 2>&1; then
  if command -v sudo >/dev/null 2>&1 && sudo -n docker info >/dev/null 2>&1; then
    DOCKER_CMD=(sudo -n docker)
  else
    echo "docker unavailable" >&2
    exit 1
  fi
fi

before_running="$(${DOCKER_CMD[@]} compose -f "$FILE" ps --status running --services | wc -l | tr -d " ")"
${DOCKER_CMD[@]} compose -f "$FILE" up -d "${SERVICES[@]}"
sleep 10
running_services="$(${DOCKER_CMD[@]} compose -f "$FILE" ps --status running --services || true)"
after_running="$(printf "%s\n" "$running_services" | sed '/^$/d' | wc -l | tr -d " ")"

if [[ "${#SERVICES[@]}" -gt 0 ]]; then
  for svc in "${SERVICES[@]}"; do
    printf "%s\n" "$running_services" | grep -Fxq "$svc" || { echo "service_not_running=$svc" >&2; exit 1; }
  done
fi

echo "before_running=$before_running"
echo "after_running=$after_running"'

service_args=""
for s in "${SERVICES[@]}"; do
  service_args+=" $(printf '%q' "$s")"
done

set +e
# shellcheck disable=SC2086
ssh "${ssh_opts[@]}" -p "$ssh_port" "${ssh_user}@${ssh_host}" \
  "bash -lc $(printf '%q' "$remote_script") -- $(printf '%q' "$stack_path")${service_args}"
remote_rc=$?
set -e
[[ "$remote_rc" -eq 0 ]] || stop "remote compose restart failed (rc=$remote_rc)"

if [[ -n "$PROBE_URL" ]]; then
  command -v curl >/dev/null 2>&1 || stop "missing dependency: curl (required for --probe-url)"
  if ! curl -fsS --max-time 10 "$PROBE_URL" >/dev/null 2>&1; then
    stop "post-restart probe failed: $PROBE_URL"
  fi
fi

echo "recovery.docker.restart"
echo "target: $TARGET"
echo "stack: $STACK"
if [[ "${#SERVICES[@]}" -gt 0 ]]; then
  echo "services: ${SERVICES[*]}"
fi
[[ -n "$PROBE_URL" ]] && echo "probe_url: $PROBE_URL"
echo "result: success"
