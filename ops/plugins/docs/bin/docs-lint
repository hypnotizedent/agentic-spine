#!/usr/bin/env bash
set -euo pipefail

# docs.lint — Enforce canonical doc hierarchy, metadata headers, README registration
# Safety: read-only (scans files, no modifications)

# Worktree-safe: lint the code tree this script lives in.
# Runtime roots (receipts/, mailroom/) remain anchored by SPINE_REPO elsewhere.
ROOT="${SPINE_CODE:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
DOCS="$ROOT/docs"

_need() { command -v "$1" >/dev/null 2>&1 || { echo "STOP: missing dependency: $1" >&2; exit 2; }; }
_need rg

if [[ ! -d "$DOCS" ]]; then
  echo "STOP: docs/ not found at $DOCS" >&2
  exit 2
fi

echo "docs.lint"
echo "root: $ROOT"
echo

ERRORS=0
WARNINGS=0

err()  { echo "ERROR: $*"; ERRORS=$((ERRORS+1)); }
warn() { echo "WARN:  $*"; WARNINGS=$((WARNINGS+1)); }

# ─────────────────────────────────────────────────────────────────────────
# CHECK 1: No loose files at docs/ root (except allowlist)
# ─────────────────────────────────────────────────────────────────────────
echo "--- Check 1: Loose files at docs/ root ---"
ALLOWED_ROOT="README.md OPERATOR_CHEAT_SHEET.md CONTRIBUTING.md .DS_Store"

for f in "$DOCS"/*; do
  [[ -d "$f" ]] && continue
  name="$(basename "$f")"
  if ! echo "$ALLOWED_ROOT" | grep -qw "$name"; then
    err "loose file at docs/ root: $name (move to appropriate subfolder)"
  fi
done
echo "  $(find "$DOCS" -maxdepth 1 -type f -not -name ".DS_Store" | wc -l | tr -d ' ') files at root (3 allowed)"

# ─────────────────────────────────────────────────────────────────────────
# CHECK 2: Known folders only
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 2: Folder allowlist ---"
# NOTE: `ops start ...` scaffolds per-scope session logs under `docs/sessions/`.
# These logs are explicitly non-canonical but are still part of the docs tree
# for discoverability (and optional RAG indexing).
ALLOWED_DIRS="core governance brain sessions legacy"

for d in "$DOCS"/*/; do
  name="$(basename "$d")"
  if ! echo "$ALLOWED_DIRS" | grep -qw "$name"; then
    err "unknown folder: docs/$name/ (not in allowlist)"
  fi
done
echo "  $(find "$DOCS" -maxdepth 1 -type d -not -path "$DOCS" | wc -l | tr -d ' ') subdirectories"

# ─────────────────────────────────────────────────────────────────────────
# CHECK 3: Metadata headers (status line in first 10 lines)
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 3: Metadata headers ---"
HAS_HEADER=0
MISSING_HEADER=0

for f in $(find "$DOCS" -name "*.md" \
  -not -path "*/legacy/*" \
  -not -path "*/sessions/*" \
  -not -path "*/_imported/*" \
  -not -path "*/_audits/*" \
  -not -path "*/_receipts_meta/*" \
  -not -name "README.md" \
  -not -name "CONTRIBUTING.md" \
  | sort); do

  # Check first 10 lines for status indicator
  if head -10 "$f" | grep -qiE '(^status:|^\*\*Status|> \*\*Status)'; then
    HAS_HEADER=$((HAS_HEADER+1))
  else
    rel="${f#$ROOT/}"
    warn "no metadata header: $rel"
    MISSING_HEADER=$((MISSING_HEADER+1))
  fi
done
echo "  $HAS_HEADER with header, $MISSING_HEADER missing"

# ─────────────────────────────────────────────────────────────────────────
# CHECK 4: README.md registration
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 4: README.md registration ---"
REGISTERED=0
UNREGISTERED=0

for f in $(find "$DOCS/core" "$DOCS/governance" -maxdepth 1 -name "*.md" -o -name "*.yaml" 2>/dev/null | sort); do
  name="$(basename "$f")"
  if grep -q "$name" "$DOCS/README.md" 2>/dev/null; then
    REGISTERED=$((REGISTERED+1))
  else
    rel="${f#$ROOT/}"
    warn "not in README.md: $rel"
    UNREGISTERED=$((UNREGISTERED+1))
  fi
done
echo "  $REGISTERED registered, $UNREGISTERED unregistered"

# ─────────────────────────────────────────────────────────────────────────
# CHECK 5: Legacy isolation (no runtime links to docs/legacy/)
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 5: Legacy isolation ---"
# Only scan runtime code surfaces. Do not scan mailroom output/state/logs:
# generated artifacts (outbox results, receipts, etc.) may legitimately mention
# docs/legacy paths for reference and should not fail this lint check.
LEGACY_REFS="$(rg -n "docs/legacy/" "$ROOT/ops/" "$ROOT/surfaces/" "$ROOT/agents/" "$ROOT/bin/" 2>/dev/null \
  | grep -v "quarantine\|FORBIDDEN\|FORBID\|DENY\|legacy.*reference\|legacy.*archive\|_imports\|docs-lint" \
  | grep -v "/ops/plugins/audit/" \
  || true)"

if [[ -n "$LEGACY_REFS" ]]; then
  err "runtime code references docs/legacy/:"
  echo "$LEGACY_REFS" | head -10
else
  echo "  No runtime references to docs/legacy/ (clean)"
fi

# ─────────────────────────────────────────────────────────────────────────
# CHECK 6: No forbidden patterns outside quarantine
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 6: Forbidden patterns ---"
# Prevent doc-driven regressions back to the deprecated legacy runtime root.
# Allow mentions in explicit quarantine/policy zones only.
LEGACY_REPO_NAME="$(yq -r '.terms[]? | select(.id == "legacy-repo-name") | .term // ""' "$ROOT/ops/bindings/deprecated.terms.yaml" 2>/dev/null || true)"
[[ -n "$LEGACY_REPO_NAME" && "$LEGACY_REPO_NAME" != "null" ]] || LEGACY_REPO_NAME="legacy-repo"
LEGACY_ESCAPED="$(printf '%s' "$LEGACY_REPO_NAME" | sed 's/[.[\*^$()+?{}|]/\\&/g')"
FORBIDDEN_RE="(/Users/ronnyworks/${LEGACY_ESCAPED}|~/${LEGACY_ESCAPED}|\\\\$HOME/${LEGACY_ESCAPED}|\\\\.config/${LEGACY_ESCAPED})"
FORBIDDEN="$(rg -n -S "$FORBIDDEN_RE" "$DOCS" \
  -g'!**/legacy/**' \
  -g'!**/governance/_audits/**' \
  -g'!**/governance/LEGACY_DEPRECATION.md' \
  -g'!**/governance/OPS_PATCH_HISTORY.md' \
  -g'!**/governance/HOST_DRIFT_POLICY.md' \
  -g'!**/governance/CORE_AGENTIC_SCOPE.md' \
  -g'!**/governance/SESSION_PROTOCOL.md' \
  -g'!**/core/AGENTIC_GAP_MAP.md' \
  2>/dev/null || true)"

if [[ -n "$FORBIDDEN" ]]; then
  err "forbidden patterns found outside quarantine zones:"
  echo "$FORBIDDEN" | head -10
else
  echo "  No forbidden patterns outside quarantine (clean)"
fi

# ─────────────────────────────────────────────────────────────────────────
# CHECK 6b: External doc leaks
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 6b: External doc leaks ---"
WORKBENCH_DOCS="$(rg -n "workbench/docs" "$DOCS" -g'!**/governance/WORKBENCH_TOOLING_INDEX.md' 2>/dev/null || true)"
# Exclude code blocks (rg command examples) and EXTRACTION_PROTOCOL (scan syntax)
INFRA_DOCS="$(rg -n "infrastructure/docs" "$DOCS" -g'!**/core/EXTRACTION_PROTOCOL.md' 2>/dev/null | grep -v 'rg -n\|rg .*infrastructure' || true)"
# Exclude: WORKBENCH_TOOLING_INDEX (canonical), LEGACY_DEPRECATION (policy/examples), source attribution patterns
WORKBENCH_INFRA="$(rg -ni "~/code/workbench/infra" "$DOCS" \
  -g'!**/governance/WORKBENCH_TOOLING_INDEX.md' \
  -g'!**/governance/LEGACY_DEPRECATION.md' \
  2>/dev/null | grep -v 'Source Attribution\|Seeded from\|Source:' || true)"

if [[ -n "$WORKBENCH_DOCS" ]]; then
  err "workbench docs referenced outside WORKBENCH_TOOLING_INDEX.md:"
  echo "$WORKBENCH_DOCS" | head -10
else
  echo "  No workbench docs references outside Tooling Index (clean)"
fi

if [[ -n "$INFRA_DOCS" ]]; then
  err "forbidden infrastructure/docs references found:"
  echo "$INFRA_DOCS" | head -10
else
  echo "  No infrastructure/docs references (clean)"
fi

if [[ -n "$WORKBENCH_INFRA" ]]; then
  err "workbench/infra paths outside WORKBENCH_TOOLING_INDEX.md:"
  echo "$WORKBENCH_INFRA" | head -10
else
echo "  No workbench/infra paths outside Tooling Index (clean)"
fi

# ─────────────────────────────────────────────────────────────────────────
# CHECK 6c: Secret-like strings in docs (never allowed)
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 6c: Secret leaks (docs) ---"

# Keep output safe: file:line only (never echo the full line content).
scan_doc_file_for_secrets() {
  local f="$1"
  local rel="${f#$ROOT/}"

  # RTSP URLs almost always embed credentials; never allow them in docs.
  while IFS= read -r hit; do
    # hit format: path:line:rtsp://
    local line_no
    line_no="$(echo "$hit" | cut -d: -f2)"
    err "rtsp:// found in docs: $rel:$line_no (store RTSP URLs in Infisical)"
  done < <(rg -n -o "rtsp://" "$f" 2>/dev/null || true)

  # Table cells that contain password values (must be -, <REDACTED>, or Infisical reference).
  while IFS= read -r hit; do
    # hit format: rel:line
    err "password value found in docs table: $hit (store credentials in Infisical)"
  done < <(awk -v rel="$rel" '
    BEGIN { IGNORECASE=1 }
    {
      n=split($0,a,"|");
      if (n < 4) { next }
      key=a[2]; val=a[3];
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", key);
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", val);
      k=tolower(key);
      if (k=="password" || k=="admin password") {
        v=tolower(val);
        if (val=="" || val=="-" || val=="<REDACTED>" || index(v,"infisical")>0) { next }
        printf("%s:%d\n", rel, NR);
      }
    }
  ' "$f")

  # Inline \"user / pass\" patterns.
  while IFS= read -r hit; do
    err "inline credential pattern found in docs: $hit (store credentials in Infisical)"
  done < <(awk -v rel="$rel" '
    BEGIN { IGNORECASE=1 }
    /(admin|root)[[:space:]]+\/[[:space:]]+[^[:space:]]+/ {
      if ($0 ~ /<REDACTED>/) { next }
      if (tolower($0) ~ /infisical/) { next }
      printf("%s:%d\n", rel, NR);
    }
  ' "$f")
}

while IFS= read -r -d '' f; do
  scan_doc_file_for_secrets "$f"
done < <(find "$DOCS" -name "*.md" \
  -not -path "*/legacy/*" \
  -not -path "*/_imported/*" \
  -not -path "*/_audits/*" \
  -not -path "*/_receipts_meta/*" \
  -print0 \
  | sort -z)

# ─────────────────────────────────────────────────────────────────────────
# CHECK 7: SSOT path validation
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "--- Check 7: SSOT path existence ---"
SSOT_OK=0; SSOT_EXT=0; SSOT_MISS=0
if command -v yq >/dev/null 2>&1 && [[ -f "$DOCS/governance/SSOT_REGISTRY.yaml" ]]; then
  while IFS= read -r p; do
    [[ -z "$p" || "$p" == "null" ]] && continue
    if [[ "$p" == docs/* || "$p" == ops/* || "$p" == surfaces/* ]]; then
      if [[ -f "$ROOT/$p" ]]; then
        SSOT_OK=$((SSOT_OK+1))
      else
        err "SSOT path missing: $p"
        SSOT_MISS=$((SSOT_MISS+1))
      fi
    else
      SSOT_EXT=$((SSOT_EXT+1))
    fi
  done < <(yq eval '.ssots[].path // ""' "$DOCS/governance/SSOT_REGISTRY.yaml" 2>/dev/null)
  echo "  $SSOT_OK spine-local OK, $SSOT_EXT external (cross-repo), $SSOT_MISS missing"
else
  echo "  SKIP: yq not found or SSOT_REGISTRY.yaml missing"
fi

# ─────────────────────────────────────────────────────────────────────────
# SUMMARY
# ─────────────────────────────────────────────────────────────────────────
echo ""
echo "errors: $ERRORS"
echo "warnings: $WARNINGS"

if [[ "$ERRORS" -gt 0 ]]; then
  echo "status: FAIL"
  exit 1
else
  echo "status: OK"
fi
