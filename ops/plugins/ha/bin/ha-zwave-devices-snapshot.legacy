#!/usr/bin/env bash
set -euo pipefail

# ha.zwave.devices.snapshot — Extract Z-Wave device list from HA API
# Reads zwave_js entities from HA Core API, writes YAML binding.
# Requires: HA_API_TOKEN from Infisical, HA reachable via LAN (default) or HA_HOST override.

SPINE_ROOT="${SPINE_ROOT:-$HOME/code/agentic-spine}"
OUTPUT="$SPINE_ROOT/ops/bindings/zwave.devices.yaml"
INFISICAL_AGENT="${SPINE_ROOT}/ops/tools/infisical-agent.sh"
HA_HOST="${HA_HOST:-10.0.0.100}"
HA_PORT="${HA_PORT:-8123}"
HA_API="http://${HA_HOST}:${HA_PORT}/api"

echo "ha.zwave.devices.snapshot"
echo

# Resolve token
if [[ ! -x "$INFISICAL_AGENT" ]]; then
  echo "STOP (2): infisical-agent.sh not found"
  exit 2
fi

HA_TOKEN=$("$INFISICAL_AGENT" get home-assistant prod HA_API_TOKEN 2>/dev/null) || true
if [[ -z "$HA_TOKEN" ]]; then
  echo "STOP (2): could not retrieve HA_API_TOKEN"
  exit 2
fi

# Fetch all states
ALL_STATES=$(curl -s --connect-timeout 10 \
  -H "Authorization: Bearer $HA_TOKEN" \
  "${HA_API}/states" 2>/dev/null) || {
  echo "STOP (2): HA unreachable"
  exit 2
}

# Check if Z-Wave JS add-on is running (look for zwave_js entities)
ZWAVE_COUNT=$(echo "$ALL_STATES" | jq '[.[] | select(.entity_id | startswith("zwave_js."))] | length' 2>/dev/null) || ZWAVE_COUNT=0

# Also check for sensor entities from Z-Wave devices
ZWAVE_DEVICE_ENTITIES=$(echo "$ALL_STATES" | jq -r '[.[] | select(.attributes.device_class != null) | select(.entity_id | test("zwave")) | {entity_id, state, friendly_name: .attributes.friendly_name, device_class: .attributes.device_class}]' 2>/dev/null) || ZWAVE_DEVICE_ENTITIES="[]"

# Check Z-Wave JS UI add-on state via update entity
ZW_ADDON_VERSION=$(echo "$ALL_STATES" | jq -r '.[] | select(.entity_id == "update.z_wave_js_update") | .attributes.installed_version // "unknown"' 2>/dev/null) || ZW_ADDON_VERSION="unknown"

# Check TubesZB serial status
ZW_SERIAL=$(echo "$ALL_STATES" | jq -r '.[] | select(.entity_id == "binary_sensor.tubeszb_2026_zw_tubeszb_zw_serial_connected") | .state // "unknown"' 2>/dev/null) || ZW_SERIAL="unknown"
TUBESZB_IP=$(echo "$ALL_STATES" | jq -r '.[] | select(.entity_id == "sensor.tubeszb_2026_zw_esp_ip_address") | .state // "unknown"' 2>/dev/null) || TUBESZB_IP="unknown"
TUBESZB_FW=$(echo "$ALL_STATES" | jq -r '.[] | select(.entity_id == "update.tubeszb_2026_zw_tubeszb_firmware_update") | .attributes.installed_version // "unknown"' 2>/dev/null) || TUBESZB_FW="unknown"

# Write YAML binding
python3 - "$OUTPUT" "$ZW_ADDON_VERSION" "$ZW_SERIAL" "$TUBESZB_IP" "$TUBESZB_FW" "$ZWAVE_COUNT" "$ALL_STATES" << 'PYEOF'
import json, sys, datetime

try:
    import yaml
except ImportError:
    print("STOP (2): PyYAML not installed", file=sys.stderr)
    sys.exit(2)

out_path = sys.argv[1]
addon_version = sys.argv[2]
serial_state = sys.argv[3]
tubeszb_ip = sys.argv[4]
tubeszb_fw = sys.argv[5]
zwave_entity_count = int(sys.argv[6])
all_states = json.loads(sys.argv[7])

# Extract Z-Wave device entities (those with zwave in entity_id or device info)
devices = []
for s in all_states:
    eid = s.get('entity_id', '')
    # Z-Wave JS creates entities like sensor.*, binary_sensor.*, etc. with node_id attribute
    attrs = s.get('attributes', {})
    node_id = attrs.get('node_id')
    if node_id is not None:
        devices.append({
            'entity_id': eid,
            'state': s.get('state', 'unknown'),
            'friendly_name': attrs.get('friendly_name', 'unknown'),
            'node_id': node_id,
            'device_class': attrs.get('device_class', ''),
        })

# Deduplicate by node_id (group entities per node)
nodes = {}
for d in devices:
    nid = d['node_id']
    if nid not in nodes:
        nodes[nid] = {
            'node_id': nid,
            'name': d['friendly_name'].split(' ')[0] if d['friendly_name'] else f'node_{nid}',
            'entity_count': 0,
            'entities': [],
        }
    nodes[nid]['entity_count'] += 1
    nodes[nid]['entities'].append(d['entity_id'])

node_list = sorted(nodes.values(), key=lambda n: n['node_id'])

output = {
    'zwave_devices': {
        'last_snapshot': datetime.datetime.now(tz=datetime.timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ'),
        'controller': {
            'type': 'TubesZB ZAC93 (Zooz 800 Series Long Range)',
            'ip': tubeszb_ip,
            'esphome_firmware': tubeszb_fw,
            'serial_connected': serial_state,
            'socket': f'tcp://{tubeszb_ip}:6638',
        },
        'addon': {
            'name': 'Z-Wave JS UI',
            'version': addon_version,
        },
        'device_count': len(node_list),
        'total_entities': sum(n['entity_count'] for n in node_list),
        'nodes': node_list,
    }
}

header = '# Z-Wave Device Registry (SSOT)\n'
header += '# Auto-generated by ha.zwave.devices.snapshot — do not hand-edit.\n'
header += '# Source: HA Core API (zwave_js entities) + TubesZB ESPHome\n'
header += '# Status: authoritative\n\n'

with open(out_path, 'w') as f:
    f.write(header)
    yaml.dump(output, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

print(f"device_count={len(node_list)}")
print(f"total_entities={sum(n['entity_count'] for n in node_list)}")
print(f"controller_ip={tubeszb_ip}")
print(f"serial_connected={serial_state}")
print(f"addon_version={addon_version}")
PYEOF

echo
echo "Wrote $OUTPUT"
echo "sha256: $(shasum -a 256 "$OUTPUT" | cut -d' ' -f1)"
