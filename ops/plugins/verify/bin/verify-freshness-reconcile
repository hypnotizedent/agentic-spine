#!/usr/bin/env python3
import json
import os
import subprocess
import sys
from collections import Counter
from datetime import datetime, timezone
from pathlib import Path

import yaml


def fail(message: str) -> None:
    raise SystemExit(f"verify.freshness.reconcile FAIL: {message}")


def run_cmd(cmd: list[str], timeout: int, cwd: Path, env: dict[str, str]) -> tuple[int, str]:
    try:
        result = subprocess.run(
            cmd,
            cwd=str(cwd),
            env=env,
            capture_output=True,
            text=True,
            timeout=timeout,
            check=False,
        )
    except subprocess.TimeoutExpired:
        return 124, ""
    out = (result.stdout or "") + (result.stderr or "")
    return result.returncode, out.strip()


def gate_sort_key(gate_id: str) -> tuple[int, str]:
    if gate_id.startswith("D") and gate_id[1:].isdigit():
        return (int(gate_id[1:]), gate_id)
    return (10**9, gate_id)


def main() -> None:
    root = Path(__file__).resolve().parents[4]
    registry_path = root / "ops/bindings/gate.registry.yaml"
    contract_path = root / "ops/bindings/freshness.reconcile.contract.yaml"

    if not registry_path.exists():
        fail(f"missing file: {registry_path}")
    if not contract_path.exists():
        fail(f"missing file: {contract_path}")

    registry = yaml.safe_load(registry_path.read_text(encoding="utf-8")) or {}
    contract = yaml.safe_load(contract_path.read_text(encoding="utf-8")) or {}

    run_cfg = contract.get("run", {}) or {}
    gate_timeout = int(run_cfg.get("gate_timeout_seconds", 120))
    refresh_timeout = int(run_cfg.get("refresh_timeout_seconds", 180))

    report_cfg = contract.get("report", {}) or {}
    report_md = root / report_cfg.get("markdown_path", "docs/planning/W63_FRESHNESS_RECONCILE_REPORT.md")
    report_json = root / report_cfg.get("json_path", "docs/planning/W63_FRESHNESS_RECONCILE_REPORT.json")

    refresh_map = contract.get("refresh_mappings", {}) or {}

    gates = registry.get("gates", []) or []
    freshness_gates = []
    for gate in gates:
        gate_id = str(gate.get("id", "")).strip()
        if not gate_id:
            continue
        if str(gate.get("gate_class", "")).strip().lower() != "freshness":
            continue
        if bool(gate.get("retired", False)):
            continue
        freshness_gates.append(gate)

    env = os.environ.copy()
    env.setdefault("SPINE_ROOT", str(root))
    env.setdefault("VERIFY_TAILSCALE_PROBE_MODE", "passive")

    rows = []
    refreshed_count = 0
    unresolved_count = 0
    pass_count = 0
    rerun_count = 0
    reason_counts: Counter[str] = Counter()

    for gate in sorted(freshness_gates, key=lambda g: gate_sort_key(str(g.get("id", "")))):
        gate_id = str(gate.get("id", "")).strip()
        gate_name = str(gate.get("name", "")).strip()
        script_rel = str(gate.get("check_script", "")).strip()
        inline = bool(gate.get("inline", False))

        row = {
            "gate_id": gate_id,
            "gate_name": gate_name,
            "check_script": script_rel,
            "initial_status": "unknown",
            "refresh_capability": None,
            "refresh_status": "not_applicable",
            "final_status": "unknown",
            "unresolved_reason": None,
        }

        if inline:
            row["initial_status"] = "skipped"
            row["final_status"] = "unresolved"
            row["unresolved_reason"] = "inline_gate_not_individually_rerunnable"
            unresolved_count += 1
            reason_counts[row["unresolved_reason"]] += 1
            rows.append(row)
            continue

        script_path = root / script_rel
        if not script_rel or not script_path.exists() or not os.access(script_path, os.X_OK):
            row["initial_status"] = "failed"
            row["final_status"] = "unresolved"
            row["unresolved_reason"] = "missing_gate_script"
            unresolved_count += 1
            reason_counts[row["unresolved_reason"]] += 1
            rows.append(row)
            continue

        rc_initial, _ = run_cmd(["bash", str(script_path)], gate_timeout, root, env)
        if rc_initial == 0:
            row["initial_status"] = "pass"
            row["final_status"] = "pass"
            pass_count += 1
            rows.append(row)
            continue

        row["initial_status"] = "failed"
        mapping = refresh_map.get(gate_id, {}) or {}
        capability = str(mapping.get("capability", "")).strip()
        args = mapping.get("args", []) or []

        if not capability:
            row["final_status"] = "unresolved"
            row["unresolved_reason"] = "no_refresh_capability"
            unresolved_count += 1
            reason_counts[row["unresolved_reason"]] += 1
            rows.append(row)
            continue

        row["refresh_capability"] = capability
        refresh_cmd = ["./bin/ops", "cap", "run", capability]
        if args:
            refresh_cmd.append("--")
            refresh_cmd.extend(str(x) for x in args)

        rc_refresh, _ = run_cmd(refresh_cmd, refresh_timeout, root, env)
        if rc_refresh != 0:
            row["refresh_status"] = "failed"
            row["final_status"] = "unresolved"
            row["unresolved_reason"] = "refresh_capability_failed"
            unresolved_count += 1
            reason_counts[row["unresolved_reason"]] += 1
            rows.append(row)
            continue

        row["refresh_status"] = "ran"
        rerun_count += 1
        rc_rerun, _ = run_cmd(["bash", str(script_path)], gate_timeout, root, env)
        if rc_rerun == 0:
            row["final_status"] = "refreshed"
            refreshed_count += 1
        else:
            row["final_status"] = "unresolved"
            row["unresolved_reason"] = "still_failing_after_refresh"
            unresolved_count += 1
            reason_counts[row["unresolved_reason"]] += 1

        rows.append(row)

    generated = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    payload = {
        "generated_at_utc": generated,
        "source_registry": str(registry_path),
        "source_contract": str(contract_path),
        "total_freshness_gates": len(freshness_gates),
        "pass_count": pass_count,
        "refreshed_count": refreshed_count,
        "rerun_count": rerun_count,
        "unresolved_count": unresolved_count,
        "unresolved_reasons": dict(reason_counts),
        "rows": rows,
    }

    report_md.parent.mkdir(parents=True, exist_ok=True)
    report_json.parent.mkdir(parents=True, exist_ok=True)
    report_json.write_text(json.dumps(payload, indent=2, sort_keys=False) + "\n", encoding="utf-8")

    lines = [
        "# W63 Freshness Reconcile Report",
        "",
        f"Generated: {generated}",
        f"Source contract: `{contract_path}`",
        f"Source registry: `{registry_path}`",
        "",
        "## Summary",
        "",
        f"- freshness_gates_total: **{len(freshness_gates)}**",
        f"- pass_count: **{pass_count}**",
        f"- refreshed_count: **{refreshed_count}**",
        f"- rerun_count: **{rerun_count}**",
        f"- unresolved_count: **{unresolved_count}**",
        "",
        "## Unresolved Reason Counts",
        "",
        "| reason | count |",
        "|---|---:|",
    ]

    if reason_counts:
        for reason, count in sorted(reason_counts.items()):
            lines.append(f"| {reason} | {count} |")
    else:
        lines.append("| none | 0 |")

    lines.extend(
        [
            "",
            "## Gate Reconciliation Detail",
            "",
            "| gate_id | gate_name | initial_status | refresh_capability | refresh_status | final_status | unresolved_reason |",
            "|---|---|---|---|---|---|---|",
        ]
    )

    for row in rows:
        lines.append(
            "| {gate_id} | {gate_name} | {initial_status} | {refresh_capability} | {refresh_status} | {final_status} | {unresolved_reason} |".format(
                gate_id=row["gate_id"],
                gate_name=row["gate_name"] or "n/a",
                initial_status=row["initial_status"],
                refresh_capability=row["refresh_capability"] or "n/a",
                refresh_status=row["refresh_status"],
                final_status=row["final_status"],
                unresolved_reason=row["unresolved_reason"] or "n/a",
            )
        )

    report_md.write_text("\n".join(lines) + "\n", encoding="utf-8")

    print("verify.freshness.reconcile")
    print(f"freshness_gates_total: {len(freshness_gates)}")
    print(f"refreshed_count: {refreshed_count}")
    print(f"unresolved_count: {unresolved_count}")
    print(f"report_md: {report_md}")
    print(f"report_json: {report_json}")


if __name__ == "__main__":
    main()
