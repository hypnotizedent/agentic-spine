#!/usr/bin/env bash
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
CONTRACT="$ROOT/ops/bindings/vertical.integration.admission.contract.yaml"
DEPLOY_STATUS_BIN="$ROOT/ops/plugins/mint/bin/deploy-status"

stop() {
  echo "STOP (2): $*" >&2
  exit 2
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || stop "missing dependency: $1"
}

resolve_contract_path() {
  local p="${1:-}"
  if [[ -z "$p" ]]; then
    printf '%s\n' ""
    return
  fi
  if [[ "$p" == /* ]]; then
    printf '%s\n' "$p"
  else
    printf '%s\n' "$ROOT/$p"
  fi
}

combine_status() {
  local current="$1"
  local next="$2"
  if [[ "$current" == "FAIL" || "$next" == "FAIL" ]]; then
    printf '%s\n' "FAIL"
    return
  fi
  if [[ "$current" == "WARN" || "$next" == "WARN" ]]; then
    printf '%s\n' "WARN"
    return
  fi
  printf '%s\n' "PASS"
}

need_cmd yq
need_cmd curl
[[ -f "$CONTRACT" ]] || stop "missing contract: $CONTRACT"

module_count="$(yq e '.parity_status.modules | length' "$CONTRACT" 2>/dev/null || echo 0)"
[[ "$module_count" =~ ^[0-9]+$ ]] || stop "invalid module count in contract"
(( module_count > 0 )) || stop "no parity modules configured in contract"

deploy_output=""
deploy_rc=0
if [[ -x "$DEPLOY_STATUS_BIN" ]]; then
  set +e
  deploy_output="$($DEPLOY_STATUS_BIN 2>&1)"
  deploy_rc=$?
  set -e
else
  deploy_rc=127
  deploy_output="deploy status runner missing: $DEPLOY_STATUS_BIN"
fi

deploy_parsed=""
if (( deploy_rc == 0 )); then
  deploy_parsed="$(awk 'NF && $1 !~ /^(mint\.deploy\.status|===|compose_path:|CONTAINER|summary:|status:)/ {print $1"\t"$2}' <<< "$deploy_output" || true)"
fi

echo "vertical.integration.parity.status"
echo "generated_at_utc: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
echo "contract: $CONTRACT"
echo
printf "%-12s %-28s %-5s %s\n" "MODULE" "DIMENSION" "STATE" "REASON"

overall_status="PASS"
module_summary=""

for ((idx=0; idx<module_count; idx++)); do
  module_id="$(yq e -r ".parity_status.modules[$idx].id // \"module_$idx\"" "$CONTRACT")"
  module_status="PASS"

  # 1) Code surface present
  code_repo_rel="$(yq e -r ".parity_status.modules[$idx].code_surface.in_repo_path // \"\"" "$CONTRACT")"
  code_external="$(yq e -r ".parity_status.modules[$idx].code_surface.external_read_only_path // \"\"" "$CONTRACT")"
  code_repo_abs="$(resolve_contract_path "$code_repo_rel")"
  code_state="FAIL"
  code_reason="missing both code paths"
  if [[ -n "$code_repo_abs" && -d "$code_repo_abs" ]]; then
    code_state="PASS"
    code_reason="in-repo path exists: ${code_repo_rel}"
  elif [[ -n "$code_external" && -d "$code_external" ]]; then
    code_state="PASS"
    code_reason="external read-only path exists: ${code_external}"
  fi
  printf "%-12s %-28s %-5s %s\n" "$module_id" "code_surface_present" "$code_state" "$code_reason"
  module_status="$(combine_status "$module_status" "$code_state")"

  # 2) Runtime container expected/running state
  runtime_state="PASS"
  runtime_reason=""
  if (( deploy_rc != 0 )); then
    runtime_state="WARN"
    runtime_reason="runtime check unavailable (mint.deploy.status rc=${deploy_rc})"
  else
    matched_any=0
    running_any=0
    runtime_matches=""
    while IFS= read -r expected_container; do
      [[ -n "$expected_container" ]] || continue
      while IFS=$'\t' read -r cname cstate; do
        [[ -n "$cname" ]] || continue
        if [[ "$cname" == $expected_container ]]; then
          matched_any=1
          if [[ -n "$runtime_matches" ]]; then
            runtime_matches+=", "
          fi
          runtime_matches+="${cname}:${cstate}"
          if [[ "${cstate,,}" == "running" ]]; then
            running_any=1
          fi
        fi
      done <<< "$deploy_parsed"
    done < <(yq e -r ".parity_status.modules[$idx].runtime.expected_containers[]?" "$CONTRACT")

    if (( matched_any == 0 )); then
      runtime_state="FAIL"
      runtime_reason="no expected containers found in mint.deploy.status"
    elif (( running_any == 0 )); then
      runtime_state="FAIL"
      runtime_reason="expected containers found but not running: ${runtime_matches}"
    else
      runtime_state="PASS"
      runtime_reason="running containers: ${runtime_matches}"
    fi
  fi
  printf "%-12s %-28s %-5s %s\n" "$module_id" "runtime_container_state" "$runtime_state" "$runtime_reason"
  module_status="$(combine_status "$module_status" "$runtime_state")"

  # 3) Endpoint health check
  endpoint_url="$(yq e -r ".parity_status.modules[$idx].endpoint_health.url // \"\"" "$CONTRACT")"
  endpoint_state="FAIL"
  endpoint_reason="endpoint url missing in contract"
  if [[ -n "$endpoint_url" ]]; then
    set +e
    endpoint_http="$(curl -sS -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "$endpoint_url" 2>/dev/null)"
    curl_rc=$?
    set -e
    if (( curl_rc != 0 )); then
      endpoint_state="FAIL"
      endpoint_reason="curl failed (rc=${curl_rc}) for ${endpoint_url}"
    else
      expected_hit=0
      while IFS= read -r expected_code; do
        [[ -n "$expected_code" ]] || continue
        if [[ "$endpoint_http" == "$expected_code" ]]; then
          expected_hit=1
          break
        fi
      done < <(yq e -r ".parity_status.modules[$idx].endpoint_health.expected_http_codes[]?" "$CONTRACT")
      if (( expected_hit == 1 )); then
        endpoint_state="PASS"
        endpoint_reason="http=${endpoint_http} (${endpoint_url})"
      else
        endpoint_state="FAIL"
        endpoint_reason="unexpected http=${endpoint_http} (${endpoint_url})"
      fi
    fi
  fi
  printf "%-12s %-28s %-5s %s\n" "$module_id" "endpoint_health" "$endpoint_state" "$endpoint_reason"
  module_status="$(combine_status "$module_status" "$endpoint_state")"

  # 4) MCP exposure check
  mcp_state="PASS"
  mcp_reason="markers present"
  missing_mcp_files=""
  missing_mcp_markers=""
  marker_found=0
  mcp_files_count=0
  while IFS= read -r mcp_file_rel; do
    [[ -n "$mcp_file_rel" ]] || continue
    mcp_files_count=$((mcp_files_count + 1))
    mcp_file_abs="$(resolve_contract_path "$mcp_file_rel")"
    if [[ ! -f "$mcp_file_abs" ]]; then
      if [[ -n "$missing_mcp_files" ]]; then
        missing_mcp_files+=", "
      fi
      missing_mcp_files+="$mcp_file_rel"
    fi
  done < <(yq e -r ".parity_status.modules[$idx].mcp_exposure.files[]?" "$CONTRACT")

  while IFS= read -r marker; do
    [[ -n "$marker" ]] || continue
    marker_hit=0
    while IFS= read -r mcp_file_rel; do
      [[ -n "$mcp_file_rel" ]] || continue
      mcp_file_abs="$(resolve_contract_path "$mcp_file_rel")"
      [[ -f "$mcp_file_abs" ]] || continue
      if grep -Fq -- "$marker" "$mcp_file_abs"; then
        marker_hit=1
        marker_found=1
        break
      fi
    done < <(yq e -r ".parity_status.modules[$idx].mcp_exposure.files[]?" "$CONTRACT")
    if (( marker_hit == 0 )); then
      if [[ -n "$missing_mcp_markers" ]]; then
        missing_mcp_markers+=", "
      fi
      missing_mcp_markers+="$marker"
    fi
  done < <(yq e -r ".parity_status.modules[$idx].mcp_exposure.required_markers[]?" "$CONTRACT")

  if (( mcp_files_count == 0 )); then
    mcp_state="FAIL"
    mcp_reason="contract has no mcp files configured"
  elif [[ -n "$missing_mcp_files" ]]; then
    mcp_state="FAIL"
    mcp_reason="missing mcp files: ${missing_mcp_files}"
  elif [[ -n "$missing_mcp_markers" ]]; then
    mcp_state="FAIL"
    mcp_reason="missing mcp markers: ${missing_mcp_markers}"
  elif (( marker_found == 0 )); then
    mcp_state="FAIL"
    mcp_reason="no required markers found in mcp files"
  fi
  printf "%-12s %-28s %-5s %s\n" "$module_id" "mcp_exposure" "$mcp_state" "$mcp_reason"
  module_status="$(combine_status "$module_status" "$mcp_state")"

  # 5) Docs/contracts reference check
  docs_state="PASS"
  docs_reason="required references present"
  missing_docs_files=""
  missing_docs_markers=""
  docs_files_count=0
  docs_marker_found=0

  while IFS= read -r docs_file_rel; do
    [[ -n "$docs_file_rel" ]] || continue
    docs_files_count=$((docs_files_count + 1))
    docs_file_abs="$(resolve_contract_path "$docs_file_rel")"
    if [[ ! -f "$docs_file_abs" ]]; then
      if [[ -n "$missing_docs_files" ]]; then
        missing_docs_files+=", "
      fi
      missing_docs_files+="$docs_file_rel"
    fi
  done < <(yq e -r ".parity_status.modules[$idx].docs_contract_reference.files[]?" "$CONTRACT")

  while IFS= read -r marker; do
    [[ -n "$marker" ]] || continue
    marker_hit=0
    while IFS= read -r docs_file_rel; do
      [[ -n "$docs_file_rel" ]] || continue
      docs_file_abs="$(resolve_contract_path "$docs_file_rel")"
      [[ -f "$docs_file_abs" ]] || continue
      if grep -Fq -- "$marker" "$docs_file_abs"; then
        marker_hit=1
        docs_marker_found=1
        break
      fi
    done < <(yq e -r ".parity_status.modules[$idx].docs_contract_reference.files[]?" "$CONTRACT")
    if (( marker_hit == 0 )); then
      if [[ -n "$missing_docs_markers" ]]; then
        missing_docs_markers+=", "
      fi
      missing_docs_markers+="$marker"
    fi
  done < <(yq e -r ".parity_status.modules[$idx].docs_contract_reference.required_markers[]?" "$CONTRACT")

  if (( docs_files_count == 0 )); then
    docs_state="FAIL"
    docs_reason="contract has no docs reference files configured"
  elif [[ -n "$missing_docs_files" ]]; then
    docs_state="FAIL"
    docs_reason="missing docs files: ${missing_docs_files}"
  elif [[ -n "$missing_docs_markers" ]]; then
    docs_state="FAIL"
    docs_reason="missing docs markers: ${missing_docs_markers}"
  elif (( docs_marker_found == 0 )); then
    docs_state="FAIL"
    docs_reason="no required markers found in docs/contracts files"
  fi
  printf "%-12s %-28s %-5s %s\n" "$module_id" "docs_contract_reference" "$docs_state" "$docs_reason"
  module_status="$(combine_status "$module_status" "$docs_state")"

  overall_status="$(combine_status "$overall_status" "$module_status")"
  if [[ -n "$module_summary" ]]; then
    module_summary+=$'\n'
  fi
  module_summary+="${module_id}: ${module_status}"
done

echo
echo "module_summary:"
printf "%s\n" "$module_summary"
echo "overall: ${overall_status}"

exit 0
