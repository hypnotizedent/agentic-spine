#!/usr/bin/env bash
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
CONTRACT="$ROOT/ops/bindings/spine.schema.conventions.yaml"
MODE="full"
JSON_MODE=0
REPORT_MODE=0

fail() {
  echo "schema.conventions.audit FAIL: $*" >&2
  exit 1
}

usage() {
  cat <<'USAGE'
schema-conventions-audit

Usage:
  schema-conventions-audit [--mode full|gate] [--json] [--report]

Modes:
  full  - audit all ops/bindings YAML files
  gate  - audit changed binding files + always_validate_files from conventions contract
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --) shift ;;
    --mode)
      MODE="${2:-}"
      shift 2
      ;;
    --json)
      JSON_MODE=1
      shift
      ;;
    --report)
      REPORT_MODE=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      fail "unknown arg: $1"
      ;;
  esac
done

[[ "$MODE" == "full" || "$MODE" == "gate" ]] || fail "--mode must be full or gate"

command -v yq >/dev/null 2>&1 || fail "required tool missing: yq"
command -v jq >/dev/null 2>&1 || fail "required tool missing: jq"
command -v git >/dev/null 2>&1 || fail "required tool missing: git"

[[ -f "$CONTRACT" ]] || fail "missing contract: $CONTRACT"
yq e '.' "$CONTRACT" >/dev/null 2>&1 || fail "invalid YAML in $CONTRACT"

DATE_RE="$(yq e -r '.date_rules.iso_8601_regex // ""' "$CONTRACT")"
[[ -n "$DATE_RE" && "$DATE_RE" != "null" ]] || DATE_RE='^[0-9]{4}-[0-9]{2}-[0-9]{2}([T][0-9]{2}:[0-9]{2}:[0-9]{2}Z)?$'

TOUCH_TO_FIX_REQUIRED="$(yq e -r '.legacy_alias_rules.touch_to_fix_required // true' "$CONTRACT")"

mapfile -t DISALLOWED_KEYS < <(yq e -r '.field_rules.disallowed_alias_keys[]?' "$CONTRACT")
mapfile -t DISCOURAGED_KEYS < <(yq e -r '.field_rules.discouraged_alias_keys[]?' "$CONTRACT")
mapfile -t STATUS_ALLOWED < <(yq e -r '.status_rules.allowed_values[]?' "$CONTRACT")
mapfile -t LIFECYCLE_ALLOWED < <(yq e -r '.status_rules.lifecycle_values[]?' "$CONTRACT")
mapfile -t DATE_FIELDS < <(
  {
    yq e -r '.date_rules.canonical_fields[]?' "$CONTRACT"
    yq e -r '.date_rules.accepted_legacy_fields[]?' "$CONTRACT"
  } | awk 'NF && !seen[$0]++'
)

contains_in_array() {
  local needle="$1"
  shift || true
  local item
  for item in "$@"; do
    [[ "$item" == "$needle" ]] && return 0
  done
  return 1
}

append_unique() {
  local entry="$1"
  local target="$2"
  local existing
  if [[ "$target" == "violations" ]]; then
    for existing in "${VIOLATIONS[@]}"; do
      [[ "$existing" == "$entry" ]] && return 0
    done
    VIOLATIONS+=("$entry")
  else
    for existing in "${WARNINGS[@]}"; do
      [[ "$existing" == "$entry" ]] && return 0
    done
    WARNINGS+=("$entry")
  fi
}

collect_changed_binding_files() {
  {
    git -C "$ROOT" diff --name-only -- 2>/dev/null || true
    git -C "$ROOT" diff --cached --name-only -- 2>/dev/null || true
    git -C "$ROOT" ls-files --others --exclude-standard -- 2>/dev/null || true
  } | rg '^ops/bindings/.*\.ya?ml$' | awk '!seen[$0]++'
}

mapfile -t CHANGED_FILES < <(collect_changed_binding_files)

declare -a CANDIDATES=()
if [[ "$MODE" == "full" ]]; then
  while IFS= read -r f; do
    CANDIDATES+=("$f")
  done < <(find "$ROOT/ops/bindings" -type f \( -name '*.yaml' -o -name '*.yml' \) | sed "s|^$ROOT/||" | sort)
else
  mapfile -t ALWAYS_VALIDATE < <(yq e -r '.policy.always_validate_files[]?' "$CONTRACT")
  CANDIDATES+=("${ALWAYS_VALIDATE[@]}")
  CANDIDATES+=("${CHANGED_FILES[@]}")
fi

# unique + drop empties
declare -a UNIQUE_CANDIDATES=()
for f in "${CANDIDATES[@]}"; do
  [[ -n "$f" ]] || continue
  if ! contains_in_array "$f" "${UNIQUE_CANDIDATES[@]}"; then
    UNIQUE_CANDIDATES+=("$f")
  fi
done
CANDIDATES=("${UNIQUE_CANDIDATES[@]}")

if [[ "${#CANDIDATES[@]}" -eq 0 ]]; then
  if [[ "$JSON_MODE" -eq 1 ]]; then
    jq -n --arg mode "$MODE" '{status:"pass", mode:$mode, files_checked:0, violations:[], warnings:[]}'
  else
    echo "schema.conventions.audit"
    echo "mode: $MODE"
    echo "files_checked: 0"
    echo "status: PASS (no candidate files)"
  fi
  exit 0
fi

declare -a VIOLATIONS=()
declare -a WARNINGS=()

audit_file() {
  local rel="$1"
  local abs="$ROOT/$rel"

  [[ -f "$abs" ]] || {
    append_unique "$rel :: file missing" "violations"
    return
  }

  if ! yq e '.' "$abs" >/dev/null 2>&1; then
    append_unique "$rel :: invalid YAML" "violations"
    return
  fi

  mapfile -t PRESENT_KEYS < <(yq e '.. | select(tag == "!!map") | keys | .[]' "$abs" 2>/dev/null | awk 'NF && !seen[$0]++')

  local is_changed=0
  if contains_in_array "$rel" "${CHANGED_FILES[@]}"; then
    is_changed=1
  fi

  local key
  for key in "${DISALLOWED_KEYS[@]}"; do
    [[ -n "$key" ]] || continue
    if contains_in_array "$key" "${PRESENT_KEYS[@]}"; then
      mapfile -t ALLOWED_KEYS_FOR_FILE < <(yq e -r ".legacy_alias_rules.legacy_exceptions[] | select(.file == \"$rel\") | .allowed_keys[]?" "$CONTRACT" 2>/dev/null)
      if contains_in_array "$key" "${ALLOWED_KEYS_FOR_FILE[@]}"; then
        if [[ "$TOUCH_TO_FIX_REQUIRED" == "true" && "$is_changed" -eq 1 ]]; then
          append_unique "$rel :: disallowed key '$key' is legacy-excepted but file is changed (touch-and-fix required)" "violations"
        else
          append_unique "$rel :: legacy key '$key' allowed by exception (not changed)" "warnings"
        fi
      else
        append_unique "$rel :: disallowed key '$key' found" "violations"
      fi
    fi
  done

  for key in "${DISCOURAGED_KEYS[@]}"; do
    [[ -n "$key" ]] || continue
    if contains_in_array "$key" "${PRESENT_KEYS[@]}"; then
      append_unique "$rel :: discouraged key '$key' found" "warnings"
    fi
  done

  mapfile -t STATUS_VALUES < <(yq e '.. | select(tag == "!!map" and has("status")) | .status' "$abs" 2>/dev/null)
  local val
  for val in "${STATUS_VALUES[@]}"; do
    [[ -n "$val" && "$val" != "null" ]] || continue
    if ! contains_in_array "$val" "${STATUS_ALLOWED[@]}"; then
      append_unique "$rel :: status value '$val' not allowed by conventions" "violations"
    fi
  done

  mapfile -t LIFECYCLE_VALUES < <(yq e '.. | select(tag == "!!map" and has("lifecycle")) | .lifecycle' "$abs" 2>/dev/null)
  for val in "${LIFECYCLE_VALUES[@]}"; do
    [[ -n "$val" && "$val" != "null" ]] || continue
    if ! contains_in_array "$val" "${LIFECYCLE_ALLOWED[@]}"; then
      append_unique "$rel :: lifecycle value '$val' not allowed by conventions" "violations"
    fi
  done

  local field
  for field in "${DATE_FIELDS[@]}"; do
    [[ -n "$field" ]] || continue
    mapfile -t FIELD_VALUES < <(yq e ".. | select(tag == \"!!map\" and has(\"$field\")) | .$field" "$abs" 2>/dev/null)
    for val in "${FIELD_VALUES[@]}"; do
      [[ -n "$val" && "$val" != "null" ]] || continue
      [[ "$val" == "true" || "$val" == "false" ]] && continue
      # Heuristic: only enforce format when value is date-like.
      [[ "$val" =~ [0-9]{4}-[0-9]{2}-[0-9]{2} ]] || continue
      if ! [[ "$val" =~ $DATE_RE ]]; then
        append_unique "$rel :: field '$field' has non-ISO value '$val'" "violations"
      fi
    done
  done
}

for rel in "${CANDIDATES[@]}"; do
  audit_file "$rel"
done

status="pass"
[[ "${#VIOLATIONS[@]}" -gt 0 ]] && status="fail"

if [[ "$REPORT_MODE" -eq 1 ]]; then
  REPORT_DIR_REL="$(yq e -r '.reporting.audit_report_dir // "docs/governance/_audits"' "$CONTRACT")"
  REPORT_PREFIX="$(yq e -r '.reporting.audit_report_prefix // "SPINE_SCHEMA_CONVENTIONS_AUDIT"' "$CONTRACT")"
  REPORT_DIR="$ROOT/$REPORT_DIR_REL"
  mkdir -p "$REPORT_DIR"
  STAMP="$(date +%Y%m%d)"
  REPORT_FILE="$REPORT_DIR/${REPORT_PREFIX}_${STAMP}.md"

  {
    echo "# Spine Schema Conventions Audit"
    echo
    echo "- Mode: $MODE"
    echo "- Status: ${status^^}"
    echo "- Files checked: ${#CANDIDATES[@]}"
    echo "- Violations: ${#VIOLATIONS[@]}"
    echo "- Warnings: ${#WARNINGS[@]}"
    echo
    echo "## Violations"
    if [[ "${#VIOLATIONS[@]}" -eq 0 ]]; then
      echo "- none"
    else
      for row in "${VIOLATIONS[@]}"; do
        echo "- $row"
      done
    fi
    echo
    echo "## Warnings"
    if [[ "${#WARNINGS[@]}" -eq 0 ]]; then
      echo "- none"
    else
      for row in "${WARNINGS[@]}"; do
        echo "- $row"
      done
    fi
  } > "$REPORT_FILE"
fi

if [[ "$JSON_MODE" -eq 1 ]]; then
  jq -n \
    --arg status "$status" \
    --arg mode "$MODE" \
    --argjson files_checked "${#CANDIDATES[@]}" \
    --argjson violations "$(printf '%s\n' "${VIOLATIONS[@]}" | jq -R -s 'split("\n") | map(select(length > 0))')" \
    --argjson warnings "$(printf '%s\n' "${WARNINGS[@]}" | jq -R -s 'split("\n") | map(select(length > 0))')" \
    '{status:$status, mode:$mode, files_checked:$files_checked, violations:$violations, warnings:$warnings}'
else
  echo "schema.conventions.audit"
  echo "mode: $MODE"
  echo "files_checked: ${#CANDIDATES[@]}"
  echo "violations: ${#VIOLATIONS[@]}"
  echo "warnings: ${#WARNINGS[@]}"

  if [[ "${#VIOLATIONS[@]}" -gt 0 ]]; then
    echo
    echo "violations:"
    printf '  - %s\n' "${VIOLATIONS[@]}"
  fi

  if [[ "${#WARNINGS[@]}" -gt 0 ]]; then
    echo
    echo "warnings:"
    printf '  - %s\n' "${WARNINGS[@]}"
  fi
fi

if [[ "$status" == "fail" ]]; then
  exit 1
fi

exit 0
