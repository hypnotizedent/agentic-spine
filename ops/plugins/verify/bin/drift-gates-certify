#!/usr/bin/env bash
# drift-gates-certify - inventory/certification report for surfaces/verify drift gates
#
# Purpose:
#   Give agents a single, fast, scan-first view of what each drift gate checks,
#   which scripts back it, and what SSOT files it depends on, without running
#   the full gate suite.
#
# Output:
#   Markdown report to stdout (captured by receipts).
#
# Optional:
#   --profile       : execute gate scripts (where possible) and include timings.
#   --list-domains  : print configured gate domains from gate.domain.profiles.yaml.
#   --domain <name> : filter report to a configured domain gate pack.
#   --brief         : summary-only output (useful for preflight banners).
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_CODE="${SPINE_CODE:-$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || true)}"
if [[ -z "${SPINE_CODE:-}" ]]; then
  SPINE_CODE="$(cd "$SCRIPT_DIR/../../../.." && pwd)"
fi
SPINE_REPO="${SPINE_REPO:-$SPINE_CODE}"

PROFILE=0
LIST_DOMAINS=0
BRIEF=0
DOMAIN=""
DOMAIN_BINDING="$SPINE_CODE/ops/bindings/gate.domain.profiles.yaml"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --profile) PROFILE=1; shift ;;
    --list-domains) LIST_DOMAINS=1; shift ;;
    --brief) BRIEF=1; shift ;;
    --domain)
      [[ $# -ge 2 ]] || { echo "ERROR: --domain requires a value" >&2; exit 2; }
      DOMAIN="$2"
      shift 2
      ;;
    -h|--help)
      cat <<'EOF'
drift-gates-certify

Usage:
  drift-gates-certify [--profile] [--brief]
  drift-gates-certify --list-domains
  drift-gates-certify --domain <name> [--brief] [--profile]

Notes:
  - Default mode is scan-only (fast).
  - --profile runs executable gate scripts directly to measure time + pass/fail.
  - --list-domains and --domain use ops/bindings/gate.domain.profiles.yaml.
EOF
      exit 0
      ;;
    *)
      echo "ERROR: unknown arg: $1" >&2
      exit 2
      ;;
  esac
done

if [[ "$LIST_DOMAINS" -eq 1 || -n "$DOMAIN" ]]; then
  if [[ ! -f "$DOMAIN_BINDING" ]]; then
    echo "ERROR: missing gate domain binding: $DOMAIN_BINDING" >&2
    echo "ACTION: create ops/bindings/gate.domain.profiles.yaml (GAP-OP-432)." >&2
    exit 2
  fi

  if ! command -v yq >/dev/null 2>&1; then
    echo "ERROR: yq is required for --list-domains/--domain modes." >&2
    exit 2
  fi
fi

if [[ "$LIST_DOMAINS" -eq 1 ]]; then
  yq e '.domains | keys | .[]' "$DOMAIN_BINDING" 2>/dev/null
  exit 0
fi

DOMAINS_JSON='{}'
if [[ -n "$DOMAIN" ]]; then
  valid_domains="$(yq e '.domains | keys | .[]' "$DOMAIN_BINDING" 2>/dev/null | tr '\n' ' ' | sed -E 's/[[:space:]]+$//')"
  domain_exists="$(yq e ".domains.\"$DOMAIN\" != null" "$DOMAIN_BINDING" 2>/dev/null || echo "false")"
  if [[ "$domain_exists" != "true" ]]; then
    echo "ERROR: unknown domain: $DOMAIN" >&2
    echo "VALID: ${valid_domains:-<none>}" >&2
    exit 2
  fi
  DOMAINS_JSON="$(yq -o=json e '.domains' "$DOMAIN_BINDING" 2>/dev/null || echo '{}')"
fi

DG="$SPINE_CODE/surfaces/verify/drift-gate.sh"
if [[ ! -f "$DG" ]]; then
  echo "ERROR: missing: $DG" >&2
  exit 2
fi

DRIFT_GATE_DOMAINS_JSON="$DOMAINS_JSON" python3 - "$DG" "$SPINE_CODE" "$PROFILE" "$DOMAIN" "$BRIEF" <<'PY'
import json
import os
import re
import subprocess
import sys
import time
from dataclasses import dataclass
from pathlib import Path

dg_path = Path(sys.argv[1]).resolve()
spine_code = Path(sys.argv[2]).resolve()
profile = sys.argv[3] == "1"
domain = (sys.argv[4] or "").strip()
brief = sys.argv[5] == "1"
domains = json.loads(os.environ.get("DRIFT_GATE_DOMAINS_JSON", "{}"))

dg_text = dg_path.read_text(errors="ignore").splitlines()

@dataclass
class Gate:
  id: str
  label: str
  scripts: list[str]
  kind: str
  deps: list[str]
  profile_ms: int | None = None
  profile_rc: int | None = None

def extract_deps(text: str) -> list[str]:
  deps = set()
  # Capture explicit SSOT/binding references.
  for m in re.finditer(r"\b(docs/governance/[A-Za-z0-9_./-]+\.(?:md|yaml|yml))\b", text):
    deps.add(m.group(1))
  for m in re.finditer(r"\b(ops/bindings/[A-Za-z0-9_./-]+\.(?:yaml|yml))\b", text):
    deps.add(m.group(1))
  for m in re.finditer(r"\b(ops/capabilities\.yaml)\b", text):
    deps.add(m.group(1))
  for m in re.finditer(r"\b(surfaces/verify/[A-Za-z0-9_./-]+\.sh)\b", text):
    deps.add(m.group(1))
  return sorted(deps)

def classify_kind(text: str) -> str:
  # Heuristic: "network" if it likely touches remote network; else "local".
  # This is intentionally conservative.
  net_markers = [
    r"\bssh\b",
    r"\bcurl\b",
    r"\bncat\b",
    r"\bnc\b",
    r"\bping\b",
    r"\btailscale\b",
    r"\bdig\b",
    r"\bnslookup\b",
    r"\bhttp[s]?://",
  ]
  for pat in net_markers:
    if re.search(pat, text):
      return "network"
  return "local"

gates: list[Gate] = []

echo_re = re.compile(r'^echo -n "D(\d+)\s+([^"]+)"')
for i, line in enumerate(dg_text):
  m = echo_re.match(line.strip())
  if not m:
    continue
  num = m.group(1)
  label = m.group(2).strip()
  gate_id = f"D{int(num)}"

  # Determine the block for this gate: from this echo line until the next gate echo.
  j = i + 1
  while j < len(dg_text):
    if echo_re.match(dg_text[j].strip()):
      break
    j += 1
  block_lines = dg_text[i:j]
  block = "\n".join(block_lines)

  # Discover backing scripts mentioned in the block.
  scripts = []
  for sm in re.finditer(r"(surfaces/verify/[A-Za-z0-9_.-]+\.sh)", block):
    p = sm.group(1)
    if p.endswith("drift-gate.sh"):
      continue
    scripts.append(p)
  scripts = sorted(dict.fromkeys(scripts))

  # Prefer a dedicated dNN-* script when present.
  preferred = None
  dnn = f"d{int(num):02d}-"
  for s in scripts:
    if f"/{dnn}" in s:
      preferred = s
      break
  if preferred:
    scripts = [preferred] + [s for s in scripts if s != preferred]

  # Combine deps/kind across scripts if present; otherwise infer from inline block.
  deps_set = set()
  kind = "local"
  if scripts:
    kinds = set()
    for s in scripts:
      sabs = spine_code / s
      stext = sabs.read_text(errors="ignore") if sabs.exists() else ""
      for d in extract_deps(stext):
        deps_set.add(d)
      kinds.add(classify_kind(stext))
    kind = "network" if "network" in kinds else "local"
  else:
    kind = classify_kind(block)
    for d in extract_deps(block):
      deps_set.add(d)

  gates.append(Gate(id=gate_id, label=label, scripts=scripts, kind=kind, deps=sorted(deps_set)))

domain_missing: list[str] = []
if domain:
  dom = domains.get(domain, {})
  wanted = [str(x).strip() for x in dom.get("gate_ids", []) if str(x).strip()]
  idx = {g.id: g for g in gates}
  domain_missing = [gid for gid in wanted if gid not in idx]
  gates = [idx[gid] for gid in wanted if gid in idx]

# Optional profiling (script-backed gates only)
if profile:
  for g in gates:
    if not g.scripts:
      continue
    # Profile the preferred script only (first in list).
    script_abs = spine_code / g.scripts[0]
    if not script_abs.exists():
      g.profile_rc = 127
      g.profile_ms = 0
      continue
    t0 = time.perf_counter()
    try:
      p = subprocess.run(
        ["/usr/bin/env", "bash", str(script_abs)],
        cwd=str(spine_code),
        env={**os.environ, "SPINE_CODE": str(spine_code), "SPINE_REPO": str(spine_code)},
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
      )
      rc = p.returncode
    except Exception:
      rc = 127
    t1 = time.perf_counter()
    g.profile_rc = rc
    g.profile_ms = int((t1 - t0) * 1000)

now = time.strftime("%Y-%m-%d")
branch = ""
try:
  branch = subprocess.check_output(["git", "-C", str(spine_code), "rev-parse", "--abbrev-ref", "HEAD"], text=True).strip()
except Exception:
  branch = "unknown"

if brief:
  if domain:
    dom = domains.get(domain, {})
    desc = str(dom.get("description", "")).strip()
    wanted = [str(x).strip() for x in dom.get("gate_ids", []) if str(x).strip()]
    print("# Drift Gate Domain Brief")
    print(f"- Domain: `{domain}`")
    if desc:
      print(f"- Description: {desc}")
    print(f"- Gates configured: {len(wanted)}")
    print(f"- Gates discovered: {len(gates)}")
    if domain_missing:
      missing_txt = ", ".join(f"`{g}`" for g in domain_missing)
      print(f"- Missing from drift suite: {missing_txt}")
    else:
      print("- Missing from drift suite: none")
    ids_txt = ", ".join(f"`{g.id}`" for g in gates) if gates else "(none)"
    print(f"- Gate IDs: {ids_txt}")
    sys.exit(0)

  total = len(gates)
  local_n = sum(1 for g in gates if g.kind == "local")
  net_n = sum(1 for g in gates if g.kind == "network")
  script_n = sum(1 for g in gates if g.scripts)
  inline_n = total - script_n
  print("# Drift Gates Brief")
  print(f"- Gates discovered: {total}")
  print(f"- Script-backed: {script_n}")
  print(f"- Inline-only: {inline_n}")
  print(f"- Classified local: {local_n}")
  print(f"- Classified network: {net_n}")
  sys.exit(0)

print("# Drift Gates Certification Report")
print(f"- Date: {now}")
print(f"- Drift suite: `{dg_path}`")
print(f"- Branch: `{branch}`")
print(f"- Mode: {'scan+profile' if profile else 'scan-only'}")
if domain:
  print(f"- Domain filter: `{domain}`")
print("")

print("## Summary")
total = len(gates)
local_n = sum(1 for g in gates if g.kind == "local")
net_n = sum(1 for g in gates if g.kind == "network")
script_n = sum(1 for g in gates if g.scripts)
inline_n = total - script_n
print(f"- Gates discovered: {total}")
print(f"- Script-backed: {script_n}")
print(f"- Inline-only: {inline_n}")
print(f"- Classified local: {local_n}")
print(f"- Classified network: {net_n}")
if domain:
  dom = domains.get(domain, {})
  wanted = [str(x).strip() for x in dom.get("gate_ids", []) if str(x).strip()]
  print(f"- Domain configured gates: {len(wanted)}")
  print(f"- Domain discovered gates: {len(gates)}")
  if domain_missing:
    print(f"- Domain mapping missing IDs: {', '.join(domain_missing)}")
print("")

if profile:
  prof = [g for g in gates if g.profile_ms is not None]
  prof.sort(key=lambda g: g.profile_ms or 0, reverse=True)
  print("## Slowest Script Gates (Profile)")
  for g in prof[:10]:
    status = "PASS" if g.profile_rc == 0 else f"FAIL(rc={g.profile_rc})"
    backing = g.scripts[0] if g.scripts else "<inline>"
    print(f"- {g.id} {g.label} `{backing}`: {g.profile_ms}ms {status}")
  print("")

print("## Gate Inventory")
print("| Gate | Kind | Backing | Dependencies |")
print("|------|------|---------|--------------|")
for g in gates:
  if g.scripts:
    backing = f"`{g.scripts[0]}`"
    if len(g.scripts) > 1:
      backing = backing + f" (+{len(g.scripts)-1})"
  else:
    backing = "`<inline>`"
  deps = ", ".join(f"`{d}`" for d in g.deps[:5])
  if len(g.deps) > 5:
    deps = deps + f", â€¦ (+{len(g.deps) - 5})"
  print(f"| {g.id} {g.label} | {g.kind} | {backing} | {deps or ''} |")

print("")
print("## Notes")
print("- This report is heuristic. It is designed to route agents to the right script/SSOT quickly.")
print("- For full enforcement, run `./bin/ops cap run spine.verify` (receipted).")
PY
