#!/usr/bin/env bash
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)}"
TOPOLOGY="$ROOT/ops/bindings/gate.execution.topology.yaml"
REGISTRY="$ROOT/ops/bindings/gate.registry.yaml"
AGENT_PROFILES="$ROOT/ops/bindings/gate.agent.profiles.yaml"
DOMAIN_PROFILES="$ROOT/ops/bindings/gate.domain.profiles.yaml"
STABILIZATION_CONTRACT="$ROOT/ops/bindings/stabilization.mode.yaml"
RING_POLICY="$ROOT/ops/bindings/verify.ring.policy.yaml"

fail() {
  echo "verify.topology FAIL: $*" >&2
  exit 1
}

need_file() {
  [[ -f "$1" ]] || fail "missing file: $1"
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || fail "missing command: $1"
}

need_file "$TOPOLOGY"
need_file "$REGISTRY"
need_file "$AGENT_PROFILES"
need_file "$DOMAIN_PROFILES"
need_file "$RING_POLICY"
need_cmd yq
need_cmd python3

usage() {
  cat <<'USAGE'
verify-topology

Usage:
  verify-topology core [--json]
  verify-topology domain <domain_id> [--json] [--force]
  verify-topology domains-run <domain_csv|domain...> [--json] [--force]
  verify-topology release [--json] [--force]
  verify-topology recommend [--path <path>]... [--capability <cap>]... [--json]
  verify-topology pack-list
  verify-topology pack-explain <agent_id|domain>
  verify-topology pack-run [<agent_id|domain>] [--json]

Notes:
  - Core/day-to-day checks run through core_mode.core_gate_ids.
  - Domain checks resolve from gate.execution.topology.yaml first, then domain profiles fallback.
  - Release uses full drift-gate certification.
  - During active stabilization windows, domain/release can be bypassed unless --force is provided.
USAGE
}

ring_budget_seconds() {
  local ring="$1"
  local value
  value="$(yq e -r ".budgets_seconds.\"$ring\" // \"\"" "$RING_POLICY" 2>/dev/null || true)"
  [[ "$value" =~ ^[0-9]+$ ]] || fail "invalid ring budget for '$ring' in $RING_POLICY"
  echo "$value"
}

format_delta() {
  local delta="$1"
  if [[ "$delta" -gt 0 ]]; then
    echo "+${delta}s"
  else
    echo "${delta}s"
  fi
}

monotonic_ms() {
  python3 - <<'PY'
import time
print(int(time.monotonic() * 1000))
PY
}

ms_to_seconds() {
  local ms="$1"
  awk -v value="$ms" 'BEGIN { printf "%.3f", value / 1000 }'
}

format_delta_ms() {
  local delta_ms="$1"
  if (( delta_ms > 0 )); then
    echo "+$(ms_to_seconds "$delta_ms")s"
  else
    echo "$(ms_to_seconds "$delta_ms")s"
  fi
}

normalize_domain() {
  local raw="${1:-}"
  case "$raw" in
    core) echo "core" ;;
    loop-gap|loop_gap) echo "loop_gap" ;;
    home-automation) echo "home" ;;
    finance-ops) echo "finance" ;;
    automation) echo "n8n" ;;
    photos) echo "immich" ;;
    identity|email|calendar|microsoft) echo "microsoft" ;;
    *) echo "$raw" ;;
  esac
}

mapfile -t TOPOLOGY_DOMAINS < <(yq e -r '.domain_metadata[].domain_id' "$TOPOLOGY")

is_topology_domain() {
  local domain="$1"
  local d
  for d in "${TOPOLOGY_DOMAINS[@]}"; do
    [[ "$d" == "$domain" ]] && return 0
  done
  return 1
}

unique_lines() {
  awk 'NF && !seen[$0]++'
}

tailscale_online_from_status() {
  tailscale status --json 2>/dev/null | python3 -c '
import json
import sys

try:
    payload = json.load(sys.stdin)
except Exception:
    print("false")
    raise SystemExit(0)

self_obj = payload.get("Self") if isinstance(payload, dict) else {}
online = bool((self_obj or {}).get("Online"))
print("true" if online else "false")
' || echo "false"
}

resolve_tailscale_probe_mode() {
  local mode="${VERIFY_TAILSCALE_PROBE_MODE:-active}"
  case "$mode" in
    active|passive) echo "$mode" ;;
    *) echo "active" ;;
  esac
}

contains_value() {
  local needle="$1"
  shift || true
  local item
  for item in "$@"; do
    [[ "$item" == "$needle" ]] && return 0
  done
  return 1
}

receipt_output_has_mixed_status() {
  local out_file="$1"
  [[ -s "$out_file" ]] || return 1

  # Only check outputs that look like capability receipts marked complete.
  grep -Eqi '(^|[[:space:]])(DONE|Status:[[:space:]]+done|status:[[:space:]]+done|status:[[:space:]]+OK)' "$out_file" || return 1

  # Require at least one explicit success marker.
  grep -Eq '(^|[^A-Z])PASS([^A-Z]|$)|RESULT:[[:space:]]+PASS' "$out_file" || return 1

  # Flag mixed output when common hard-error signatures coexist with success markers.
  grep -Eqi 'failed to wait for command termination|^FAIL:|command not found|Traceback|Exception|unbound variable|unexpected EOF|No such file or directory|[[:space:]]ERROR:' "$out_file" || return 1
  return 0
}

print_receipt_mixed_status_excerpt() {
  local out_file="$1"
  grep -Ein 'failed to wait for command termination|^FAIL:|command not found|Traceback|Exception|unbound variable|unexpected EOF|No such file or directory|[[:space:]]ERROR:' "$out_file" | head -n 8 | sed 's/^/    /' || true
}

collect_domain_gate_ids() {
  local raw_domain="$1"
  local domain
  domain="$(normalize_domain "$raw_domain")"

  declare -A seen=()
  local gid

  while IFS=$'\t' read -r gate_id primary secondary; do
    [[ -n "$gate_id" ]] || continue
    if [[ "$primary" == "$domain" ]]; then
      seen["$gate_id"]=1
      continue
    fi
    if [[ -n "$secondary" ]]; then
      IFS=',' read -r -a sec_arr <<< "$secondary"
      for sec in "${sec_arr[@]}"; do
        if [[ "$sec" == "$domain" ]]; then
          seen["$gate_id"]=1
          break
        fi
      done
    fi
  done < <(yq e -r '.gate_assignments[] | [.gate_id, (.primary_domain // ""), ((.secondary_domains // []) | join(","))] | @tsv' "$TOPOLOGY")

  # Transition fallback: domain profile gates if topology has no direct assignments.
  if [[ "${#seen[@]}" -eq 0 ]]; then
    while IFS= read -r gid; do
      [[ -n "$gid" ]] && seen["$gid"]=1
    done < <(yq e -r ".domains.\"$raw_domain\".gate_ids[]?" "$DOMAIN_PROFILES" 2>/dev/null || true)

    if [[ "$domain" != "$raw_domain" ]]; then
      while IFS= read -r gid; do
        [[ -n "$gid" ]] && seen["$gid"]=1
      done < <(yq e -r ".domains.\"$domain\".gate_ids[]?" "$DOMAIN_PROFILES" 2>/dev/null || true)
    fi
  fi

  for gid in "${!seen[@]}"; do
    printf '%s\n' "$gid"
  done | sort -V
}

collect_core_gate_ids() {
  yq e -r '.core_mode.core_gate_ids[]?' "$TOPOLOGY" | unique_lines
}

run_gate_ids() {
  local json_mode="$1"
  local ring="${2:-}"
  shift 2
  local -a input_ids=("$@")
  local start_ms elapsed_ms budget budget_ms delta_ms elapsed_seconds
  start_ms="$(monotonic_ms)"

  declare -A seen=()
  local -a gate_ids=()
  local gid
  for gid in "${input_ids[@]}"; do
    [[ -n "$gid" ]] || continue
    if [[ -z "${seen[$gid]:-}" ]]; then
      seen["$gid"]=1
      gate_ids+=("$gid")
    fi
  done

  ((${#gate_ids[@]} > 0)) || fail "no gates resolved for run"

  # Pre-fetch all gate metadata in a single yq call (avoids 3 calls per gate).
  declare -A gate_script=()
  declare -A gate_inline=()
  declare -A gate_retired=()
  while IFS=$'\t' read -r _gid _script _inline _retired; do
    [[ -n "$_gid" ]] || continue
    gate_script["$_gid"]="$_script"
    gate_inline["$_gid"]="$_inline"
    gate_retired["$_gid"]="$_retired"
  done < <(yq e -r '.gates[] | [.id, (.check_script // ""), (.inline // false | tostring), (.retired // false | tostring)] | @tsv' "$REGISTRY" 2>/dev/null || true)

  local pass_count=0
  local fail_count=0
  local skipped_inline=0
  local skipped_retired=0
  local receipt_integrity_warnings=0
  local -a failing_ids=()
  local receipt_integrity_mode="${VERIFY_RECEIPT_INTEGRITY_MODE:-warn}"
  case "$receipt_integrity_mode" in
    off|warn|fail) ;;
    *) fail "invalid VERIFY_RECEIPT_INTEGRITY_MODE value: $receipt_integrity_mode (expected off|warn|fail)" ;;
  esac
  local parallel_jobs=1
  if [[ "${VERIFY_PARALLEL_JOBS:-}" =~ ^[1-9][0-9]*$ ]]; then
    parallel_jobs="${VERIFY_PARALLEL_JOBS}"
  elif [[ "$ring" == "standard" || "$ring" == "deep" ]]; then
    parallel_jobs=4
  fi

  declare -A gate_mode=()
  declare -A gate_script_abs=()
  declare -A gate_meta_fail_msg=()
  local tailscale_guard_needed=0
  local gid script_rel inline retired script_abs
  for gid in "${gate_ids[@]}"; do
    script_rel="${gate_script[$gid]:-}"
    inline="${gate_inline[$gid]:-false}"
    retired="${gate_retired[$gid]:-false}"

    if [[ -z "$script_rel" || "$script_rel" == "null" ]]; then
      gate_mode["$gid"]="meta_fail"
      gate_meta_fail_msg["$gid"]="missing check_script"
      continue
    fi

    if [[ "$retired" == "true" ]]; then
      gate_mode["$gid"]="skip_retired"
      continue
    fi

    if [[ "$inline" == "true" ]]; then
      gate_mode["$gid"]="skip_inline"
      continue
    fi

    script_abs="$ROOT/$script_rel"
    if [[ ! -x "$script_abs" ]]; then
      gate_mode["$gid"]="meta_fail"
      gate_meta_fail_msg["$gid"]="missing/non-executable script: $script_rel"
      continue
    fi

    gate_mode["$gid"]="run"
    gate_script_abs["$gid"]="$script_abs"
    if [[ "$tailscale_guard_needed" -eq 0 ]]; then
      if grep -Eq 'tailscale-guard\.sh|require_tailscale' "$script_abs" 2>/dev/null; then
        tailscale_guard_needed=1
      fi
    fi
  done

  if [[ "$json_mode" == "0" ]]; then
    echo "verify.run"
    echo "gate_count: ${#gate_ids[@]}"
    echo
  fi

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  local tailscale_cache_file=""
  if [[ "$tailscale_guard_needed" -eq 1 ]]; then
    tailscale_cache_file="$tmp_dir/tailscale_guard.cache"
    local tailscale_online="missing_cli"
    local tailscale_probe_mode
    tailscale_probe_mode="$(resolve_tailscale_probe_mode)"
    if command -v tailscale >/dev/null 2>&1; then
      if [[ "$tailscale_probe_mode" == "active" ]]; then
        tailscale_online="$(tailscale_online_from_status)"
        case "$tailscale_online" in
          true|false) ;;
          *) tailscale_online="false" ;;
        esac
      else
        # Passive mode avoids triggering tailscale auth/browser flows.
        tailscale_online="false"
      fi
    fi
    printf 'online=%s\n' "$tailscale_online" >"$tailscale_cache_file"
  fi

  local current_batch=0
  for gid in "${gate_ids[@]}"; do
    [[ "${gate_mode[$gid]:-}" == "run" ]] || continue

    local out_file rc_file
    out_file="$tmp_dir/${gid}.out"
    rc_file="$tmp_dir/${gid}.rc"
    (
      set +e
      if [[ -n "$tailscale_cache_file" ]]; then
        VERIFY_TAILSCALE_GUARD_CACHE_FILE="$tailscale_cache_file" bash "${gate_script_abs[$gid]}" >"$out_file" 2>&1
      else
        bash "${gate_script_abs[$gid]}" >"$out_file" 2>&1
      fi
      echo "$?" >"$rc_file"
    ) &
    current_batch=$((current_batch + 1))

    if (( current_batch >= parallel_jobs )); then
      set +e
      wait
      set -e
      current_batch=0
    fi
  done

  set +e
  wait
  set -e

  local rc out_file
  for gid in "${gate_ids[@]}"; do
    case "${gate_mode[$gid]:-meta_fail}" in
      skip_retired)
        skipped_retired=$((skipped_retired + 1))
        [[ "$json_mode" == "0" ]] && echo "$gid SKIP retired"
        ;;
      skip_inline)
        skipped_inline=$((skipped_inline + 1))
        [[ "$json_mode" == "0" ]] && echo "$gid SKIP inline-only"
        ;;
      meta_fail)
        fail_count=$((fail_count + 1))
        failing_ids+=("$gid")
        [[ "$json_mode" == "0" ]] && echo "$gid FAIL ${gate_meta_fail_msg[$gid]}"
        ;;
      run)
        out_file="$tmp_dir/${gid}.out"
        rc="$(cat "$tmp_dir/${gid}.rc" 2>/dev/null || echo 99)"
        if [[ "$rc" -eq 0 ]]; then
          if [[ "$receipt_integrity_mode" != "off" ]] && receipt_output_has_mixed_status "$out_file"; then
            if [[ "$receipt_integrity_mode" == "fail" ]]; then
              fail_count=$((fail_count + 1))
              failing_ids+=("$gid")
              if [[ "$json_mode" == "0" ]]; then
                echo "$gid FAIL receipt-integrity-mixed-status"
                print_receipt_mixed_status_excerpt "$out_file"
              fi
            else
              pass_count=$((pass_count + 1))
              receipt_integrity_warnings=$((receipt_integrity_warnings + 1))
              if [[ "$json_mode" == "0" ]]; then
                echo "$gid WARN receipt-integrity-mixed-status"
                print_receipt_mixed_status_excerpt "$out_file"
              fi
            fi
          else
            pass_count=$((pass_count + 1))
            [[ "$json_mode" == "0" ]] && echo "$gid PASS"
          fi
        else
          fail_count=$((fail_count + 1))
          failing_ids+=("$gid")
          if [[ "$json_mode" == "0" ]]; then
            echo "$gid FAIL (rc=$rc)"
            sed -n '1,60p' "$out_file" | sed 's/^/  /' || true
          fi
        fi
        ;;
      *)
        fail_count=$((fail_count + 1))
        failing_ids+=("$gid")
        [[ "$json_mode" == "0" ]] && echo "$gid FAIL unknown gate mode"
        ;;
    esac
  done

  rm -rf "$tmp_dir" >/dev/null 2>&1 || true

  if [[ "$json_mode" == "1" ]]; then
    local failing_json="[]"
    if [[ "${#failing_ids[@]}" -gt 0 ]]; then
      failing_json="$(printf '%s\n' "${failing_ids[@]}" | jq -R -s 'split("\n") | map(select(length > 0))')"
    fi
    jq -n \
      --argjson total "${#gate_ids[@]}" \
      --argjson pass "$pass_count" \
      --argjson fail "$fail_count" \
      --argjson skipped_inline "$skipped_inline" \
      --argjson skipped_retired "$skipped_retired" \
      --argjson receipt_integrity_warnings "$receipt_integrity_warnings" \
      --argjson failing_ids "$failing_json" \
      '{total:$total, pass:$pass, fail:$fail, skipped_inline:$skipped_inline, skipped_retired:$skipped_retired, receipt_integrity_warnings:$receipt_integrity_warnings, failing_ids:$failing_ids}'
  else
    echo
    echo "summary: pass=$pass_count fail=$fail_count skipped_inline=$skipped_inline skipped_retired=$skipped_retired"
    if [[ "$receipt_integrity_warnings" -gt 0 ]]; then
      echo "receipt_integrity_warnings: $receipt_integrity_warnings"
    fi
  fi

  local budget_breach=0
  if [[ -n "$ring" ]]; then
    elapsed_ms=$(( $(monotonic_ms) - start_ms ))
    budget="$(ring_budget_seconds "$ring")"
    budget_ms=$(( budget * 1000 ))
    delta_ms=$(( elapsed_ms - budget_ms ))
    elapsed_seconds="$(ms_to_seconds "$elapsed_ms")"

    if [[ "$json_mode" == "0" ]]; then
      echo "budget: ring=$ring elapsed=${elapsed_seconds}s budget=${budget}s delta=$(format_delta_ms "$delta_ms")"
    fi

    if [[ "$delta_ms" -gt 0 ]]; then
      budget_breach=1
      echo "verify.run FAIL: budget exceeded (ring=$ring elapsed=${elapsed_seconds}s budget=${budget}s delta=$(format_delta_ms "$delta_ms"))" >&2
    fi
  fi

  [[ "$fail_count" -eq 0 && "$budget_breach" -eq 0 ]]
}

parse_json_flag() {
  local json_mode=0
  local arg
  for arg in "$@"; do
    if [[ "$arg" == "--json" ]]; then
      json_mode=1
      break
    fi
  done
  echo "$json_mode"
}

parse_force_flag() {
  local force_mode=0
  local arg
  for arg in "$@"; do
    if [[ "$arg" == "--force" ]]; then
      force_mode=1
      break
    fi
  done
  echo "$force_mode"
}

iso_to_epoch() {
  local raw="${1:-}"
  python3 - "$raw" <<'PY'
from datetime import datetime, timezone
import sys

raw = (sys.argv[1] or "").strip()
if not raw:
    print(0)
    raise SystemExit(0)
try:
    dt = datetime.fromisoformat(raw.replace("Z", "+00:00"))
except Exception:
    print(0)
    raise SystemExit(0)
if dt.tzinfo is None:
    dt = dt.replace(tzinfo=timezone.utc)
print(int(dt.timestamp()))
PY
}

stabilization_is_active() {
  [[ -f "$STABILIZATION_CONTRACT" ]] || return 1
  local enabled
  enabled="$(yq e -r '.enabled // false' "$STABILIZATION_CONTRACT" 2>/dev/null || echo false)"
  [[ "$enabled" == "true" ]] || return 1

  local start_raw end_raw now_epoch start_epoch end_epoch
  start_raw="$(yq e -r '.window_start // ""' "$STABILIZATION_CONTRACT" 2>/dev/null || true)"
  end_raw="$(yq e -r '.window_end // ""' "$STABILIZATION_CONTRACT" 2>/dev/null || true)"
  now_epoch="$(date +%s)"
  start_epoch="$(iso_to_epoch "$start_raw")"
  end_epoch="$(iso_to_epoch "$end_raw")"

  if [[ "$start_epoch" -eq 0 || "$end_epoch" -eq 0 ]]; then
    return 0
  fi
  [[ "$now_epoch" -ge "$start_epoch" && "$now_epoch" -le "$end_epoch" ]]
}

stabilization_bypass_enabled() {
  local target="$1"
  [[ -f "$STABILIZATION_CONTRACT" ]] || return 1
  while IFS= read -r bypass_target; do
    [[ -n "$bypass_target" ]] || continue
    if [[ "$bypass_target" == "$target" ]]; then
      return 0
    fi
  done < <(yq e -r '.verify_bypass[]?' "$STABILIZATION_CONTRACT" 2>/dev/null || true)
  return 1
}

emit_stabilization_bypass() {
  local target="$1"
  local domain="${2:-}"
  local json_mode="$3"
  local preflight
  preflight="$(yq e -r '.required_preflight_capability // "stability.control.snapshot"' "$STABILIZATION_CONTRACT" 2>/dev/null || echo "stability.control.snapshot")"

  if [[ "$json_mode" == "1" ]]; then
    jq -n \
      --arg status "bypass" \
      --arg target "$target" \
      --arg domain "$domain" \
      --arg preflight "$preflight" \
      --arg contract "$STABILIZATION_CONTRACT" \
      '{status:$status, target:$target, domain:$domain, required_preflight_capability:$preflight, contract:$contract}'
    return
  fi

  echo "verify.$target.run"
  if [[ -n "$domain" ]]; then
    echo "domain: $domain"
  fi
  echo "status: bypass"
  echo "reason: active stabilization mode"
  echo "required_preflight_capability: $preflight"
  echo "contract: $STABILIZATION_CONTRACT"
  echo "override: rerun with --force"
}

resolve_target_kind() {
  local target="$1"
  local norm
  norm="$(normalize_domain "$target")"

  if yq e -r ".profiles[] | select(.agent_id == \"$target\") | .agent_id" "$AGENT_PROFILES" 2>/dev/null | grep -q .; then
    echo "agent"
    return 0
  fi

  if yq e -r ".domains.\"$target\"" "$DOMAIN_PROFILES" 2>/dev/null | grep -qv '^null$'; then
    echo "domain"
    return 0
  fi

  if is_topology_domain "$norm"; then
    echo "domain"
    return 0
  fi

  return 1
}

pack_list() {
  local default_pack
  default_pack="$(yq e -r '.defaults.default_pack // ""' "$AGENT_PROFILES")"
  local core_limit core_started core_review
  core_limit="$(yq e -r '.core_mode.core_count_limit // 0' "$TOPOLOGY")"
  core_started="$(yq e -r '.core_mode.transition_started_at // ""' "$TOPOLOGY")"
  core_review="$(yq e -r '.core_mode.transition_review_required_by // ""' "$TOPOLOGY")"

  echo "verify.pack.list"
  echo "default_pack: ${default_pack:-none}"
  echo "core_mode_limit: $core_limit"
  echo "transition_started_at: $core_started"
  echo "transition_review_required_by: $core_review"
  echo
  echo "agent_profiles:"
  while IFS=$'\t' read -r agent domains; do
    [[ -z "$agent" ]] && continue
    if [[ "$agent" == "$default_pack" ]]; then
      echo "  - $agent (default) domains=[$domains]"
    else
      echo "  - $agent domains=[$domains]"
    fi
  done < <(yq e -r '.profiles[] | [.agent_id, ((.domains // []) | join(","))] | @tsv' "$AGENT_PROFILES" 2>/dev/null)

  echo
  echo "domain_profiles:"
  while IFS= read -r dom; do
    [[ -z "$dom" ]] && continue
    echo "  - $dom"
  done < <(yq e -r '.domains | keys | .[]' "$DOMAIN_PROFILES" 2>/dev/null)
}

pack_explain() {
  local target="$1"
  local kind
  kind="$(resolve_target_kind "$target")" || fail "unknown target: $target"

  local -a domains=()
  local -a gate_ids=()
  local domain

  if [[ "$kind" == "agent" ]]; then
    domains+=("core")
    while IFS= read -r domain; do
      [[ -z "$domain" ]] && continue
      domain="$(normalize_domain "$domain")"
      [[ "$domain" == "core" ]] && continue
      domains+=("$domain")
    done < <(yq e -r ".profiles[] | select(.agent_id == \"$target\") | .domains[]?" "$AGENT_PROFILES")
  else
    domain="$(normalize_domain "$target")"
    domains+=("$domain")
  fi

  mapfile -t domains < <(printf '%s\n' "${domains[@]}" | unique_lines)

  for domain in "${domains[@]}"; do
    if [[ "$domain" == "core" ]]; then
      while IFS= read -r gid; do gate_ids+=("$gid"); done < <(collect_core_gate_ids)
    else
      while IFS= read -r gid; do gate_ids+=("$gid"); done < <(collect_domain_gate_ids "$domain")
    fi
  done

  mapfile -t gate_ids < <(printf '%s\n' "${gate_ids[@]}" | unique_lines)

  echo "verify.pack.explain"
  echo "target: $target"
  echo "kind: $kind"
  echo "domains: $(IFS=,; echo "${domains[*]}")"
  echo "gate_count: ${#gate_ids[@]}"
  echo

  local gid script inline retired
  for gid in "${gate_ids[@]}"; do
    script="$(yq e -r ".gates[] | select(.id == \"$gid\") | .check_script // \"\"" "$REGISTRY" 2>/dev/null || true)"
    inline="$(yq e -r ".gates[] | select(.id == \"$gid\") | .inline // false" "$REGISTRY" 2>/dev/null || echo false)"
    retired="$(yq e -r ".gates[] | select(.id == \"$gid\") | .retired // false" "$REGISTRY" 2>/dev/null || echo false)"
    echo "  - $gid script=${script:-<missing>} inline=$inline retired=$retired"
  done
}

pack_run() {
  local default_pack target json_mode
  default_pack="$(yq e -r '.defaults.default_pack // "core-operator"' "$AGENT_PROFILES")"

  target="${1:-$default_pack}"
  shift || true
  json_mode="$(parse_json_flag "$@")"

  local kind
  kind="$(resolve_target_kind "$target")" || fail "unknown target: $target"

  local -a domains=()
  local -a gate_ids=()
  local domain

  if [[ "$kind" == "agent" ]]; then
    domains+=("core")
    while IFS= read -r domain; do
      [[ -z "$domain" ]] && continue
      domain="$(normalize_domain "$domain")"
      domains+=("$domain")
    done < <(yq e -r ".profiles[] | select(.agent_id == \"$target\") | .domains[]?" "$AGENT_PROFILES")
  else
    domains+=("$(normalize_domain "$target")")
  fi

  mapfile -t domains < <(printf '%s\n' "${domains[@]}" | unique_lines)

  for domain in "${domains[@]}"; do
    if [[ "$domain" == "core" ]]; then
      while IFS= read -r gid; do gate_ids+=("$gid"); done < <(collect_core_gate_ids)
    else
      while IFS= read -r gid; do gate_ids+=("$gid"); done < <(collect_domain_gate_ids "$domain")
    fi
  done

  mapfile -t gate_ids < <(printf '%s\n' "${gate_ids[@]}" | unique_lines)

  if [[ "$json_mode" == "0" ]]; then
    echo "verify.pack.run"
    echo "target: $target"
    echo "kind: $kind"
    echo "domains: $(IFS=,; echo "${domains[*]}")"
    echo "gate_count: ${#gate_ids[@]}"
    echo
  fi

  local ring="${VERIFY_RING_ENTRYPOINT:-standard}"
  case "$ring" in
    instant|standard|deep) ;;
    *) fail "invalid VERIFY_RING_ENTRYPOINT value: $ring" ;;
  esac

  run_gate_ids "$json_mode" "$ring" "${gate_ids[@]}"
}

run_core() {
  local json_mode
  json_mode="$(parse_json_flag "$@")"
  mapfile -t core_ids < <(collect_core_gate_ids)
  if [[ "$json_mode" == "0" ]]; then
    echo "verify.core.run"
    echo "core_gate_count: ${#core_ids[@]}"
    echo
  fi
  run_gate_ids "$json_mode" "instant" "${core_ids[@]}"
}

run_domain() {
  local raw_domain="$1"
  shift || true
  local json_mode force_mode
  json_mode="$(parse_json_flag "$@")"
  force_mode="$(parse_force_flag "$@")"
  local domain
  domain="$(normalize_domain "$raw_domain")"

  if [[ "$force_mode" == "0" ]] && stabilization_is_active && stabilization_bypass_enabled "domain"; then
    emit_stabilization_bypass "domain" "$domain" "$json_mode"
    return 0
  fi

  mapfile -t domain_ids < <(collect_domain_gate_ids "$domain")
  ((${#domain_ids[@]} > 0)) || fail "domain '$raw_domain' resolved to '$domain' with no gates"

  if [[ "$json_mode" == "0" ]]; then
    echo "verify.domain.run"
    echo "domain: $domain"
    echo "gate_count: ${#domain_ids[@]}"
    echo
  fi
  run_gate_ids "$json_mode" "" "${domain_ids[@]}"
}

run_domains() {
  local json_mode force_mode
  json_mode="$(parse_json_flag "$@")"
  force_mode="$(parse_force_flag "$@")"

  local -a input_domains=()
  local arg
  for arg in "$@"; do
    case "$arg" in
      --json|--force) ;;
      *) input_domains+=("$arg") ;;
    esac
  done

  ((${#input_domains[@]} > 0)) || fail "usage: verify-topology domains-run <domain_csv|domain...> [--json] [--force]"

  local -a domains=()
  local token raw normalized
  for raw in "${input_domains[@]}"; do
    IFS=',' read -r -a split <<< "$raw"
    for token in "${split[@]}"; do
      token="$(echo "$token" | xargs)"
      [[ -n "$token" ]] || continue
      normalized="$(normalize_domain "$token")"
      if ! contains_value "$normalized" "${domains[@]:-}"; then
        domains+=("$normalized")
      fi
    done
  done

  ((${#domains[@]} > 0)) || fail "no domains resolved"

  if [[ "$force_mode" == "0" ]] && stabilization_is_active && stabilization_bypass_enabled "domain"; then
    emit_stabilization_bypass "domains" "$(IFS=,; echo "${domains[*]}")" "$json_mode"
    return 0
  fi

  local -a gate_ids=()
  local domain
  for domain in "${domains[@]}"; do
    mapfile -t domain_ids < <(collect_domain_gate_ids "$domain")
    ((${#domain_ids[@]} > 0)) || fail "domain '$domain' resolved with no gates"
    gate_ids+=("${domain_ids[@]}")
  done

  mapfile -t gate_ids < <(printf '%s\n' "${gate_ids[@]}" | unique_lines)

  if [[ "$json_mode" == "0" ]]; then
    echo "verify.domains.run"
    echo "domains: $(IFS=,; echo "${domains[*]}")"
    echo "gate_count: ${#gate_ids[@]}"
    echo
  fi

  run_gate_ids "$json_mode" "" "${gate_ids[@]}"
}

run_release() {
  local json_mode force_mode
  json_mode="$(parse_json_flag "$@")"
  force_mode="$(parse_force_flag "$@")"

  if [[ "$force_mode" == "0" ]] && stabilization_is_active && stabilization_bypass_enabled "release"; then
    emit_stabilization_bypass "release" "" "$json_mode"
    return 0
  fi
  local tmp rc summary start_ms elapsed_ms elapsed_seconds budget budget_ms delta_ms delta_seconds budget_breach status
  start_ms="$(monotonic_ms)"
  tmp="$(mktemp)"
  set +e
  bash "$ROOT/surfaces/verify/drift-gate.sh" >"$tmp" 2>&1
  rc=$?
  set -e
  elapsed_ms=$(( $(monotonic_ms) - start_ms ))
  elapsed_seconds="$(ms_to_seconds "$elapsed_ms")"
  budget="$(ring_budget_seconds "deep")"
  budget_ms=$(( budget * 1000 ))
  delta_ms=$(( elapsed_ms - budget_ms ))
  delta_seconds="$(ms_to_seconds "$delta_ms")"
  budget_breach=0
  if [[ "$delta_ms" -gt 0 ]]; then
    budget_breach=1
  fi

  if [[ "$json_mode" == "1" ]]; then
    summary="$(grep -E '^DRIFT GATE:' "$tmp" | tail -n1 | xargs || true)"
    status="$([[ "$rc" -eq 0 && "$budget_breach" -eq 0 ]] && echo pass || echo fail)"
    if [[ "$budget_breach" -eq 1 ]]; then
      echo "verify.release.run budget exceeded (ring=deep elapsed=${elapsed_seconds}s budget=${budget}s delta=$(format_delta_ms "$delta_ms"))" >&2
    fi
    jq -n \
      --arg status "$status" \
      --arg summary "$summary" \
      --arg mode "core+all-domains" \
      --arg ring "deep" \
      --argjson elapsed_seconds "$elapsed_seconds" \
      --argjson budget_seconds "$budget" \
      --argjson budget_delta_seconds "$delta_seconds" \
      '{status:$status, mode:$mode, summary:$summary, ring:$ring, elapsed_seconds:$elapsed_seconds, budget_seconds:$budget_seconds, budget_delta_seconds:$budget_delta_seconds}'
  else
    cat "$tmp"
    echo "budget: ring=deep elapsed=${elapsed_seconds}s budget=${budget}s delta=$(format_delta_ms "$delta_ms")"
    if [[ "$budget_breach" -eq 1 ]]; then
      echo "verify.release.run FAIL: budget exceeded (ring=deep elapsed=${elapsed_seconds}s budget=${budget}s delta=$(format_delta_ms "$delta_ms"))" >&2
    fi
  fi

  rm -f "$tmp" >/dev/null 2>&1 || true
  [[ "$rc" -eq 0 && "$budget_breach" -eq 0 ]]
}

is_loop_gap_doc_only_set() {
  local -a input_paths=("$@")
  local saw_loop_signal=0
  local p

  ((${#input_paths[@]} > 0)) || return 1

  for p in "${input_paths[@]}"; do
    [[ -n "$p" ]] || continue

    case "$p" in
      mailroom/state/loop-scopes/*|ops/bindings/operational.gaps.yaml|ops/plugins/loops/*)
        saw_loop_signal=1
        ;;
    esac

    case "$p" in
      mailroom/state/loop-scopes/*|docs/planning/*|docs/governance/*|ops/bindings/operational.gaps.yaml|ops/plugins/loops/*)
        ;;
      *)
        return 1
        ;;
    esac
  done

  [[ "$saw_loop_signal" -eq 1 ]]
}

recommend_route() {
  local json_mode=0
  local -a paths=()
  local -a capabilities=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --) shift ;;
      --path)
        [[ $# -ge 2 ]] || fail "--path requires a value"
        paths+=("$2")
        shift 2
        ;;
      --capability)
        [[ $# -ge 2 ]] || fail "--capability requires a value"
        capabilities+=("$2")
        shift 2
        ;;
      --json)
        json_mode=1
        shift
        ;;
      *)
        fail "unknown argument for recommend: $1"
        ;;
    esac
  done

  if [[ "${#paths[@]}" -eq 0 && "${#capabilities[@]}" -eq 0 ]]; then
    while IFS= read -r p; do
      [[ -n "$p" ]] && paths+=("$p")
    done < <(git -C "$ROOT" diff --name-only -- 2>/dev/null || true)
  fi

  declare -A hits=()
  declare -A reasons=()

  while IFS=$'\t' read -r domain trigger_csv prefix_csv; do
    [[ -n "$domain" ]] || continue

    IFS=',' read -r -a triggers <<< "${trigger_csv:-}"
    IFS=',' read -r -a prefixes <<< "${prefix_csv:-}"

    for p in "${paths[@]}"; do
      for t in "${triggers[@]}"; do
        [[ -z "$t" ]] && continue
        if [[ "$p" == *"$t"* ]]; then
          hits["$domain"]=1
          reasons["$domain"]="${reasons[$domain]:-} path:$p"
          break
        fi
      done
    done

    for cap in "${capabilities[@]}"; do
      for pref in "${prefixes[@]}"; do
        [[ -z "$pref" ]] && continue
        if [[ "$cap" == "$pref"* ]]; then
          hits["$domain"]=1
          reasons["$domain"]="${reasons[$domain]:-} capability:$cap"
          break
        fi
      done
    done
  done < <(yq e -r '.domain_metadata[] | [.domain_id, ((.path_triggers // []) | join(",")), ((.capability_prefixes // []) | join(","))] | @tsv' "$TOPOLOGY")

  mapfile -t recommended_domains < <(printf '%s\n' "${!hits[@]}" | awk 'NF' | sort)
  if (( ${#recommended_domains[@]} == 0 )); then
    recommended_domains=("core")
  fi

  # Reduce noisy recommendations for loop/doc-only governance edits.
  if [[ "${#capabilities[@]}" -eq 0 ]] && is_loop_gap_doc_only_set "${paths[@]}"; then
    recommended_domains=("loop_gap")
  fi

  if [[ "$json_mode" == "1" ]]; then
    jq -n \
      --argjson domains "$(printf '%s\n' "${recommended_domains[@]}" | jq -R -s 'split("\n") | map(select(length > 0))')" \
      --argjson paths "$(printf '%s\n' "${paths[@]}" | jq -R -s 'split("\n") | map(select(length > 0))')" \
      --argjson capabilities "$(printf '%s\n' "${capabilities[@]}" | jq -R -s 'split("\n") | map(select(length > 0))')" \
      '{recommended_domains:$domains, input_paths:$paths, input_capabilities:$capabilities}'
  else
    echo "verify.route.recommend"
    if [[ "${#paths[@]}" -gt 0 ]]; then
      echo "paths:"; printf '  - %s\n' "${paths[@]}"
    fi
    if [[ "${#capabilities[@]}" -gt 0 ]]; then
      echo "capabilities:"; printf '  - %s\n' "${capabilities[@]}"
    fi
    echo "recommended_domains: $(IFS=,; echo "${recommended_domains[*]}")"
    for d in "${recommended_domains[@]}"; do
      if [[ "$d" == "core" ]]; then
        echo "  - run: ./bin/ops cap run verify.core.run"
      else
        echo "  - run: ./bin/ops cap run verify.pack.run $d"
      fi
    done
  fi
}

cmd="${1:-}"
case "$cmd" in
  core|core-run)
    shift
    run_core "$@"
    ;;
  domain|domain-run)
    [[ $# -ge 2 ]] || fail "usage: verify-topology domain <domain_id> [--json]"
    domain="$2"
    shift 2
    run_domain "$domain" "$@"
    ;;
  domains|domains-run)
    shift
    run_domains "$@"
    ;;
  release|release-run)
    shift
    run_release "$@"
    ;;
  recommend|route-recommend)
    shift
    recommend_route "$@"
    ;;
  pack-list)
    shift
    pack_list "$@"
    ;;
  pack-explain)
    [[ $# -ge 2 ]] || fail "usage: verify-topology pack-explain <agent_id|domain>"
    target="$2"
    shift 2
    pack_explain "$target" "$@"
    ;;
  pack-run)
    shift
    pack_run "$@"
    ;;
  -h|--help|"")
    usage
    ;;
  *)
    fail "unknown command: $cmd"
    ;;
esac
