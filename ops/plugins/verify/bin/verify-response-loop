#!/usr/bin/env bash
set -euo pipefail

SPINE_ROOT="${SPINE_ROOT:-$HOME/code/agentic-spine}"
CAP_RUNNER="${SPINE_ROOT}/bin/ops"
HISTORY_FILE="${VERIFY_FAILURE_HISTORY_FILE:-$SPINE_ROOT/ops/plugins/verify/state/verify-failure-class-history.ndjson}"
GATE_REGISTRY="${VERIFY_GATE_REGISTRY_FILE:-$SPINE_ROOT/ops/bindings/gate.registry.yaml}"
GAPS_FILE="${VERIFY_GAPS_FILE:-$SPINE_ROOT/ops/bindings/operational.gaps.yaml}"
CURSOR_FILE="${VERIFY_RESPONSE_CURSOR_FILE:-/tmp/verify-response-loop.cursor}"
GATE_REVIEW_QUEUE_FILE="${VERIFY_GATE_REVIEW_QUEUE_FILE:-$SPINE_ROOT/mailroom/outbox/alerts/verify-gate-review-queue.ndjson}"
EMAIL_INTENT_DIR="${VERIFY_RESPONSE_EMAIL_INTENT_DIR:-$SPINE_ROOT/mailroom/outbox/alerts/email-intents}"
DEFAULT_PARENT_LOOP="${VERIFY_RESPONSE_PARENT_LOOP:-LOOP-SPINE-SELF-HEALING-E2E-20260301}"
RECOVERY_DISPATCH_BIN="${VERIFY_RECOVERY_DISPATCH_BIN:-$SPINE_ROOT/ops/plugins/recovery/bin/recovery-dispatch}"

fail() {
  echo "verify.response.loop FAIL: $*" >&2
  exit 1
}

enqueue_email_intent() {
  local domain_id="$1"
  local severity="$2"
  local title="$3"
  local summary="$4"
  local intent_id created_at intent_file
  intent_id="email-intent-$(date -u +%Y%m%dT%H%M%SZ)-${RANDOM}"
  created_at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  intent_file="${EMAIL_INTENT_DIR}/${intent_id}.yaml"
  mkdir -p "${EMAIL_INTENT_DIR}"
  cat >"${intent_file}" <<INTENT
intent_id: "${intent_id}"
created_at: "${created_at}"
domain_id: "${domain_id}"
severity: "${severity}"
title: "${title}"
summary: |-
$(printf '%s\n' "${summary}" | sed 's/^/  /')
suggested_recipient: "alerts@spine.ronny.works"
source_alert: "verify-response-loop"
flush_status: pending
INTENT
}

run_recovery_dispatch() {
  local gate_id="$1"
  local failure_class="$2"
  local out

  if [[ ! -x "$RECOVERY_DISPATCH_BIN" ]]; then
    jq -cn \
      --arg gid "$gate_id" \
      --arg fc "$failure_class" \
      '{gate_id:$gid,failure_class:$fc,matched:false,recovered:false,escalate:false,suppressed:false,attempt:0,message:"recovery-dispatch unavailable"}'
    return 0
  fi

  out="$("$RECOVERY_DISPATCH_BIN" --gate-id "$gate_id" --failure-class "$failure_class" --json 2>/dev/null || true)"
  if jq -e . >/dev/null 2>&1 <<<"$out"; then
    printf '%s\n' "$out"
  else
    jq -cn \
      --arg gid "$gate_id" \
      --arg fc "$failure_class" \
      '{gate_id:$gid,failure_class:$fc,matched:false,recovered:false,escalate:false,suppressed:false,attempt:0,message:"recovery-dispatch returned invalid output"}'
  fi
}

queue_gap_candidate() {
  local gate_id="$1"
  local failure_class="$2"
  local target_file="$3"
  local existing_open gate_name gate_ring gate_doc

  existing_open="$(
    GID="$gate_id" yq e '[.gaps[] | select(.status == "open" and (.discovered_by // "") == "verify-response-loop" and (.recovery_gate_id // "") == strenv(GID))] | length' "$GAPS_FILE" 2>/dev/null || echo 0
  )"
  if [[ "$existing_open" =~ ^[0-9]+$ ]] && (( existing_open > 0 )); then
    return 0
  fi

  gate_name="$(
    GID="$gate_id" yq e -r '.gates[] | select(.id == strenv(GID)) | .name // ""' "$GATE_REGISTRY" 2>/dev/null | head -n1
  )"
  gate_ring="$(
    GID="$gate_id" yq e -r '.gates[] | select(.id == strenv(GID)) | .ring // "standard"' "$GATE_REGISTRY" 2>/dev/null | head -n1
  )"
  gate_doc="$(
    GID="$gate_id" yq e -r '.gates[] | select(.id == strenv(GID)) | .check_script // ""' "$GATE_REGISTRY" 2>/dev/null | head -n1
  )"

  [[ -n "$gate_doc" ]] || gate_doc="ops/plugins/verify/bin/verify-run"
  [[ -n "$gate_name" ]] || gate_name="Unknown gate"
  [[ -n "$gate_ring" ]] || gate_ring="standard"

  printf '%s\t%s\t%s\t%s\t%s\n' "$gate_id" "$failure_class" "$gate_name" "$gate_ring" "$gate_doc" >> "$target_file"
}

[[ -x "$CAP_RUNNER" ]] || fail "missing cap runner: $CAP_RUNNER"
[[ -f "$HISTORY_FILE" ]] || fail "missing verify failure history: $HISTORY_FILE"
[[ -f "$GATE_REGISTRY" ]] || fail "missing gate registry: $GATE_REGISTRY"
[[ -f "$GAPS_FILE" ]] || fail "missing gaps file: $GAPS_FILE"
command -v jq >/dev/null 2>&1 || fail "missing dependency: jq"
command -v yq >/dev/null 2>&1 || fail "missing dependency: yq"

latest_line="$(tail -n 1 "$HISTORY_FILE" 2>/dev/null || true)"
if [[ -z "$latest_line" ]]; then
  echo "verify.response.loop: no history entries"
  echo "0 freshness auto-reconciled, 0 gaps opened, 0 gate bugs flagged"
  exit 0
fi

if ! jq -e . >/dev/null 2>&1 <<<"$latest_line"; then
  fail "latest history entry is not valid JSON"
fi

fingerprint="$(jq -r '[.timestamp_utc // "", .run_key // "", .scope // ""] | join("|")' <<<"$latest_line")"
last_fingerprint="$(cat "$CURSOR_FILE" 2>/dev/null || true)"
if [[ -n "$last_fingerprint" && "$last_fingerprint" == "$fingerprint" ]]; then
  echo "verify.response.loop: already processed latest run ($fingerprint)"
  echo "0 freshness auto-reconciled, 0 gaps opened, 0 gate bugs flagged"
  exit 0
fi

run_key="$(jq -r '.run_key // "manual"' <<<"$latest_line")"
scope="$(jq -r '.scope // "unknown"' <<<"$latest_line")"
timestamp_utc="$(jq -r '.timestamp_utc // ""' <<<"$latest_line")"

mapfile -t freshness_ids < <(jq -r '.failure_class.freshness[]?' <<<"$latest_line")
mapfile -t deterministic_ids < <(jq -r '.failure_class.deterministic[]?' <<<"$latest_line")
mapfile -t gate_bug_ids < <(jq -r '.failure_class.gate_bug[]?' <<<"$latest_line")

freshness_reconciled=0
gaps_opened=0
gate_bugs_flagged=0
gap_candidates=0
escalations_notified=0
gap_candidates_file="$(mktemp)"
cleanup_candidates() { rm -f "$gap_candidates_file"; }
trap cleanup_candidates EXIT

if ((${#freshness_ids[@]} > 0)); then
  if "$CAP_RUNNER" cap run verify.freshness.reconcile >/dev/null 2>&1; then
    freshness_reconciled="${#freshness_ids[@]}"
  else
    echo "verify.response.loop WARN: verify.freshness.reconcile failed for run_key=$run_key" >&2
    for gid in "${freshness_ids[@]}"; do
      [[ -n "$gid" ]] || continue
      recovery_result="$(run_recovery_dispatch "$gid" "freshness")"
      recovered="$(jq -r '.recovered // false' <<<"$recovery_result")"
      if [[ "$recovered" == "true" ]]; then
        freshness_reconciled=$((freshness_reconciled + 1))
      else
        queue_gap_candidate "$gid" "freshness" "$gap_candidates_file"
        gap_candidates=$((gap_candidates + 1))
      fi
    done

    enqueue_email_intent \
      "verify-response-loop" \
      "warn" \
      "verify.freshness.reconcile failed in response loop" \
      "run_key=${run_key} scope=${scope} freshness_gate_count=${#freshness_ids[@]}: scheduled reconcile failed from verify-response-loop; recovery-dispatch fallback attempted."
  fi
fi

if ((${#deterministic_ids[@]} > 0)); then
  for gid in "${deterministic_ids[@]}"; do
    [[ -n "$gid" ]] || continue
    recovery_result="$(run_recovery_dispatch "$gid" "deterministic")"
    recovered="$(jq -r '.recovered // false' <<<"$recovery_result")"
    matched="$(jq -r '.matched // false' <<<"$recovery_result")"
    escalate="$(jq -r '.escalate // false' <<<"$recovery_result")"
    action_type="$(jq -r '.action_type // ""' <<<"$recovery_result")"
    action_id="$(jq -r '.action_id // ""' <<<"$recovery_result")"
    recovery_message="$(jq -r '.message // ""' <<<"$recovery_result")"
    if [[ "$recovered" == "true" ]]; then
      continue
    fi
    if [[ "$matched" == "true" && "$escalate" == "true" ]]; then
      enqueue_email_intent \
        "verify-response-loop" \
        "incident" \
        "Deterministic gate recovery escalated: ${gid}" \
        "run_key=${run_key} scope=${scope} gate_id=${gid} action_id=${action_id} action_type=${action_type} message=${recovery_message}"
      escalations_notified=$((escalations_notified + 1))
    fi
    queue_gap_candidate "$gid" "deterministic" "$gap_candidates_file"
    gap_candidates=$((gap_candidates + 1))
  done
fi

if [[ -s "$gap_candidates_file" ]]; then
  batch_file="$(mktemp)"
  cleanup_batch() { rm -f "$batch_file"; cleanup_candidates; }
  trap cleanup_batch EXIT

  echo "gaps:" > "$batch_file"
  while IFS=$'\t' read -r gid failure_class gate_name gate_ring gate_doc; do
    [[ -n "$gid" ]] || continue
    cat >> "$batch_file" <<EOF
  - id: auto
    type: runtime-bug
    severity: medium
    discovered_by: verify-response-loop
    recovery_gate_id: $gid
    doc: $gate_doc
    description: |
      Auto-opened by verify-response-loop for gate $gid.
      run_key: $run_key
      timestamp_utc: $timestamp_utc
      scope: $scope
      gate_name: $gate_name
      gate_ring: $gate_ring
      failure_class: $failure_class
      source_history: ops/plugins/verify/state/verify-failure-class-history.ndjson
EOF
    gaps_opened=$((gaps_opened + 1))
  done < "$gap_candidates_file"

  if (( gaps_opened > 0 )); then
    if ! "$CAP_RUNNER" cap run gaps.file -- --batch "$batch_file" --parent-loop "$DEFAULT_PARENT_LOOP" >/dev/null 2>&1; then
      echo "verify.response.loop WARN: gaps.file batch failed for run_key=$run_key" >&2
      enqueue_email_intent \
        "verify-response-loop" \
        "incident" \
        "verify-response-loop failed to auto-file deterministic gaps" \
        "run_key=${run_key} scope=${scope} attempted_gaps=${gaps_opened} parent_loop=${DEFAULT_PARENT_LOOP}."
      gaps_opened=0
    fi
  fi

  rm -f "$batch_file"
fi

if ((${#gate_bug_ids[@]} > 0)); then
  mkdir -p "$(dirname "$GATE_REVIEW_QUEUE_FILE")"
  for gid in "${gate_bug_ids[@]}"; do
    [[ -n "$gid" ]] || continue
    jq -cn \
      --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
      --arg run_key "$run_key" \
      --arg scope "$scope" \
      --arg gate_id "$gid" \
      --arg source_history "$HISTORY_FILE" \
      '{timestamp_utc:$ts,run_key:$run_key,scope:$scope,gate_id:$gate_id,classification:"gate_bug",source_history:$source_history}' >> "$GATE_REVIEW_QUEUE_FILE"
    gate_bugs_flagged=$((gate_bugs_flagged + 1))
  done
fi

if (( gaps_opened > 0 )); then
  enqueue_email_intent \
    "verify-response-loop" \
    "incident" \
    "Verify failures auto-filed as gaps" \
    "run_key=${run_key} scope=${scope} gaps_opened=${gaps_opened} parent_loop=${DEFAULT_PARENT_LOOP}."
fi

if (( gate_bugs_flagged > 0 )); then
  enqueue_email_intent \
    "verify-response-loop" \
    "warn" \
    "Gate bug classifications queued for review" \
    "run_key=${run_key} scope=${scope} gate_bugs_flagged=${gate_bugs_flagged} queue_file=${GATE_REVIEW_QUEUE_FILE}."
fi

if (( escalations_notified > 0 )); then
  enqueue_email_intent \
    "verify-response-loop" \
    "incident" \
    "Recovery escalations detected in verify-response-loop" \
    "run_key=${run_key} scope=${scope} escalations_notified=${escalations_notified}."
fi

"$CAP_RUNNER" cap run gaps.auto.close >/dev/null 2>&1 || true

printf '%s\n' "$fingerprint" > "$CURSOR_FILE"
echo "${freshness_reconciled} freshness auto-reconciled, ${gaps_opened} gaps opened, ${gate_bugs_flagged} gate bugs flagged, ${escalations_notified} escalations notified"
