#!/usr/bin/env bash
# media.backup.restore â€” restore media config-state from governed backups
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "$0")/../../../.." && pwd)}"
VM_BINDING="$ROOT/ops/bindings/vm.lifecycle.yaml"
SERVICES_HEALTH="$ROOT/ops/bindings/services.health.yaml"
BACKUP_ROOT="/mnt/docker/backups/media-config"

usage() {
  cat <<'USAGE'
media.backup.restore - Restore media config-state from backup

Args:
  --vm HOST            Required: download-stack|streaming-stack
  --service NAME       Required: media service id (radarr, sonarr, jellyfin, etc.)
  --backup-file PATH   Optional: explicit backup archive path on target VM
  --retention DAYS     Optional: backup lookup window (default: 14)
  --dry-run            Preview restore plan without mutation
USAGE
}

stop() {
  echo "FAIL: $*" >&2
  exit 1
}

VM=""
SERVICE=""
BACKUP_FILE=""
RETENTION_DAYS=14
DRY_RUN=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --) shift ;;
    --vm) VM="${2:-}"; shift 2 ;;
    --service) SERVICE="${2:-}"; shift 2 ;;
    --backup-file) BACKUP_FILE="${2:-}"; shift 2 ;;
    --retention) RETENTION_DAYS="${2:-}"; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) stop "unknown argument: $1" ;;
  esac
done

[[ -n "$VM" ]] || stop "--vm is required"
[[ -n "$SERVICE" ]] || stop "--service is required"
[[ "$RETENTION_DAYS" =~ ^[0-9]+$ ]] || stop "--retention must be numeric"

case "$VM" in
  download-stack|streaming-stack) ;;
  *) stop "--vm must be download-stack or streaming-stack" ;;
esac

command -v yq >/dev/null 2>&1 || stop "missing dependency: yq"
command -v ssh >/dev/null 2>&1 || stop "missing dependency: ssh"
command -v curl >/dev/null 2>&1 || stop "missing dependency: curl"

map_service_paths() {
  local vm="$1"
  local service="$2"
  case "$service" in
    radarr|sonarr|lidarr|prowlarr|sabnzbd|qbittorrent|trailarr)
      [[ "$vm" == "download-stack" ]] || return 1
      PRIMARY_PATH="/mnt/docker/volumes/${service}/config"
      APPDATA_PATH="/opt/appdata/${service}"
      ;;
    jellyfin|jellyseerr|bazarr)
      [[ "$vm" == "streaming-stack" ]] || return 1
      PRIMARY_PATH="/mnt/docker/volumes/${service}/config"
      APPDATA_PATH="/opt/appdata/${service}"
      ;;
    navidrome)
      [[ "$vm" == "streaming-stack" ]] || return 1
      PRIMARY_PATH="/mnt/docker/volumes/navidrome/data"
      APPDATA_PATH="/opt/appdata/navidrome"
      ;;
    homarr)
      [[ "$vm" == "streaming-stack" ]] || return 1
      PRIMARY_PATH="/mnt/docker/volumes/homarr/configs"
      APPDATA_PATH="/opt/appdata/homarr"
      ;;
    *)
      return 1
      ;;
  esac
}

PRIMARY_PATH=""
APPDATA_PATH=""
map_service_paths "$VM" "$SERVICE" || stop "service '$SERVICE' is not restore-mapped for vm '$VM'"
container_name="$SERVICE"

get_vm_ssh_ref() {
  local vm="$1"
  local target user
  target="$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_target // .hostname // \"\"" "$VM_BINDING" 2>/dev/null || true)"
  user="$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_user // \"\"" "$VM_BINDING" 2>/dev/null || true)"
  [[ -n "$target" && "$target" != "null" ]] || return 1
  if [[ -n "$user" && "$user" != "null" ]]; then
    echo "${user}@${target}"
  else
    echo "$target"
  fi
}

ssh_ref="$(get_vm_ssh_ref "$VM" 2>/dev/null || true)"
[[ -n "$ssh_ref" ]] || stop "no ssh target found for vm '$VM'"

mapfile -t backups < <(
  ssh -o BatchMode=yes -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$ssh_ref" \
    "find '$BACKUP_ROOT' -maxdepth 1 -type f -name '${VM}-config-*.tar.gz' -mtime -${RETENTION_DAYS} -print | sort -r" 2>/dev/null || true
)

if [[ "${#backups[@]}" -eq 0 ]]; then
  stop "no backups found on $VM within ${RETENTION_DAYS} day(s)"
fi

selected_backup="$BACKUP_FILE"
if [[ -z "$selected_backup" ]]; then
  selected_backup="${backups[0]}"
fi

if ! ssh -o BatchMode=yes -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$ssh_ref" \
  "test -f '$selected_backup'" >/dev/null 2>&1; then
  stop "selected backup does not exist on $VM: $selected_backup"
fi

cat <<INFO
media.backup.restore
====================
vm: $VM
service: $SERVICE
primary_path: $PRIMARY_PATH
appdata_path: $APPDATA_PATH
selected_backup: $selected_backup
retention_days: $RETENTION_DAYS
dry_run: $( [[ "$DRY_RUN" -eq 1 ]] && echo true || echo false )

available_backups:
INFO
for b in "${backups[@]}"; do
  echo "  - $b"
done

if [[ "$DRY_RUN" -eq 1 ]]; then
  echo
  echo "DRY_RUN: would stop '$container_name', restore '$PRIMARY_PATH' (+ optional '$APPDATA_PATH') from '$selected_backup', then restart."
  exit 0
fi

if ! ssh -o BatchMode=yes -o ConnectTimeout=15 -o StrictHostKeyChecking=no "$ssh_ref" bash -s -- \
    "$selected_backup" "$container_name" "$PRIMARY_PATH" "$APPDATA_PATH" <<'REMOTE'
set -euo pipefail
backup_file="$1"
container_name="$2"
primary_path="$3"
appdata_path="$4"

docker_cmd="docker"
if ! docker ps >/dev/null 2>&1; then
  if command -v sudo >/dev/null 2>&1 && sudo -n docker ps >/dev/null 2>&1; then
    docker_cmd="sudo -n docker"
  fi
fi

primary_rel="${primary_path#/}"
appdata_rel="${appdata_path#/}"

if ! tar -tzf "$backup_file" | grep -q "^${primary_rel}"; then
  echo "backup archive missing required path: $primary_rel" >&2
  exit 2
fi

FS_PREFIX=()
if [[ -w "$(dirname "$primary_path")" ]]; then
  :
elif command -v sudo >/dev/null 2>&1 && sudo -n true >/dev/null 2>&1; then
  FS_PREFIX=(sudo -n)
else
  echo "filesystem restore requires sudo and sudo -n is unavailable" >&2
  exit 3
fi

if $docker_cmd ps --format '{{.Names}}' | grep -Fxq "$container_name"; then
  $docker_cmd stop "$container_name" >/dev/null 2>&1 || true
fi

"${FS_PREFIX[@]}" rm -rf "$primary_path"
"${FS_PREFIX[@]}" mkdir -p "$(dirname "$primary_path")"
"${FS_PREFIX[@]}" tar -xzf "$backup_file" -C / "$primary_rel"

if [[ -n "$appdata_path" ]] && tar -tzf "$backup_file" | grep -q "^${appdata_rel}"; then
  "${FS_PREFIX[@]}" rm -rf "$appdata_path"
  "${FS_PREFIX[@]}" mkdir -p "$(dirname "$appdata_path")"
  "${FS_PREFIX[@]}" tar -xzf "$backup_file" -C / "$appdata_rel"
fi

$docker_cmd start "$container_name" >/dev/null 2>&1 || true
REMOTE
then
  stop "remote restore failed on $VM"
fi

endpoint_url="$(yq e -r ".endpoints[] | select(.id == \"$SERVICE\") | .url // \"\"" "$SERVICES_HEALTH" | head -n1)"
endpoint_expect="$(yq e -r ".endpoints[] | select(.id == \"$SERVICE\") | .expect // 200" "$SERVICES_HEALTH" | head -n1)"
if [[ -n "$endpoint_url" && "$endpoint_url" != "null" ]]; then
  [[ "$endpoint_expect" =~ ^[0-9]+$ ]] || endpoint_expect=200
  health_code="$(curl -fsS -o /dev/null -w '%{http_code}' --max-time 12 "$endpoint_url" 2>/dev/null || true)"
  if [[ "$health_code" != "$endpoint_expect" ]]; then
    stop "post-restore health check failed for $SERVICE (expected ${endpoint_expect}, got ${health_code:-none})"
  fi
  echo "health_check: PASS (${SERVICE} http=${health_code})"
else
  echo "health_check: SKIP (no services.health endpoint for ${SERVICE})"
fi

echo "OK: restore completed for ${SERVICE} on ${VM}"
