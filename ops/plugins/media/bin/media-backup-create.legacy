#!/usr/bin/env bash
# media.backup.create — create media config-state snapshots (non-payload)
set -euo pipefail

ROOT="${SPINE_ROOT:-$(cd "$(dirname "$0")/../../../.." && pwd)}"
VM_BINDING="$ROOT/ops/bindings/vm.lifecycle.yaml"
BACKUP_ROOT="/mnt/docker/backups/media-config"

usage() {
  cat <<'USAGE'
media.backup.create — Create media config-state snapshots

Args:
  --vm HOST         Backup only this VM (download-stack|streaming-stack)
  --dry-run         Show plan without mutation
  --retention DAYS  Keep snapshots for N days (default: 14)

Notes:
  - Includes: /mnt/docker/volumes + /opt/appdata service config metadata
  - Excludes: /mnt/media payload and regenerable cache lanes
USAGE
}

VM_FILTER=""
DRY_RUN=0
RETENTION_DAYS=14

while [[ $# -gt 0 ]]; do
  case "$1" in
    --vm) VM_FILTER="${2:-}"; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    --retention) RETENTION_DAYS="${2:-}"; shift 2 ;;
    -h|--help) usage; exit 0 ;;
    *) echo "FAIL: unknown arg: $1" >&2; usage >&2; exit 1 ;;
  esac
done

[[ "$RETENTION_DAYS" =~ ^[0-9]+$ ]] || { echo "FAIL: --retention must be numeric" >&2; exit 1; }
command -v yq >/dev/null 2>&1 || { echo "MISSING_DEP: yq" >&2; exit 2; }
command -v ssh >/dev/null 2>&1 || { echo "MISSING_DEP: ssh" >&2; exit 2; }

get_vm_ssh_ref() {
  local vm="$1"
  local target user
  target="$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_target // .hostname // \"\"" "$VM_BINDING" 2>/dev/null || true)"
  user="$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_user // \"\"" "$VM_BINDING" 2>/dev/null || true)"
  [[ -n "$target" && "$target" != "null" ]] || return 1
  if [[ -n "$user" && "$user" != "null" ]]; then
    echo "${user}@${target}"
  else
    echo "$target"
  fi
}

DOWNLOAD_PATHS=(
  "/mnt/docker/volumes/radarr/config"
  "/mnt/docker/volumes/sonarr/config"
  "/mnt/docker/volumes/lidarr/config"
  "/mnt/docker/volumes/prowlarr/config"
  "/mnt/docker/volumes/sabnzbd/config"
  "/mnt/docker/volumes/qbittorrent/config"
  "/mnt/docker/volumes/recyclarr/config"
  "/mnt/docker/volumes/flaresolverr/config"
  "/mnt/docker/volumes/trailarr/config"
  "/mnt/docker/volumes/autopulse"
  "/opt/appdata/radarr"
  "/opt/appdata/sonarr"
  "/opt/appdata/lidarr"
  "/opt/appdata/prowlarr"
  "/opt/appdata/sabnzbd"
  "/opt/appdata/qbittorrent"
  "/opt/appdata/trailarr"
)

STREAMING_PATHS=(
  "/mnt/docker/volumes/jellyfin/config"
  "/mnt/docker/volumes/navidrome/data"
  "/mnt/docker/volumes/jellyseerr/config"
  "/mnt/docker/volumes/bazarr/config"
  "/mnt/docker/volumes/homarr/configs"
  "/opt/appdata/jellyfin"
  "/opt/appdata/navidrome"
  "/opt/appdata/jellyseerr"
  "/opt/appdata/bazarr"
)

TIMESTAMP="$(date +%Y%m%d-%H%M%S)"

backup_vm_configs() {
  local vm="$1"
  shift
  local paths=("$@")
  local ssh_ref backup_file prune_glob

  echo ""
  echo "--- $vm ---"
  ssh_ref="$(get_vm_ssh_ref "$vm" 2>/dev/null || true)"
  if [[ -z "$ssh_ref" ]]; then
    echo "FAIL: no ssh target found for $vm in vm.lifecycle binding"
    return 1
  fi

  backup_file="${BACKUP_ROOT}/${vm}-config-${TIMESTAMP}.tar.gz"
  prune_glob="${vm}-config-*.tar.gz"

  if [[ "$DRY_RUN" -eq 1 ]]; then
    echo "DRY_RUN: would include candidate paths:"
    for p in "${paths[@]}"; do
      echo "  - $p"
    done
    echo "DRY_RUN: payload exclusions:"
    echo "  - /mnt/media"
    echo "  - */cache"
    echo "  - */tmp"
    echo "DRY_RUN: output archive: $backup_file"
    return 0
  fi

if ! ssh -o BatchMode=yes -o ConnectTimeout=12 "$ssh_ref" bash -s -- \
      "$BACKUP_ROOT" "$backup_file" "$RETENTION_DAYS" "$prune_glob" "${paths[@]}" <<'REMOTE'
set -euo pipefail
backup_root="$1"
backup_file="$2"
retention_days="$3"
prune_glob="$4"
shift 4
paths=("$@")

FS_PREFIX=()
if mkdir -p "$backup_root" 2>/dev/null; then
  :
elif command -v sudo >/dev/null 2>&1 && sudo -n true >/dev/null 2>&1; then
  FS_PREFIX=(sudo -n)
  "${FS_PREFIX[@]}" mkdir -p "$backup_root"
else
  echo "cannot create backup root '$backup_root' (no sudo fallback)" >&2
  exit 2
fi

# If the path already existed but is not writable, escalate filesystem ops.
if ! test -w "$backup_root"; then
  if command -v sudo >/dev/null 2>&1 && sudo -n true >/dev/null 2>&1; then
    FS_PREFIX=(sudo -n)
  else
    echo "backup root '$backup_root' not writable and sudo unavailable" >&2
    exit 2
  fi
fi

include_paths=()
for p in "${paths[@]}"; do
  if [[ -e "$p" ]]; then
    include_paths+=("${p#/}")
  elif [[ "${#FS_PREFIX[@]}" -gt 0 ]] && "${FS_PREFIX[@]}" test -e "$p"; then
    include_paths+=("${p#/}")
  fi
done

if [[ "${#include_paths[@]}" -eq 0 ]]; then
  echo "no existing include paths found on host" >&2
  exit 3
fi

"${FS_PREFIX[@]}" tar -czf "$backup_file" -C / "${include_paths[@]}"
"${FS_PREFIX[@]}" find "$backup_root" -maxdepth 1 -type f -name "$prune_glob" -mtime +"$retention_days" -delete || true
"${FS_PREFIX[@]}" ls -lh "$backup_file"
REMOTE
  then
    echo "FAIL: backup creation failed on $vm"
    return 1
  fi

  return 0
}

echo "media.backup.create"
echo "==================="
echo "timestamp: $TIMESTAMP"
echo "retention_days: $RETENTION_DAYS"
echo "backup_root: $BACKUP_ROOT"
echo "dry_run: $([[ "$DRY_RUN" -eq 1 ]] && echo true || echo false)"

ERRORS=0

if [[ -z "$VM_FILTER" || "$VM_FILTER" == "download-stack" ]]; then
  backup_vm_configs "download-stack" "${DOWNLOAD_PATHS[@]}" || ERRORS=$((ERRORS + 1))
fi

if [[ -z "$VM_FILTER" || "$VM_FILTER" == "streaming-stack" ]]; then
  backup_vm_configs "streaming-stack" "${STREAMING_PATHS[@]}" || ERRORS=$((ERRORS + 1))
fi

if [[ $ERRORS -gt 0 ]]; then
  echo ""
  echo "FAIL: $ERRORS VM(s) had backup errors"
  exit 1
fi

echo ""
echo "OK: config-state backups created"
exit 0
