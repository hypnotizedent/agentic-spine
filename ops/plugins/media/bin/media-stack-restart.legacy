#!/usr/bin/env bash
# media.stack.restart — Restart docker compose stacks on media VMs
#
# Usage:
#   ./bin/ops cap run media.stack.restart
#   ./bin/ops cap run media.stack.restart --vm download-stack
#   ./bin/ops cap run media.stack.restart --vm streaming-stack
#   ./bin/ops cap run media.stack.restart --dry-run
#
# Contract:
# - Reads VM targets from ops/bindings/docker.compose.targets.yaml
# - Executes: docker compose down && docker compose up -d
# - Requires SSH access to target VMs
# - Generates receipt with before/after container states

set -euo pipefail

ROOT="$(cd "$(dirname "$0")/../../../.." && pwd)"
COMPOSE_BINDING="$ROOT/ops/bindings/docker.compose.targets.yaml"
VM_BINDING="$ROOT/ops/bindings/vm.lifecycle.yaml"

usage() {
  cat <<'USAGE'
media.stack.restart — Restart docker compose stacks on media VMs

Args:
  --vm HOST         Restart only this VM (download-stack|streaming-stack)
  --dry-run         Show what would be done without executing
  --timeout SEC     SSH connection timeout (default: 30)

Examples:
  ./bin/ops cap run media.stack.restart --vm download-stack
  ./bin/ops cap run media.stack.restart --dry-run
USAGE
}

VM_FILTER=""
DRY_RUN=false
TIMEOUT_SEC=30

while [[ $# -gt 0 ]]; do
  case "$1" in
    --vm)
      VM_FILTER="${2:-}"; shift 2 ;;
    --dry-run)
      DRY_RUN=true; shift ;;
    --timeout)
      TIMEOUT_SEC="${2:-}"; shift 2 ;;
    -h|--help)
      usage; exit 0 ;;
    *)
      echo "FAIL: unknown arg: $1" >&2; usage >&2; exit 1 ;;
  esac
done

command -v yq >/dev/null 2>&1 || { echo "MISSING_DEP: yq" >&2; exit 2; }
command -v ssh >/dev/null 2>&1 || { echo "MISSING_DEP: ssh" >&2; exit 2; }

# Media VMs only
MEDIA_VMS=("download-stack" "streaming-stack")

get_vm_ssh_ref() {
  local vm="$1"
  local target user

  target=$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_target // .hostname // \"\"" "$VM_BINDING" 2>/dev/null || echo "")
  user=$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_user // \"\"" "$VM_BINDING" 2>/dev/null || echo "")

  if [[ -z "$target" || "$target" == "null" ]]; then
    echo ""
    return 1
  fi

  if [[ -n "$user" && "$user" != "null" ]]; then
    echo "${user}@${target}"
  else
    echo "$target"
  fi
}

get_compose_path() {
  local vm="$1"
  yq -r ".targets[\"$vm\"].stacks[0].path // \"\"" "$COMPOSE_BINDING" 2>/dev/null || echo ""
}

restart_vm_stack() {
  local vm="$1"
  local compose_path
  local ssh_ref

  compose_path=$(get_compose_path "$vm")
  if [[ -z "$compose_path" ]]; then
    echo "FAIL: no compose path found for $vm"
    return 1
  fi

  echo ""
  echo "--- $vm ---"
  echo "compose_path: $compose_path"
  ssh_ref=$(get_vm_ssh_ref "$vm" 2>/dev/null || true)
  if [[ -z "$ssh_ref" ]]; then
    echo "FAIL: no ssh target found for $vm in vm.lifecycle binding"
    return 1
  fi

  if $DRY_RUN; then
    echo "DRY_RUN: would execute:"
    echo "  ssh $ssh_ref 'cd $compose_path && docker compose down && docker compose up -d'"
    return 0
  fi

  # Get before state
  echo "BEFORE:"
  before_out=$(ssh -o BatchMode=yes -o ConnectTimeout="$TIMEOUT_SEC" "$ssh_ref" "docker ps --format 'table {{.Names}}\t{{.Status}}'" 2>&1 || true)
  if echo "$before_out" | grep -qi "permission denied while trying to connect to the docker api"; then
    before_out=$(ssh -o BatchMode=yes -o ConnectTimeout="$TIMEOUT_SEC" "$ssh_ref" "sudo -n docker ps --format 'table {{.Names}}\t{{.Status}}'" 2>&1 || true)
  fi
  if echo "$before_out" | grep -qi "^sudo: "; then
    echo "FAIL: docker access denied on $vm (sudo fallback unavailable)"
    return 1
  fi
  echo "$before_out"

  # Restart
  echo ""
  echo "RESTARTING..."
  restart_out=$(ssh -o BatchMode=yes -o ConnectTimeout="$TIMEOUT_SEC" "$ssh_ref" "cd $compose_path && docker compose down && docker compose up -d" 2>&1 || true)
  if echo "$restart_out" | grep -qi "permission denied while trying to connect to the docker api"; then
    restart_out=$(ssh -o BatchMode=yes -o ConnectTimeout="$TIMEOUT_SEC" "$ssh_ref" "cd $compose_path && sudo -n docker compose down && sudo -n docker compose up -d" 2>&1 || true)
  fi
  if echo "$restart_out" | grep -qi "^sudo: "; then
    echo "FAIL: restart failed on $vm (docker/sudo access unavailable)"
    return 1
  fi
  echo "$restart_out"

  # Get after state
  echo ""
  echo "AFTER:"
  after_out=$(ssh -o BatchMode=yes -o ConnectTimeout="$TIMEOUT_SEC" "$ssh_ref" "docker ps --format 'table {{.Names}}\t{{.Status}}'" 2>&1 || true)
  if echo "$after_out" | grep -qi "permission denied while trying to connect to the docker api"; then
    after_out=$(ssh -o BatchMode=yes -o ConnectTimeout="$TIMEOUT_SEC" "$ssh_ref" "sudo -n docker ps --format 'table {{.Names}}\t{{.Status}}'" 2>&1 || true)
  fi
  if echo "$after_out" | grep -qi "^sudo: "; then
    echo "FAIL: post-restart status unavailable on $vm (docker/sudo access unavailable)"
    return 1
  fi
  echo "$after_out"

  return 0
}

echo "media.stack.restart"
echo "==================="
echo "vm_filter: ${VM_FILTER:-all}"
echo "dry_run: $DRY_RUN"

ERRORS=0

for vm in "${MEDIA_VMS[@]}"; do
  if [[ -n "$VM_FILTER" && "$vm" != "$VM_FILTER" ]]; then
    continue
  fi
  restart_vm_stack "$vm" || ERRORS=$((ERRORS + 1))
done

if [[ $ERRORS -gt 0 ]]; then
  echo ""
  echo "FAIL: $ERRORS VM(s) had errors"
  exit 1
fi

echo ""
echo "OK: all requested VMs restarted"
exit 0
