#!/usr/bin/env bash
# media.nfs.verify — Verify NFS mount health and free space for media VMs
#
# Usage:
#   ./bin/ops cap run media.nfs.verify
#   ./bin/ops cap run media.nfs.verify --vm download-stack
#   ./bin/ops cap run media.nfs.verify --json
#
# Contract:
# - Verifies NFS mount from pve:/media is present on both VMs
# - Checks download-stack has RW, streaming-stack has RO
# - Reports free space on the NFS share
# - Exit 1 if any mount issues

set -euo pipefail

ROOT="$(cd "$(dirname "$0")/../../../.." && pwd)"
TENANT_BINDING="$ROOT/ops/bindings/tenants/media-stack.yaml"
VM_BINDING="$ROOT/ops/bindings/vm.lifecycle.yaml"
SCHEMA_VERSION="1.0.0"
GENERATED_AT="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

usage() {
  cat <<'USAGE'
media.nfs.verify — Verify NFS mount health and free space for media VMs

Args:
  --vm HOST         Check only this VM (download-stack|streaming-stack)
  --json            Output JSON format

Examples:
  ./bin/ops cap run media.nfs.verify
  ./bin/ops cap run media.nfs.verify --vm download-stack --json
USAGE
}

VM_FILTER=""
OUTPUT_JSON=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --vm)
      VM_FILTER="${2:-}"; shift 2 ;;
    --json)
      OUTPUT_JSON=true; shift ;;
    -h|--help)
      usage; exit 0 ;;
    *)
      echo "FAIL: unknown arg: $1" >&2; usage >&2; exit 1 ;;
  esac
done

command -v yq >/dev/null 2>&1 || { echo "MISSING_DEP: yq" >&2; exit 2; }
command -v ssh >/dev/null 2>&1 || { echo "MISSING_DEP: ssh" >&2; exit 2; }
if $OUTPUT_JSON; then
  command -v jq >/dev/null 2>&1 || { echo "MISSING_DEP: jq" >&2; exit 2; }
fi

# Expected mount config from tenant binding
NFS_SOURCE=$(yq -r '.media.nfs.source' "$TENANT_BINDING" 2>/dev/null || echo "pve:/media")
EXPECTED_MOUNT="/mnt/media"
EXPECTED_EXPORT_PATH="${NFS_SOURCE#*:}"

get_vm_ssh_ref() {
  local vm="$1"
  local target user

  target=$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_target // .hostname // \"\"" "$VM_BINDING" 2>/dev/null || echo "")
  user=$(yq -r ".vms[] | select(.hostname == \"$vm\") | .ssh_user // \"\"" "$VM_BINDING" 2>/dev/null || echo "")

  if [[ -z "$target" || "$target" == "null" ]]; then
    echo ""
    return 1
  fi

  if [[ -n "$user" && "$user" != "null" ]]; then
    echo "${user}@${target}"
  else
    echo "$target"
  fi
}

verify_vm_nfs() {
  local vm="$1"
  local expected_mode="$2"
  local ssh_ref=""

  local result=""
  local status="OK"
  local mount_info=""
  local mount_source=""
  local mount_opts=""
  local free_space=""

  ssh_ref=$(get_vm_ssh_ref "$vm" 2>/dev/null || true)
  if [[ -z "$ssh_ref" ]]; then
    printf '%s\t%s\t%s\t%s\t%s\n' "$vm" "FAIL" "no-ssh-target" "unknown" ""
    return 0
  fi

  # Check active mount at expected path and validate export path (host may appear as alias or IP).
  mount_info=$(ssh -o BatchMode=yes -o ConnectTimeout=10 "$ssh_ref" "findmnt -rn -T '$EXPECTED_MOUNT' -t nfs,nfs4 -o SOURCE,OPTIONS" 2>/dev/null || echo "")

  if [[ -z "$mount_info" ]]; then
    result="FAIL:not-mounted"
    status="FAIL"
  else
    mount_source="${mount_info%% *}"
    mount_opts="${mount_info#* }"
    if [[ "$mount_source" != *":$EXPECTED_EXPORT_PATH" ]]; then
      result="FAIL:unexpected-source:$mount_source"
      status="FAIL"
      printf '%s\t%s\t%s\t%s\t%s\n' "$vm" "$status" "$result" "unknown" "$mount_info"
      return 0
    fi

    # Check mount mode
    if [[ "$expected_mode" == "rw" ]]; then
      if [[ "$mount_opts" =~ (^|,)rw($|,) ]]; then
        result="OK:rw-mounted"
      else
        result="FAIL:expected-rw-got-ro"
        status="FAIL"
      fi
    else
      if [[ "$mount_opts" =~ (^|,)ro($|,) ]]; then
        result="OK:ro-mounted"
      else
        # For streaming-stack, ro is ideal but rw is acceptable
        result="OK:rw-mounted-acceptable"
      fi
    fi

    # Get free space
    free_space=$(ssh -o BatchMode=yes -o ConnectTimeout=10 "$ssh_ref" "df -h $EXPECTED_MOUNT 2>/dev/null | tail -1 | awk '{print \$4}'" 2>/dev/null || echo "unknown")
  fi

  printf '%s\t%s\t%s\t%s\t%s\n' "$vm" "$status" "$result" "$free_space" "$mount_info"
}

ERRORS=0
RESULTS=()

if [[ -z "$VM_FILTER" || "$VM_FILTER" == "download-stack" ]]; then
  result=$(verify_vm_nfs "download-stack" "rw")
  RESULTS+=("$result")
  if [[ "$result" == *$'\tFAIL\t'* ]]; then
    ERRORS=$((ERRORS + 1))
  fi
fi

if [[ -z "$VM_FILTER" || "$VM_FILTER" == "streaming-stack" ]]; then
  result=$(verify_vm_nfs "streaming-stack" "ro")
  RESULTS+=("$result")
  if [[ "$result" == *$'\tFAIL\t'* ]]; then
    ERRORS=$((ERRORS + 1))
  fi
fi

if $OUTPUT_JSON; then
  overall_status="ok"
  if [[ "$ERRORS" -gt 0 ]]; then
    overall_status="fail"
  fi

  results_json="$(printf '%s\n' "${RESULTS[@]}" | jq -R -s '
    split("\n")
    | map(select(length > 0))
    | map(split("\t") | {vm: .[0], status: .[1], detail: .[2], free_space: .[3], mount: .[4]})
  ')"

  jq -n \
    --arg capability "media.nfs.verify" \
    --arg schema_version "$SCHEMA_VERSION" \
    --arg generated_at "$GENERATED_AT" \
    --arg status "$overall_status" \
    --arg nfs_source "$NFS_SOURCE" \
    --arg expected_mount "$EXPECTED_MOUNT" \
    --arg vm_filter "$VM_FILTER" \
    --argjson errors "$ERRORS" \
    --argjson results "$results_json" \
    '{
      capability: $capability,
      schema_version: $schema_version,
      generated_at: $generated_at,
      status: $status,
      data: {
        nfs_source: $nfs_source,
        expected_mount: $expected_mount,
        vm_filter: (if $vm_filter == "" then null else $vm_filter end),
        errors: $errors,
        results: $results
      }
    }'
else
  echo "media.nfs.verify"
  echo "================"
  echo "nfs_source: $NFS_SOURCE"
  echo "expected_mount: $EXPECTED_MOUNT"
  echo ""
  printf "%-20s %-8s %-25s %12s\n" "VM" "STATUS" "DETAIL" "FREE"
  printf "%-20s %-8s %-25s %12s\n" "--" "------" "------" "----"

  for r in "${RESULTS[@]}"; do
    IFS=$'\t' read -r vm status detail free rest <<< "$r"
    printf "%-20s %-8s %-25s %12s\n" "$vm" "$status" "$detail" "$free"
  done

  if [[ $ERRORS -gt 0 ]]; then
    echo ""
    echo "FAIL: $ERRORS NFS mount issue(s) detected"
    exit 1
  fi

  echo ""
  echo "OK: all NFS mounts healthy"
fi

exit $ERRORS
