#!/usr/bin/env bash
set -euo pipefail

# session-start — Initialize a governed spine terminal session
#
# Usage: session-start <lane>
#   Lanes: scan | apply | coordinator
#
# Creates:
#   - SPINE_SESSION_ID env var
#   - Session state dir: mailroom/state/sessions/<id>/
#   - Session manifest: <id>/session.yaml
#   - Bootstrap log: <id>/bootstrap.log
#   - Commands log hook (preexec)
#
# Multi-agent awareness:
#   - Prunes stale sessions (dead PID + age > TTL)
#   - Counts active peer sessions
#   - Exports SPINE_ACTIVE_SESSION_COUNT and SPINE_MULTI_AGENT
#
# The 'apply' lane acquires apply-owner.lock — only one terminal can apply.

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)"
SESSIONS_DIR="$ROOT/mailroom/state/sessions"
LOCK_FILE="$ROOT/mailroom/state/apply-owner.lock"
ARCHIVE_DIR="$SESSIONS_DIR/.archive"
SESSION_TTL=${SPINE_SESSION_TTL:-14400}  # 4 hours default

parse_epoch_utc() {
  local ts="${1:-}"
  [[ -n "$ts" ]] || { echo 0; return; }

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$ts" <<'PY'
import sys
from datetime import datetime, timezone

ts = (sys.argv[1] or "").strip()
if not ts:
    print(0)
    raise SystemExit(0)

if ts.endswith("Z"):
    ts = ts[:-1] + "+00:00"

try:
    dt = datetime.fromisoformat(ts)
except Exception:
    print(0)
    raise SystemExit(0)

if dt.tzinfo is None:
    dt = dt.replace(tzinfo=timezone.utc)

print(int(dt.timestamp()))
PY
    return
  fi

  if date --version >/dev/null 2>&1; then
    date -d "$ts" "+%s" 2>/dev/null || echo 0
    return
  fi

  local clean_ts="${ts%%Z*}"
  clean_ts="${clean_ts%%+*}"
  date -j -f "%Y-%m-%dT%H:%M:%S" "$clean_ts" "+%s" 2>/dev/null || echo 0
}

usage() {
  echo "Usage: session-start <lane>"
  echo "  Lanes: scan | apply | coordinator"
  exit 1
}

[[ $# -ge 1 ]] || usage
LANE="$1"

case "$LANE" in
  scan|apply|coordinator) ;;
  *) echo "ERROR: unknown lane '$LANE'. Use: scan | apply | coordinator"; exit 1 ;;
esac

# ─── Session pruning + liveness ─────────────────────────────
# Archive stale sessions: PID dead (immediate); also archive TTL-expired sessions.
# Returns active session count via stdout when called as subshell.

prune_and_count_sessions() {
  mkdir -p "$ARCHIVE_DIR"
  local now
  now=$(date +%s)
  local active=0

  for session_dir in "$SESSIONS_DIR"/SES-*/; do
    [[ -d "$session_dir" ]] || continue
    local manifest="$session_dir/session.yaml"
    [[ -f "$manifest" ]] || continue

    # Extract fields with grep (portable, no yq dependency in hooks)
    local pid created
    pid=$(grep '^pid:' "$manifest" | sed 's/^pid: *//' | tr -d '"' || echo "")
    created=$(grep '^created:' "$manifest" | sed 's/^created: *//' | tr -d '"' || echo "")

    # Calculate age
    local epoch=0
    if [[ -n "$created" ]]; then
      epoch=$(parse_epoch_utc "$created")
    fi
    local age=$((now - epoch))

    # Check PID liveness
    local pid_alive=false
    if [[ -n "$pid" && "$pid" != "null" && "$pid" != "" ]]; then
      if kill -0 "$pid" 2>/dev/null; then
        pid_alive=true
      fi
    fi

    # Archive if PID dead (stale session) or far past TTL.
    if [[ "$pid_alive" == "false" ]] || [[ "$age" -gt "$SESSION_TTL" ]]; then
      mv "$session_dir" "$ARCHIVE_DIR/" 2>/dev/null || true
      continue
    fi

    active=$((active + 1))
  done

  echo "$active"
}

# Prune stale sessions and count active peers
ACTIVE_BEFORE=$(prune_and_count_sessions)

# ─── Generate session ───────────────────────────────────────

DATE_PART=$(date +%Y%m%d-%H%M%S)
HASH_PART=$(head -c 4 /dev/urandom | xxd -p | head -c 6)
SESSION_ID="SES-${DATE_PART}-${LANE}-${HASH_PART}"
SESSION_DIR="$SESSIONS_DIR/$SESSION_ID"

mkdir -p "$SESSION_DIR"

# Write session manifest
cat > "$SESSION_DIR/session.yaml" <<YAML
session_id: "$SESSION_ID"
lane: "$LANE"
created: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
terminal: "${TERM_PROGRAM:-unknown}"
user: "$(whoami)"
hostname: "$(hostname -s)"
pid: $$
YAML

# Apply-owner lock (P4)
if [[ "$LANE" == "apply" ]]; then
  if [[ -f "$LOCK_FILE" ]]; then
    existing=$(cat "$LOCK_FILE")
    echo "WARNING: apply-owner.lock already held by: $existing"
    echo "Only one terminal can hold apply rights."
    echo "To force: rm $LOCK_FILE"
    exit 1
  fi
  echo "$SESSION_ID" > "$LOCK_FILE"
  echo "Apply-owner lock acquired: $SESSION_ID"
fi

# ─── Multi-agent awareness ──────────────────────────────────

# Count includes the session we just created
ACTIVE_COUNT=$((ACTIVE_BEFORE + 1))
MULTI_AGENT=false
if [[ "$ACTIVE_COUNT" -gt 1 ]]; then
  MULTI_AGENT=true
fi

echo "═══════════════════════════════════════════════════════════════"
echo "  SPINE SESSION: $SESSION_ID"
echo "  Lane: $LANE"
echo "  State: $SESSION_DIR/"
echo "═══════════════════════════════════════════════════════════════"

# Multi-agent banner
if [[ "$MULTI_AGENT" == "true" ]]; then
  echo ""
  echo "╔═══════════════════════════════════════════════════════════╗"
  echo "║  MULTI-AGENT MODE ACTIVE ($ACTIVE_COUNT sessions)                  ║"
  echo "║  Proposal flow required; avoid direct commit.            ║"
  echo "║  Use: proposals.submit / proposals.apply                 ║"
  echo "║  Or take apply-owner lock: session-start apply           ║"
  echo "╚═══════════════════════════════════════════════════════════╝"
fi

# Pruning summary
if [[ -d "$ARCHIVE_DIR" ]]; then
  ARCHIVED_COUNT=$(find "$ARCHIVE_DIR" -maxdepth 1 -type d -name 'SES-*' 2>/dev/null | wc -l | tr -d ' ')
  echo ""
  echo "  Sessions: $ACTIVE_COUNT active, $ARCHIVED_COUNT archived"
fi

# Bootstrap (P2) — capture all outputs
BOOTSTRAP_LOG="$SESSION_DIR/bootstrap.log"
{
  echo "=== ops status ==="
  "$ROOT/bin/ops" status 2>&1 || true
  echo ""
  echo "=== gaps.status ==="
  bash "$ROOT/ops/plugins/loops/bin/gaps-status" 2>&1 || true
  echo ""
} > "$BOOTSTRAP_LOG" 2>&1

# MCP/tooling awareness (P6) — print agent routing summary
echo ""
echo "──────────────────────────────────────────────────────────────"
echo "  Agent Routing"
echo "──────────────────────────────────────────────────────────────"
if command -v yq >/dev/null 2>&1 && [[ -f "$ROOT/ops/bindings/agents.registry.yaml" ]]; then
  while IFS='|' read -r agent_id domain mcp_type; do
    printf "  %-24s  domain=%-16s  mcp=%s\n" "$agent_id" "$domain" "$mcp_type"
  done < <(yq e '.agents[] | .id + "|" + .domain + "|" + (.mcp_type // "n/a")' "$ROOT/ops/bindings/agents.registry.yaml" 2>/dev/null)
fi

echo ""
echo "──────────────────────────────────────────────────────────────"
echo "  Capabilities: $(yq e '.capabilities | length' "$ROOT/ops/bindings/capability_map.yaml" 2>/dev/null || echo '?') mapped"
MAX_GATE="$(yq e -r '.gates[].id' "$ROOT/ops/bindings/gate.registry.yaml" 2>/dev/null | sed 's/^D//' | sort -n | tail -1)"
[[ -n "${MAX_GATE:-}" ]] || MAX_GATE="?"
echo "  Drift Gates: D1-D$MAX_GATE ($(ls "$ROOT/surfaces/verify/"d[0-9]*.sh 2>/dev/null | wc -l | tr -d ' ') scripts)"
echo "──────────────────────────────────────────────────────────────"

# Emit env vars for caller to source
ENV_FILE="$SESSION_DIR/env.sh"
cat > "$ENV_FILE" <<SH
export SPINE_SESSION_ID="$SESSION_ID"
export SPINE_LANE="$LANE"
export SPINE_SESSION_DIR="$SESSION_DIR"
export SPINE_ACTIVE_SESSION_COUNT=$ACTIVE_COUNT
export SPINE_MULTI_AGENT=$MULTI_AGENT
SH

echo ""
echo "To activate in your shell:"
echo "  source $ENV_FILE"
echo ""

# Preexec hook snippet (P3)
PREEXEC_FILE="$SESSION_DIR/preexec-hook.zsh"
cat > "$PREEXEC_FILE" <<'ZSH'
# Spine session command telemetry — source this in your zsh session
# Usage: source <session-dir>/preexec-hook.zsh
_spine_preexec() {
  local cmd="$1"
  local log="${SPINE_SESSION_DIR}/commands.log"
  [[ -n "${SPINE_SESSION_DIR:-}" ]] || return
  printf '%s\t%s\t%s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$(pwd)" "$cmd" >> "$log"
}
autoload -Uz add-zsh-hook
add-zsh-hook preexec _spine_preexec
ZSH

echo "For command telemetry:"
echo "  source $PREEXEC_FILE"
