#!/usr/bin/env bash
set -euo pipefail

# session-start — Initialize a governed spine terminal session
#
# Usage:
#   session-start                     # fast startup summary (default)
#   session-start full               # deep startup diagnostics
#   session-start <lane>             # lane wiring: scan | apply | coordinator
#
# Creates:
#   - SPINE_SESSION_ID env var
#   - Session state dir: mailroom/state/sessions/<id>/
#   - Session manifest: <id>/session.yaml
#   - Bootstrap log: <id>/bootstrap.log
#   - Commands log hook (preexec)
#
# Multi-agent awareness:
#   - Prunes stale sessions (dead PID + age > TTL)
#   - Counts active peer sessions
#   - Exports SPINE_ACTIVE_SESSION_COUNT and SPINE_MULTI_AGENT
#
# The 'apply' lane acquires apply-owner.lock — only one terminal can apply.

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../.." && pwd)"
SESSIONS_DIR="$ROOT/mailroom/state/sessions"
LOCK_FILE="$ROOT/mailroom/state/apply-owner.lock"
ARCHIVE_DIR="$SESSIONS_DIR/.archive"
SESSION_TTL=${SPINE_SESSION_TTL:-14400}  # 4 hours default

parse_epoch_utc() {
  local ts="${1:-}"
  [[ -n "$ts" ]] || { echo 0; return; }

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$ts" <<'PY'
import sys
from datetime import datetime, timezone

ts = (sys.argv[1] or "").strip()
if not ts:
    print(0)
    raise SystemExit(0)

if ts.endswith("Z"):
    ts = ts[:-1] + "+00:00"

try:
    dt = datetime.fromisoformat(ts)
except Exception:
    print(0)
    raise SystemExit(0)

if dt.tzinfo is None:
    dt = dt.replace(tzinfo=timezone.utc)

print(int(dt.timestamp()))
PY
    return
  fi

  if date --version >/dev/null 2>&1; then
    date -d "$ts" "+%s" 2>/dev/null || echo 0
    return
  fi

  local clean_ts="${ts%%Z*}"
  clean_ts="${clean_ts%%+*}"
  date -j -f "%Y-%m-%dT%H:%M:%S" "$clean_ts" "+%s" 2>/dev/null || echo 0
}

usage() {
  cat <<'EOF'
Usage:
  session-start [--mode fast|full] [--strict] [--json]
  session-start <lane>

Lanes:
  scan | apply | coordinator

Notes:
  - No args defaults to fast startup mode.
  - full mode runs status + stability snapshot + core verify.
EOF
  exit 1
}

run_fast_startup() {
  local mode="fast"
  local strict=0
  local json_mode=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --)
        shift
        ;;
      --mode)
        mode="${2:-}"
        shift 2
        ;;
      --strict)
        strict=1
        shift
        ;;
      --json)
        json_mode=1
        shift
        ;;
      fast|full)
        mode="$1"
        shift
        ;;
      -h|--help)
        usage
        ;;
      *)
        echo "session.start FAIL: unknown arg: $1" >&2
        return 2
        ;;
    esac
  done

  case "$mode" in
    fast|full) ;;
    *)
      echo "session.start FAIL: --mode must be fast|full" >&2
      return 2
      ;;
  esac

  if [[ "$mode" == "fast" ]]; then
    local status_brief
    local recommend_output=""
    local recommend_domains="core"
    local recommend_cmd="./bin/ops cap run verify.core.run"
    local recommended_first_domain="core"
    local receipt_memory_domain="none"
    local receipt_memory_hint="./bin/ops cap run receipts.summary -- --domain none --days 7"

    status_brief="$("$ROOT/bin/ops" status --brief 2>&1 || true)"

    if [[ -x "$ROOT/ops/plugins/verify/bin/verify-topology" ]]; then
      recommend_output="$("$ROOT/ops/plugins/verify/bin/verify-topology" recommend --json 2>/dev/null || true)"
      if [[ -n "$recommend_output" ]] && jq -e '.' >/dev/null 2>&1 <<< "$recommend_output"; then
        recommend_domains="$(jq -r '.recommended_domains | join(",")' <<< "$recommend_output" 2>/dev/null || echo core)"
        recommend_cmd="$(jq -r '
          (.recommended_domains // ["core"]) as $domains
          | if ($domains | length) == 0 or $domains[0] == "core" then
              "./bin/ops cap run verify.core.run"
            else
              "./bin/ops cap run verify.pack.run " + $domains[0]
            end
        ' <<< "$recommend_output" 2>/dev/null || echo "./bin/ops cap run verify.core.run")"
      fi
    fi

    recommended_first_domain="${recommend_domains%%,*}"
    recommended_first_domain="${recommended_first_domain//[[:space:]]/}"
    [[ -n "$recommended_first_domain" ]] || recommended_first_domain="core"
    if [[ "$recommended_first_domain" == "core" || "$recommended_first_domain" == "none" ]]; then
      receipt_memory_domain="none"
    else
      receipt_memory_domain="$recommended_first_domain"
    fi
    receipt_memory_hint="./bin/ops cap run receipts.summary -- --domain ${receipt_memory_domain} --days 7"

    if [[ "$json_mode" -eq 1 ]]; then
      jq -n \
        --arg capability "session.start" \
        --arg mode "fast" \
        --arg status_brief "$status_brief" \
        --arg recommended_domains "$recommend_domains" \
        --arg recommended_verify_command "$recommend_cmd" \
        --arg receipt_memory_hint "$receipt_memory_hint" \
        '{
          capability: $capability,
          mode: $mode,
          status_brief: $status_brief,
          recommended_domains: ($recommended_domains | split(",") | map(select(length > 0))),
          recommended_verify_command: $recommended_verify_command,
          receipt_memory_hint_command: $receipt_memory_hint,
          note: "fast lane complete; run recommended verify after domain edits"
        }'
    else
      echo "session.start"
      echo "mode: fast"
      echo "status: ${status_brief}"
      echo "recommended_domains: ${recommend_domains}"
      echo "post_work_verify: ${recommend_cmd}"
      echo "receipt_memory_hint: ${receipt_memory_hint}"
      echo "note: fast lane complete; run recommended verify after domain edits"
    fi
    return 0
  fi

  local status_rc=0
  local snapshot_rc=0
  local core_rc=0

  if [[ "$json_mode" -eq 0 ]]; then
    echo "session.start"
    echo "mode: full"
    echo "running: ./bin/ops status"
  fi
  "$ROOT/bin/ops" status >/dev/null 2>&1 || status_rc=$?

  if [[ "$json_mode" -eq 0 ]]; then
    echo "running: ./bin/ops cap run stability.control.snapshot"
  fi
  "$ROOT/bin/ops" cap run stability.control.snapshot >/dev/null 2>&1 || snapshot_rc=$?

  if [[ "$json_mode" -eq 0 ]]; then
    echo "running: ./bin/ops cap run verify.core.run"
  fi
  "$ROOT/bin/ops" cap run verify.core.run >/dev/null 2>&1 || core_rc=$?

  if [[ "$json_mode" -eq 1 ]]; then
    jq -n \
      --arg capability "session.start" \
      --arg mode "full" \
      --argjson strict "$strict" \
      --argjson status_rc "$status_rc" \
      --argjson snapshot_rc "$snapshot_rc" \
      --argjson core_rc "$core_rc" \
      '{
        capability: $capability,
        mode: $mode,
        strict: ($strict == 1),
        status_rc: $status_rc,
        snapshot_rc: $snapshot_rc,
        core_rc: $core_rc
      }'
  else
    echo "status_rc: $status_rc"
    echo "snapshot_rc: $snapshot_rc"
    echo "core_rc: $core_rc"
  fi

  if [[ "$strict" -eq 1 ]]; then
    (( status_rc == 0 && snapshot_rc == 0 && core_rc == 0 )) || return 1
    return 0
  fi

  (( core_rc == 0 )) || return "$core_rc"
  return 0
}

if [[ $# -eq 0 ]]; then
  run_fast_startup
  exit $?
fi

case "${1:-}" in
  fast|full|--mode|--strict|--json|--)
    run_fast_startup "$@"
    exit $?
    ;;
esac

LANE="$1"
case "$LANE" in
  scan|apply|coordinator) ;;
  *) echo "ERROR: unknown lane '$LANE'. Use: scan | apply | coordinator"; exit 1 ;;
esac

# ─── Session pruning + liveness ─────────────────────────────
# Archive stale sessions: PID dead (immediate); also archive TTL-expired sessions.
# Returns active session count via stdout when called as subshell.

prune_and_count_sessions() {
  mkdir -p "$ARCHIVE_DIR"
  local now
  now=$(date +%s)
  local active=0

  for session_dir in "$SESSIONS_DIR"/SES-*/; do
    [[ -d "$session_dir" ]] || continue
    local manifest="$session_dir/session.yaml"
    [[ -f "$manifest" ]] || continue

    # Extract fields with grep (portable, no yq dependency in hooks)
    local pid created
    pid=$(grep '^pid:' "$manifest" | sed 's/^pid: *//' | tr -d '"' || echo "")
    created=$(grep '^created:' "$manifest" | sed 's/^created: *//' | tr -d '"' || echo "")

    # Calculate age
    local epoch=0
    if [[ -n "$created" ]]; then
      epoch=$(parse_epoch_utc "$created")
    fi
    local age=$((now - epoch))

    # Check PID liveness
    local pid_alive=false
    if [[ -n "$pid" && "$pid" != "null" && "$pid" != "" ]]; then
      if kill -0 "$pid" 2>/dev/null; then
        pid_alive=true
      fi
    fi

    # Archive if PID dead (stale session) or far past TTL.
    if [[ "$pid_alive" == "false" ]] || [[ "$age" -gt "$SESSION_TTL" ]]; then
      mv "$session_dir" "$ARCHIVE_DIR/" 2>/dev/null || true
      continue
    fi

    active=$((active + 1))
  done

  echo "$active"
}

# Prune stale sessions and count active peers
ACTIVE_BEFORE=$(prune_and_count_sessions)

# ─── Generate session ───────────────────────────────────────

DATE_PART=$(date +%Y%m%d-%H%M%S)
HASH_PART=$(head -c 4 /dev/urandom | xxd -p | head -c 6)
SESSION_ID="SES-${DATE_PART}-${LANE}-${HASH_PART}"
SESSION_DIR="$SESSIONS_DIR/$SESSION_ID"

mkdir -p "$SESSION_DIR"

# Write session manifest
cat > "$SESSION_DIR/session.yaml" <<YAML
session_id: "$SESSION_ID"
lane: "$LANE"
created: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
terminal: "${TERM_PROGRAM:-unknown}"
user: "$(whoami)"
hostname: "$(hostname -s)"
pid: $$
YAML

# Apply-owner lock (P4)
if [[ "$LANE" == "apply" ]]; then
  if [[ -f "$LOCK_FILE" ]]; then
    existing=$(cat "$LOCK_FILE")
    echo "WARNING: apply-owner.lock already held by: $existing"
    echo "Only one terminal can hold apply rights."
    echo "To force: rm $LOCK_FILE"
    exit 1
  fi
  echo "$SESSION_ID" > "$LOCK_FILE"
  echo "Apply-owner lock acquired: $SESSION_ID"
fi

# ─── Multi-agent awareness ──────────────────────────────────

# Count includes the session we just created
ACTIVE_COUNT=$((ACTIVE_BEFORE + 1))
MULTI_AGENT=false
if [[ "$ACTIVE_COUNT" -gt 1 ]]; then
  MULTI_AGENT=true
fi

echo "═══════════════════════════════════════════════════════════════"
echo "  SPINE SESSION: $SESSION_ID"
echo "  Lane: $LANE"
echo "  State: $SESSION_DIR/"
echo "═══════════════════════════════════════════════════════════════"

# Multi-agent banner
if [[ "$MULTI_AGENT" == "true" ]]; then
  echo ""
  echo "╔═══════════════════════════════════════════════════════════╗"
  echo "║  MULTI-AGENT MODE ACTIVE ($ACTIVE_COUNT sessions)                  ║"
  echo "║  Proposal flow required; avoid direct commit.            ║"
  echo "║  Use: proposals.submit / proposals.apply                 ║"
  echo "║  Or take apply-owner lock: session-start apply           ║"
  echo "╚═══════════════════════════════════════════════════════════╝"
fi

# Pruning summary
if [[ -d "$ARCHIVE_DIR" ]]; then
  ARCHIVED_COUNT=$(find "$ARCHIVE_DIR" -maxdepth 1 -type d -name 'SES-*' 2>/dev/null | wc -l | tr -d ' ')
  echo ""
  echo "  Sessions: $ACTIVE_COUNT active, $ARCHIVED_COUNT archived"
fi

# Bootstrap (P2) — capture all outputs
BOOTSTRAP_LOG="$SESSION_DIR/bootstrap.log"
{
  echo "=== ops status ==="
  "$ROOT/bin/ops" status 2>&1 || true
  echo ""
  echo "=== gaps.status ==="
  bash "$ROOT/ops/plugins/loops/bin/gaps-status" 2>&1 || true
  echo ""
} > "$BOOTSTRAP_LOG" 2>&1

# MCP/tooling awareness (P6) — print agent routing summary
echo ""
echo "──────────────────────────────────────────────────────────────"
echo "  Agent Routing"
echo "──────────────────────────────────────────────────────────────"
if command -v yq >/dev/null 2>&1 && [[ -f "$ROOT/ops/bindings/agents.registry.yaml" ]]; then
  AGENTS_FILE="$ROOT/ops/bindings/agents.registry.yaml"
  SHOW_SUPERSEDED="${SPINE_SESSION_SHOW_SUPERSEDED:-0}"
  if [[ "$SHOW_SUPERSEDED" == "1" ]]; then
    ROUTING_FILTER='.agents[] | .id + "|" + .domain + "|" + (.mcp_type // "n/a")'
  else
    ROUTING_FILTER='.agents[] | select((.implementation_status // "active") != "superseded") | .id + "|" + .domain + "|" + (.mcp_type // "n/a")'
  fi
  while IFS='|' read -r agent_id domain mcp_type; do
    printf "  %-24s  domain=%-16s  mcp=%s\n" "$agent_id" "$domain" "$mcp_type"
  done < <(yq e "$ROUTING_FILTER" "$AGENTS_FILE" 2>/dev/null)
  if [[ "$SHOW_SUPERSEDED" != "1" ]]; then
    HIDDEN_SUPERSEDED="$(yq e '.agents | map(select((.implementation_status // "active") == "superseded")) | length' "$AGENTS_FILE" 2>/dev/null || echo "0")"
    if [[ "$HIDDEN_SUPERSEDED" =~ ^[0-9]+$ ]] && (( HIDDEN_SUPERSEDED > 0 )); then
      echo "  (hidden superseded agents: $HIDDEN_SUPERSEDED; set SPINE_SESSION_SHOW_SUPERSEDED=1 to show all)"
    fi
  fi
fi

echo ""
echo "──────────────────────────────────────────────────────────────"
echo "  Capabilities: $(yq e '.capabilities | length' "$ROOT/ops/bindings/capability_map.yaml" 2>/dev/null || echo '?') mapped"
MAX_GATE="$(yq e -r '.gates[].id' "$ROOT/ops/bindings/gate.registry.yaml" 2>/dev/null | sed 's/^D//' | sort -n | tail -1)"
[[ -n "${MAX_GATE:-}" ]] || MAX_GATE="?"
echo "  Drift Gates: D1-D$MAX_GATE ($(ls "$ROOT/surfaces/verify/"d[0-9]*.sh 2>/dev/null | wc -l | tr -d ' ') scripts)"
echo "──────────────────────────────────────────────────────────────"

# Emit env vars for caller to source
ENV_FILE="$SESSION_DIR/env.sh"
cat > "$ENV_FILE" <<SH
export SPINE_SESSION_ID="$SESSION_ID"
export SPINE_LANE="$LANE"
export SPINE_SESSION_DIR="$SESSION_DIR"
export SPINE_ACTIVE_SESSION_COUNT=$ACTIVE_COUNT
export SPINE_MULTI_AGENT=$MULTI_AGENT
SH

echo ""
echo "To activate in your shell:"
echo "  source $ENV_FILE"
echo ""

# Preexec hook snippet (P3)
PREEXEC_FILE="$SESSION_DIR/preexec-hook.zsh"
cat > "$PREEXEC_FILE" <<'ZSH'
# Spine session command telemetry — source this in your zsh session
# Usage: source <session-dir>/preexec-hook.zsh
_spine_preexec() {
  local cmd="$1"
  local log="${SPINE_SESSION_DIR}/commands.log"
  [[ -n "${SPINE_SESSION_DIR:-}" ]] || return
  printf '%s\t%s\t%s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$(pwd)" "$cmd" >> "$log"
}
autoload -Uz add-zsh-hook
add-zsh-hook preexec _spine_preexec
ZSH

echo "For command telemetry:"
echo "  source $PREEXEC_FILE"
