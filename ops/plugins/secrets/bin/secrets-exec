#!/usr/bin/env bash
# secrets.exec â€” run a command with secrets injected via Infisical (NO secret output)
#
# Contract:
# - Requires secrets.binding == OK
# - Requires secrets.auth.status == OK
# - Executes: infisical run -- <cmd...>
# - Must not print env values. Receipts may include the command line, but secrets are never echoed.
#
# Usage:
#   ./bin/ops cap run secrets.exec -- <cmd...>
#
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
[[ -d "$SPINE_REPO" ]] || SPINE_REPO="$HOME/code/agentic-spine"

# Always source canonical credentials so rotated values override stale shell vars.
CREDENTIALS_FILE="${HOME}/.config/infisical/credentials"
if [[ -f "$CREDENTIALS_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CREDENTIALS_FILE"
fi

# --- parse `--` separator ---
if [[ "${1:-}" != "--" ]]; then
  echo "USAGE: secrets.exec -- <command...>"
  exit 1
fi
shift
if [[ "$#" -lt 1 ]]; then
  echo "USAGE: secrets.exec -- <command...>"
  exit 1
fi

# --- preconditions (STOP if unmet) ---
# We invoke capabilities via ops to ensure governed behavior/receipts.
# But secrets.exec itself should not assume it is running under ops.
if [[ -x "$SPINE_REPO/bin/ops" ]]; then
  "$SPINE_REPO/bin/ops" cap run secrets.binding >/dev/null || {
    rc=$?
    echo "STOP: secrets.binding not OK (exit $rc)"
    exit 2
  }
  "$SPINE_REPO/bin/ops" cap run secrets.auth.status >/dev/null || {
    rc=$?
    echo "STOP: secrets.auth.status not OK (exit $rc)"
    exit 2
  }
else
  echo "FAIL: missing $SPINE_REPO/bin/ops"
  exit 1
fi

# --- dependency check ---
command -v infisical >/dev/null 2>&1 || { echo "MISSING_DEP: infisical"; exit 1; }
command -v yq >/dev/null 2>&1 || { echo "MISSING_DEP: yq"; exit 1; }
command -v curl >/dev/null 2>&1 || { echo "MISSING_DEP: curl"; exit 1; }
command -v jq >/dev/null 2>&1 || { echo "MISSING_DEP: jq"; exit 1; }

# --- read binding for project/env/api_url ---
BINDING_FILE="$SPINE_REPO/ops/bindings/secrets.binding.yaml"
if [[ ! -f "$BINDING_FILE" ]]; then
  echo "FAIL: binding file not found: $BINDING_FILE"
  exit 1
fi

INF_API_URL="$(yq -r '.infisical.api_url // ""' "$BINDING_FILE")"
INF_PROJECT="$(yq -r '.infisical.project // ""' "$BINDING_FILE")"
INF_ENV="$(yq -r '.infisical.environment // ""' "$BINDING_FILE")"
INF_BASE_PATH="$(yq -r '.infisical.base_path // "/"' "$BINDING_FILE")"

if [[ -z "$INF_PROJECT" || -z "$INF_ENV" ]]; then
  echo "FAIL: binding missing project or environment"
  exit 1
fi
[[ -n "$INF_BASE_PATH" && "$INF_BASE_PATH" != "null" ]] || INF_BASE_PATH="/"

# --- ensure CLI auth token (non-interactive) ---
# IMPORTANT: never print tokens; never pass via CLI flags (would leak in receipts).
# Prefer INFISICAL_TOKEN if provided; else derive a short-lived token via universal auth.
if [[ -z "${INFISICAL_TOKEN:-}" ]]; then
  UA_ID="${INFISICAL_UNIVERSAL_AUTH_CLIENT_ID:-}"
  UA_SECRET="${INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET:-}"
  if [[ -z "$UA_ID" || -z "$UA_SECRET" ]]; then
    echo "STOP: missing Infisical auth (set INFISICAL_TOKEN or universal auth client id/secret)"
    exit 2
  fi
  if [[ -z "$INF_API_URL" ]]; then
    echo "FAIL: binding missing api_url"
    exit 1
  fi

  auth_resp="$(curl -s -w '\n%{http_code}' -X POST "$INF_API_URL/api/v1/auth/universal-auth/login" \
    -H 'Content-Type: application/json' \
    -d "{\"clientId\":\"$UA_ID\",\"clientSecret\":\"$UA_SECRET\"}")"
  auth_code="$(echo "$auth_resp" | tail -n1)"
  auth_body="$(echo "$auth_resp" | sed '$d')"
  if [[ "$auth_code" != "200" ]]; then
    echo "FAIL: Infisical auth failed (HTTP $auth_code)"
    exit 1
  fi

  token="$(echo "$auth_body" | jq -r '.accessToken // empty')"
  [[ -n "$token" ]] || { echo "FAIL: Infisical auth token unavailable"; exit 1; }
  export INFISICAL_TOKEN="$token"
fi

# --- execute ---
# Important: do NOT print env; do NOT `set -x`.
# We print only a safe header.
echo "=== secrets.exec ==="
echo "provider: infisical"
echo "project: $INF_PROJECT"
echo "env: $INF_ENV"
echo "path: $INF_BASE_PATH (recursive)"
echo "cmd: $*"
echo

# Build infisical run command with project/env from binding
INF_ARGS=(run --projectId "$INF_PROJECT" --env "$INF_ENV" --path "$INF_BASE_PATH" --recursive)
[[ -n "$INF_API_URL" ]] && INF_ARGS+=(--domain "$INF_API_URL")

# Infisical CLI injects secrets into the environment of the command.
# We intentionally do not pass/print secret values here.
exec infisical "${INF_ARGS[@]}" -- "$@"
