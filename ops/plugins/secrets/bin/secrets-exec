#!/usr/bin/env bash
# secrets.exec â€” run a command with secrets injected via Infisical (NO secret output)
#
# Contract:
# - Requires secrets.binding == OK
# - Requires secrets.auth.status == OK
# - Requires secrets.namespace.status == OK
# - Requires secrets.enforcement.status == OK
# - Executes: infisical run -- <cmd...>
# - Must not print env values. Receipts may include the command line, but secrets are never echoed.
#
# Usage:
#   ./bin/ops cap run secrets.exec -- <cmd...>
#
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
[[ -d "$SPINE_REPO" ]] || SPINE_REPO="$HOME/code/agentic-spine"

# Always source canonical credentials so rotated values override stale shell vars.
CREDENTIALS_FILE="${HOME}/.config/infisical/credentials"
if [[ -f "$CREDENTIALS_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CREDENTIALS_FILE"
fi

# --- parse `--` separator ---
if [[ "${1:-}" != "--" ]]; then
  echo "USAGE: secrets.exec -- <command...>"
  exit 1
fi
shift
if [[ "$#" -lt 1 ]]; then
  echo "USAGE: secrets.exec -- <command...>"
  exit 1
fi

# --- preconditions (STOP if unmet) ---
if [[ -x "$SPINE_REPO/bin/ops" ]]; then
  "$SPINE_REPO/bin/ops" cap run secrets.binding >/dev/null || {
    rc=$?
    echo "STOP: secrets.binding not OK (exit $rc)"
    exit 2
  }
  "$SPINE_REPO/bin/ops" cap run secrets.auth.status >/dev/null || {
    rc=$?
    echo "STOP: secrets.auth.status not OK (exit $rc)"
    exit 2
  }
  "$SPINE_REPO/bin/ops" cap run secrets.namespace.status >/dev/null || {
    rc=$?
    echo "STOP: secrets.namespace.status not OK (exit $rc)"
    exit 2
  }
  "$SPINE_REPO/bin/ops" cap run secrets.enforcement.status >/dev/null || {
    rc=$?
    echo "STOP: secrets.enforcement.status not OK (exit $rc)"
    exit 2
  }
else
  echo "FAIL: missing $SPINE_REPO/bin/ops"
  exit 1
fi

# --- dependency check ---
command -v infisical >/dev/null 2>&1 || { echo "MISSING_DEP: infisical"; exit 1; }
command -v yq >/dev/null 2>&1 || { echo "MISSING_DEP: yq"; exit 1; }

INFISICAL_AGENT="$SPINE_REPO/ops/tools/infisical-agent.sh"
[[ -x "$INFISICAL_AGENT" ]] || { echo "FAIL: infisical-agent.sh not found"; exit 1; }

# --- read binding for project/env/api_url ---
BINDING_FILE="$SPINE_REPO/ops/bindings/secrets.binding.yaml"
if [[ ! -f "$BINDING_FILE" ]]; then
  echo "FAIL: binding file not found: $BINDING_FILE"
  exit 1
fi

INF_API_URL="$(yq -r '.infisical.internal_api_url // .infisical.api_url // ""' "$BINDING_FILE")"
INF_PROJECT="$(yq -r '.infisical.project // ""' "$BINDING_FILE")"
INF_ENV="$(yq -r '.infisical.environment // ""' "$BINDING_FILE")"
INF_BASE_PATH="$(yq -r '.infisical.base_path // "/"' "$BINDING_FILE")"

if [[ -z "$INF_PROJECT" || -z "$INF_ENV" ]]; then
  echo "FAIL: binding missing project or environment"
  exit 1
fi
[[ -n "$INF_BASE_PATH" && "$INF_BASE_PATH" != "null" ]] || INF_BASE_PATH="/"

# --- ensure CLI auth token (non-interactive) ---
# IMPORTANT: never print tokens; never pass via CLI flags (would leak in receipts).
# Prefer INFISICAL_TOKEN if provided; else derive via canonical agent.
if [[ -z "${INFISICAL_TOKEN:-}" ]]; then
  token="$("$INFISICAL_AGENT" auth-token 2>/dev/null)" || true
  [[ -n "$token" ]] || { echo "FAIL: Infisical auth token unavailable"; exit 1; }
  export INFISICAL_TOKEN="$token"
fi

# --- execute ---
# Important: do NOT print env; do NOT `set -x`.
# We print only a safe header.
echo "=== secrets.exec ==="
echo "provider: infisical"
echo "project: $INF_PROJECT"
echo "env: $INF_ENV"
echo "path: $INF_BASE_PATH (recursive)"
echo "cmd: $*"
echo

# Build infisical run command with project/env from binding
INF_ARGS=(run --projectId "$INF_PROJECT" --env "$INF_ENV" --path "$INF_BASE_PATH" --recursive)
[[ -n "$INF_API_URL" ]] && INF_ARGS+=(--domain "$INF_API_URL")
export INFISICAL_DISABLE_UPDATE_CHECK=true

# Infisical CLI injects secrets into the environment of the command.
# We intentionally do not pass/print secret values here.
exec infisical "${INF_ARGS[@]}" -- "$@"
