#!/usr/bin/env bash
# secrets.exec â€” run a command with secrets injected via Infisical (NO secret output)
#
# Contract:
# - Requires secrets.binding == OK
# - Requires secrets.auth.status == OK
# - Executes: infisical run -- <cmd...>
# - Must not print env values. Receipts may include the command line, but secrets are never echoed.
#
# Usage:
#   ./bin/ops cap run secrets.exec -- <cmd...>
#
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/Code/agentic-spine}"
[[ -d "$SPINE_REPO" ]] || SPINE_REPO="$HOME/code/agentic-spine"

# --- parse `--` separator ---
if [[ "${1:-}" != "--" ]]; then
  echo "USAGE: secrets.exec -- <command...>"
  exit 1
fi
shift
if [[ "$#" -lt 1 ]]; then
  echo "USAGE: secrets.exec -- <command...>"
  exit 1
fi

# --- preconditions (STOP if unmet) ---
# We invoke capabilities via ops to ensure governed behavior/receipts.
# But secrets.exec itself should not assume it is running under ops.
if [[ -x "$SPINE_REPO/bin/ops" ]]; then
  "$SPINE_REPO/bin/ops" cap run secrets.binding >/dev/null || {
    rc=$?
    echo "STOP: secrets.binding not OK (exit $rc)"
    exit 2
  }
  "$SPINE_REPO/bin/ops" cap run secrets.auth.status >/dev/null || {
    rc=$?
    echo "STOP: secrets.auth.status not OK (exit $rc)"
    exit 2
  }
else
  echo "FAIL: missing $SPINE_REPO/bin/ops"
  exit 1
fi

# --- dependency check ---
command -v infisical >/dev/null 2>&1 || { echo "MISSING_DEP: infisical"; exit 1; }

# --- execute ---
# Important: do NOT print env; do NOT `set -x`.
# We print only a safe header.
echo "=== secrets.exec ==="
echo "provider: infisical"
echo "cmd: $*"
echo

# Infisical CLI injects secrets into the environment of the command.
# We intentionally do not pass/print secret values here.
exec infisical run -- "$@"
