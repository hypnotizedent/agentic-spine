#!/usr/bin/env bash
# secrets.exec â€” run a command with secrets injected via Infisical (NO secret output)
#
# Contract:
# - Requires secrets.binding == OK
# - Requires secrets.auth.status == OK
# - Requires secrets.namespace.status == OK
# - Requires secrets.enforcement.status == OK
# - Executes: infisical run -- <cmd...>
# - Must not print env values. Receipts may include the command line, but secrets are never echoed.
#
# Usage:
#   ./bin/ops cap run secrets.exec -- <cmd...>
#   ./bin/ops cap run secrets.exec -- --script /abs/path/script.sh [script args...]
#
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
[[ -d "$SPINE_REPO" ]] || SPINE_REPO="$HOME/code/agentic-spine"

# Always source canonical credentials so rotated values override stale shell vars.
CREDENTIALS_FILE="${HOME}/.config/infisical/credentials"
if [[ -f "$CREDENTIALS_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CREDENTIALS_FILE"
fi

usage() {
  cat <<'USAGE'
USAGE:
  secrets.exec -- <command...>
  secrets.exec -- --script /abs/path/script.sh [script args...]
USAGE
}

# --- parse `--` separator ---
if [[ "${1:-}" != "--" ]]; then
  usage
  exit 1
fi
shift
if [[ "$#" -lt 1 ]]; then
  usage
  exit 1
fi

declare -a USER_CMD=()
if [[ "${1:-}" == "--script" ]]; then
  [[ "$#" -ge 2 ]] || { usage; exit 1; }
  script_path="$2"
  shift 2
  [[ -f "$script_path" ]] || { echo "FAIL: script not found: $script_path"; exit 1; }
  [[ -r "$script_path" ]] || { echo "FAIL: script not readable: $script_path"; exit 1; }
  USER_CMD=(bash "$script_path" "$@")
else
  USER_CMD=("$@")
fi

# --- preconditions (STOP if unmet) ---
SECRETS_PLUGIN_DIR="$SPINE_REPO/ops/plugins/secrets/bin"
[[ -d "$SECRETS_PLUGIN_DIR" ]] || { echo "FAIL: missing plugin dir: $SECRETS_PLUGIN_DIR"; exit 1; }
[[ -x "$SECRETS_PLUGIN_DIR/secrets-binding" ]] || { echo "FAIL: missing precondition script: secrets-binding"; exit 1; }
[[ -x "$SECRETS_PLUGIN_DIR/secrets-auth-status" ]] || { echo "FAIL: missing precondition script: secrets-auth-status"; exit 1; }
[[ -x "$SECRETS_PLUGIN_DIR/secrets-namespace-status" ]] || { echo "FAIL: missing precondition script: secrets-namespace-status"; exit 1; }
[[ -x "$SECRETS_PLUGIN_DIR/secrets-enforcement-status" ]] || { echo "FAIL: missing precondition script: secrets-enforcement-status"; exit 1; }

run_precondition() {
  local label="$1"
  shift
  "$@" >/dev/null 2>&1 || {
    rc=$?
    echo "STOP: $label not OK (exit $rc)"
    exit 2
  }
}

run_precondition "secrets.binding" "$SECRETS_PLUGIN_DIR/secrets-binding"
run_precondition "secrets.auth.status" "$SECRETS_PLUGIN_DIR/secrets-auth-status"
run_precondition "secrets.namespace.status" "$SECRETS_PLUGIN_DIR/secrets-namespace-status"
run_precondition "secrets.enforcement.status" "$SECRETS_PLUGIN_DIR/secrets-enforcement-status"

# --- dependency check ---
command -v infisical >/dev/null 2>&1 || { echo "MISSING_DEP: infisical"; exit 1; }
command -v yq >/dev/null 2>&1 || { echo "MISSING_DEP: yq"; exit 1; }

INFISICAL_AGENT="$SPINE_REPO/ops/tools/infisical-agent.sh"
[[ -x "$INFISICAL_AGENT" ]] || { echo "FAIL: infisical-agent.sh not found"; exit 1; }

# --- read binding for project/env/api_url ---
BINDING_FILE="$SPINE_REPO/ops/bindings/secrets.binding.yaml"
if [[ ! -f "$BINDING_FILE" ]]; then
  echo "FAIL: binding file not found: $BINDING_FILE"
  exit 1
fi

INF_API_URL="$(yq -r '.infisical.internal_api_url // .infisical.api_url // ""' "$BINDING_FILE")"
INF_PROJECT="$(yq -r '.infisical.project // ""' "$BINDING_FILE")"
INF_ENV="$(yq -r '.infisical.environment // ""' "$BINDING_FILE")"
INF_BASE_PATH="$(yq -r '.infisical.base_path // "/"' "$BINDING_FILE")"

if [[ -z "$INF_PROJECT" || -z "$INF_ENV" ]]; then
  echo "FAIL: binding missing project or environment"
  exit 1
fi
[[ -n "$INF_BASE_PATH" && "$INF_BASE_PATH" != "null" ]] || INF_BASE_PATH="/"

# --- ensure CLI auth token (non-interactive) ---
# IMPORTANT: never print tokens; never pass via CLI flags (would leak in receipts).
# Prefer INFISICAL_TOKEN if provided; else derive via canonical agent.
if [[ -z "${INFISICAL_TOKEN:-}" ]]; then
  token="$("$INFISICAL_AGENT" auth-token 2>/dev/null)" || true
  [[ -n "$token" ]] || { echo "FAIL: Infisical auth token unavailable"; exit 1; }
  export INFISICAL_TOKEN="$token"
fi

# --- execute ---
# Important: do NOT print env; do NOT `set -x`.
# We print only a safe header.
echo "=== secrets.exec ==="
echo "provider: infisical"
echo "project: $INF_PROJECT"
echo "env: $INF_ENV"
echo "path: $INF_BASE_PATH (recursive)"
echo "cmd: ${USER_CMD[*]}"
echo

# Build infisical run command with project/env from binding
INF_ARGS=(run --projectId "$INF_PROJECT" --env "$INF_ENV" --path "$INF_BASE_PATH" --recursive)
[[ -n "$INF_API_URL" ]] && INF_ARGS+=(--domain "$INF_API_URL")
export INFISICAL_DISABLE_UPDATE_CHECK=true

# Infisical CLI injects secrets into the environment of the command.
# We intentionally do not pass/print secret values here.
exec infisical "${INF_ARGS[@]}" -- "${USER_CMD[@]}"
