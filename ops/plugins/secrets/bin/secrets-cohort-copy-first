#!/usr/bin/env bash
# secrets-cohort-copy-first - copy root-path cohort keys to a target namespace path
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
POLICY="$SPINE_REPO/ops/bindings/secrets.namespace.policy.yaml"
CREDENTIALS_FILE="${HOME}/.config/infisical/credentials"
EXECUTE=0
TARGET_PATH=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --target-path)
      TARGET_PATH="${2:-}"
      [[ -n "$TARGET_PATH" ]] || { echo "FAIL: --target-path requires a value"; exit 1; }
      shift 2
      ;;
    --execute)
      EXECUTE=1
      shift
      ;;
    *)
      echo "FAIL: unknown argument: $1"
      exit 1
      ;;
  esac
done

[[ -n "$TARGET_PATH" ]] || { echo "FAIL: --target-path is required"; exit 1; }

for dep in yq curl jq; do
  command -v "$dep" >/dev/null 2>&1 || { echo "MISSING_DEP: $dep"; exit 1; }
done
if [[ "$EXECUTE" -eq 1 ]]; then
  command -v infisical >/dev/null 2>&1 || { echo "MISSING_DEP: infisical"; exit 1; }
fi

[[ -f "$POLICY" ]] || { echo "MISSING: $POLICY"; exit 2; }
yq e '.' "$POLICY" >/dev/null 2>&1 || { echo "FAIL: invalid policy YAML"; exit 1; }

if [[ -f "$CREDENTIALS_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CREDENTIALS_FILE"
fi

PROJECT_ID="$(yq e -r '.infisical.project_id // ""' "$POLICY")"
ENV_NAME="$(yq e -r '.infisical.environment // ""' "$POLICY")"
ROOT_PATH="$(yq e -r '.freeze.root_path // "/"' "$POLICY")"
API_URL="${INFISICAL_API_URL:-https://secrets.ronny.works}"
CLIENT_ID="${INFISICAL_UNIVERSAL_AUTH_CLIENT_ID:-}"
CLIENT_SECRET="${INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET:-}"

[[ -n "$PROJECT_ID" && -n "$ENV_NAME" ]] || { echo "FAIL: policy missing project/env"; exit 1; }
[[ -n "$CLIENT_ID" && -n "$CLIENT_SECRET" ]] || { echo "FAIL: missing Infisical auth variables"; exit 1; }

mapfile -t COHORT_KEYS < <(yq e -r ".rules.key_path_overrides | to_entries[] | select(.value == \"$TARGET_PATH\") | .key" "$POLICY" 2>/dev/null || true)
(( ${#COHORT_KEYS[@]} > 0 )) || { echo "FAIL: no keys found in policy overrides for target path $TARGET_PATH"; exit 1; }

auth_resp="$(curl -s -w '\n%{http_code}' -X POST "$API_URL/api/v1/auth/universal-auth/login" \
  -H 'Content-Type: application/json' \
  -d "{\"clientId\":\"$CLIENT_ID\",\"clientSecret\":\"$CLIENT_SECRET\"}")"
auth_code="$(echo "$auth_resp" | tail -n1)"
auth_body="$(echo "$auth_resp" | sed '$d')"
[[ "$auth_code" == "200" ]] || { echo "FAIL: auth failed (HTTP $auth_code)"; exit 1; }
TOKEN="$(echo "$auth_body" | jq -r '.accessToken // empty')"
[[ -n "$TOKEN" ]] || { echo "FAIL: missing access token"; exit 1; }

list_resp="$(curl -s -w '\n%{http_code}' "$API_URL/api/v3/secrets/raw?workspaceId=$PROJECT_ID&environment=$ENV_NAME&recursive=true" \
  -H "Authorization: Bearer $TOKEN")"
list_code="$(echo "$list_resp" | tail -n1)"
list_body="$(echo "$list_resp" | sed '$d')"
[[ "$list_code" == "200" ]] || { echo "FAIL: unable to list secrets (HTTP $list_code)"; exit 1; }
RAW_JSON="$list_body"

secret_count_at_path() {
  local key="$1"
  local path="$2"
  echo "$RAW_JSON" | jq -r --arg k "$key" --arg p "$path" \
    '[.secrets[] | select(.secretKey == $k and (.secretPath // "/") == $p)] | length'
}

secret_value_at_path() {
  local key="$1"
  local path="$2"
  echo "$RAW_JSON" | jq -r --arg k "$key" --arg p "$path" \
    '[.secrets[] | select(.secretKey == $k and (.secretPath // "/") == $p) | .secretValue] | if length > 0 then .[0] else "" end'
}

set_secret_at_path() {
  local key="$1"
  local value="$2"
  local path="$3"
  local payload patch_resp patch_code patch_body post_payload post_resp post_code post_body msg

  payload="$(jq -cn --arg ws "$PROJECT_ID" --arg env "$ENV_NAME" --arg v "$value" --arg p "$path" \
    '{workspaceId:$ws, environment:$env, secretValue:$v, secretPath:$p}')"
  patch_resp="$(curl -s -w '\n%{http_code}' -X PATCH "$API_URL/api/v3/secrets/raw/$key" \
    -H "Authorization: Bearer $TOKEN" \
    -H 'Content-Type: application/json' \
    -d "$payload")"
  patch_code="$(echo "$patch_resp" | tail -n1)"
  patch_body="$(echo "$patch_resp" | sed '$d')"
  if [[ "$patch_code" == "200" ]] && echo "$patch_body" | jq -e '.secret' >/dev/null 2>&1; then
    return 0
  fi

  post_payload="$(jq -cn --arg ws "$PROJECT_ID" --arg env "$ENV_NAME" --arg v "$value" --arg p "$path" \
    '{workspaceId:$ws, environment:$env, secretValue:$v, secretPath:$p, type:"shared"}')"
  post_resp="$(curl -s -w '\n%{http_code}' -X POST "$API_URL/api/v3/secrets/raw/$key" \
    -H "Authorization: Bearer $TOKEN" \
    -H 'Content-Type: application/json' \
    -d "$post_payload")"
  post_code="$(echo "$post_resp" | tail -n1)"
  post_body="$(echo "$post_resp" | sed '$d')"
  if [[ "$post_code" =~ ^20[01]$ ]] && echo "$post_body" | jq -e '.secret' >/dev/null 2>&1; then
    return 0
  fi

  msg="$(echo "$post_body" | jq -r '.message // empty' 2>/dev/null || true)"
  [[ -n "$msg" ]] || msg="$(echo "$patch_body" | jq -r '.message // "set failed"' 2>/dev/null || echo "set failed")"
  echo "FAIL: set failed for $key ($msg)"
  return 1
}

ensure_folder_hierarchy() {
  local target="$1"
  local current="/" folders_json segment
  local -a segments=()

  [[ "$target" == "/" ]] && return 0
  IFS='/' read -r -a segments <<< "${target#/}"
  for segment in "${segments[@]}"; do
    [[ -n "$segment" ]] || continue
    folders_json="$(infisical secrets folders get --projectId "$PROJECT_ID" --env "$ENV_NAME" --path "$current" \
      --token "$TOKEN" --domain "$API_URL" --output json --silent 2>/dev/null || echo '[]')"
    if ! echo "$folders_json" | jq -e --arg name "$segment" '.[] | select(.folderName == $name)' >/dev/null 2>&1; then
      if ! infisical secrets folders create --name "$segment" --path "$current" --projectId "$PROJECT_ID" \
        --env "$ENV_NAME" --token "$TOKEN" --domain "$API_URL" --silent >/dev/null 2>&1; then
        echo "FAIL: unable to create folder '$segment' under '$current'"
        return 1
      fi
    fi
    if [[ "$current" == "/" ]]; then
      current="/$segment"
    else
      current="$current/$segment"
    fi
  done
}

echo "secrets.cohort.copy_first"
echo "mode: $([[ "$EXECUTE" -eq 1 ]] && echo execute || echo dry_run)"
echo "project_id: $PROJECT_ID"
echo "environment: $ENV_NAME"
echo "source_path: $ROOT_PATH"
echo "target_path: $TARGET_PATH"
echo

ok=0
skip=0
fail=0
copied=0

if [[ "$EXECUTE" -eq 1 ]]; then
  ensure_folder_hierarchy "$TARGET_PATH" || exit 1
fi

for key in "${COHORT_KEYS[@]}"; do
  root_count="$(secret_count_at_path "$key" "$ROOT_PATH")"
  dst_count="$(secret_count_at_path "$key" "$TARGET_PATH")"

  if (( root_count > 1 )); then
    echo "FAIL: $key duplicated at root path $ROOT_PATH"
    fail=$((fail + 1))
    continue
  fi

  if (( dst_count > 1 )); then
    echo "FAIL: $key duplicated at target path $TARGET_PATH"
    fail=$((fail + 1))
    continue
  fi

  if (( root_count == 0 && dst_count == 0 )); then
    echo "FAIL: $key missing at both root and target"
    fail=$((fail + 1))
    continue
  fi

  if (( root_count == 0 && dst_count == 1 )); then
    echo "SKIP: $key already migrated (root absent, target present)"
    skip=$((skip + 1))
    continue
  fi

  if (( root_count == 1 && dst_count == 1 )); then
    root_val="$(secret_value_at_path "$key" "$ROOT_PATH")"
    dst_val="$(secret_value_at_path "$key" "$TARGET_PATH")"
    if [[ "$root_val" != "$dst_val" ]]; then
      echo "FAIL: $key root/target mismatch"
      fail=$((fail + 1))
    else
      echo "SKIP: $key already copied (parity OK)"
      skip=$((skip + 1))
    fi
    continue
  fi

  # root_count == 1 && dst_count == 0
  if [[ "$EXECUTE" -eq 1 ]]; then
    root_val="$(secret_value_at_path "$key" "$ROOT_PATH")"
    if set_secret_at_path "$key" "$root_val" "$TARGET_PATH"; then
      echo "COPIED: $key -> $TARGET_PATH"
      copied=$((copied + 1))
      ok=$((ok + 1))
    else
      fail=$((fail + 1))
    fi
  else
    echo "READY: $key root copy eligible for namespace copy"
    ok=$((ok + 1))
  fi
done

echo
echo "summary: ok=$ok skip=$skip fail=$fail copied=$copied"

if (( fail > 0 )); then
  echo "status: FAIL"
  exit 1
fi

echo "status: OK"
exit 0
