#!/usr/bin/env bash
# secrets-namespace-status - Infisical namespace hygiene + root-path freeze lock
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
BINDING="$SPINE_REPO/ops/bindings/secrets.binding.yaml"
POLICY="$SPINE_REPO/ops/bindings/secrets.namespace.policy.yaml"
INFISICAL_AGENT="$SPINE_REPO/ops/tools/infisical-agent.sh"

for dep in yq jq; do
  command -v "$dep" >/dev/null 2>&1 || { echo "MISSING_DEP: $dep"; exit 1; }
done
[[ -x "$INFISICAL_AGENT" ]] || { echo "FAIL: infisical-agent.sh not found"; exit 1; }

[[ -f "$BINDING" ]] || { echo "MISSING: $BINDING"; exit 2; }
[[ -f "$POLICY" ]] || { echo "MISSING: $POLICY"; exit 2; }
yq e '.' "$POLICY" >/dev/null 2>&1 || { echo "FAIL: invalid YAML in $POLICY"; exit 1; }

# Binding values
PROJECT_ID="$(yq e -r '.infisical.project // ""' "$BINDING")"
ENV_NAME="$(yq e -r '.infisical.environment // ""' "$BINDING")"
BASE_PATH="$(yq e -r '.infisical.base_path // ""' "$BINDING")"

# Policy values
POLICY_PROJECT_ID="$(yq e -r '.infisical.project_id // ""' "$POLICY")"
POLICY_ENV_NAME="$(yq e -r '.infisical.environment // ""' "$POLICY")"
POLICY_BASE_PATH="$(yq e -r '.namespace.canonical_base_path // ""' "$POLICY")"
ROOT_PATH="$(yq e -r '.freeze.root_path // "/"' "$POLICY")"

[[ -n "$PROJECT_ID" && -n "$ENV_NAME" && -n "$BASE_PATH" ]] || {
  echo "STOP: incomplete secrets binding"
  exit 2
}
[[ -n "$POLICY_PROJECT_ID" && -n "$POLICY_ENV_NAME" && -n "$POLICY_BASE_PATH" ]] || {
  echo "STOP: incomplete secrets namespace policy"
  exit 2
}

if [[ "$PROJECT_ID" != "$POLICY_PROJECT_ID" || "$ENV_NAME" != "$POLICY_ENV_NAME" ]]; then
  echo "FAIL: binding/project env mismatch between secrets.binding.yaml and secrets.namespace.policy.yaml"
  exit 1
fi

if [[ "$BASE_PATH" != "$POLICY_BASE_PATH" ]]; then
  echo "FAIL: base_path mismatch (binding=$BASE_PATH policy=$POLICY_BASE_PATH)"
  exit 1
fi

# Fetch secrets via canonical agent
RAW_JSON=$("$INFISICAL_AGENT" list-recursive infrastructure prod 2>/dev/null) || {
  echo "FAIL: list-recursive failed"; exit 1
}

if ! echo "$RAW_JSON" | jq -e '.secrets' >/dev/null 2>&1; then
  echo "FAIL: invalid JSON from list-recursive"
  exit 1
fi

TOTAL="$(echo "$RAW_JSON" | jq -r '.secrets | length')"
ROOT_COUNT="$(echo "$RAW_JSON" | jq -r --arg root "$ROOT_PATH" '[.secrets[] | select((.secretPath // "/") == $root)] | length')"

mapfile -t LIVE_ROOT_KEYS < <(echo "$RAW_JSON" | jq -r --arg root "$ROOT_PATH" '.secrets[] | select((.secretPath // "/") == $root) | .secretKey' | sort -u)
mapfile -t BASELINE_ROOT_KEYS < <(yq e -r '.freeze.allowed_root_keys[]' "$POLICY" 2>/dev/null || true)
mapfile -t REQUIRED_KEYS < <(yq e -r '.rules.required_key_paths | keys | .[]' "$POLICY" 2>/dev/null || true)
mapfile -t FORBIDDEN_PREFIXES < <(yq e -r '.rules.forbidden_root_prefixes[]' "$POLICY" 2>/dev/null || true)
mapfile -t FORBIDDEN_ROOT_KEYS < <(yq e -r '.rules.forbidden_root_keys[]?' "$POLICY" 2>/dev/null || true)

echo "secrets.namespace.status"
echo "project_id: $PROJECT_ID"
echo "environment: $ENV_NAME"
echo "base_path: $BASE_PATH"
echo "total_keys: $TOTAL"
echo "root_path: $ROOT_PATH"
echo "root_path_keys: $ROOT_COUNT"
echo

echo "path_distribution:"
echo "$RAW_JSON" | jq -r '.secrets[] | (.secretPath // "/")' | sort | uniq -c | sort -nr | awk '{print "  - path: "$2" count: "$1}'

FAILURES=0

echo
for key in "${REQUIRED_KEYS[@]}"; do
  required_path="$(yq e -r ".rules.required_key_paths.${key} // \"\"" "$POLICY")"
  mapfile -t key_paths < <(echo "$RAW_JSON" | jq -r --arg k "$key" '.secrets[] | select(.secretKey == $k) | (.secretPath // "/")')

  if (( ${#key_paths[@]} == 0 )); then
    echo "FAIL: missing required key: $key"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  found_required=0
  for p in "${key_paths[@]}"; do
    [[ "$p" == "$required_path" ]] && found_required=1
    if [[ "$p" == "$ROOT_PATH" ]]; then
      echo "FAIL: $key present at root path '$ROOT_PATH'"
      FAILURES=$((FAILURES + 1))
    fi
  done

  if (( found_required == 0 )); then
    echo "FAIL: $key not found at required path: $required_path"
    FAILURES=$((FAILURES + 1))
  else
    echo "PASS: $key namespaced at $required_path"
  fi
done

echo
for prefix in "${FORBIDDEN_PREFIXES[@]}"; do
  mapfile -t prefix_hits < <(echo "$RAW_JSON" | jq -r --arg p "$prefix" --arg root "$ROOT_PATH" '.secrets[] | select((.secretPath // "/") == $root and (.secretKey | startswith($p))) | .secretKey' | sort -u)
  if (( ${#prefix_hits[@]} > 0 )); then
    echo "FAIL: forbidden prefix at root '$ROOT_PATH': $prefix"
    for k in "${prefix_hits[@]}"; do
      echo "  - $k"
    done
    FAILURES=$((FAILURES + 1))
  fi
done

for key in "${FORBIDDEN_ROOT_KEYS[@]}"; do
  [[ -n "$key" && "$key" != "null" ]] || continue
  if echo "$RAW_JSON" | jq -e --arg k "$key" --arg root "$ROOT_PATH" \
      '.secrets[] | select((.secretPath // "/") == $root and .secretKey == $k)' >/dev/null 2>&1; then
    echo "FAIL: forbidden root key present at '$ROOT_PATH': $key"
    FAILURES=$((FAILURES + 1))
  fi
done

# Root freeze check: block any new root-path keys not in baseline snapshot.
declare -A BASELINE_SET=()
for k in "${BASELINE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] && BASELINE_SET["$k"]=1
done

ADDED_ROOT_KEYS=()
for k in "${LIVE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] || continue
  if [[ -z "${BASELINE_SET[$k]:-}" ]]; then
    ADDED_ROOT_KEYS+=("$k")
  fi
done

declare -A LIVE_SET=()
for k in "${LIVE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] && LIVE_SET["$k"]=1
done

REMOVED_ROOT_KEYS=()
for k in "${BASELINE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] || continue
  if [[ -z "${LIVE_SET[$k]:-}" ]]; then
    REMOVED_ROOT_KEYS+=("$k")
  fi
done

echo
if (( ${#ADDED_ROOT_KEYS[@]} > 0 )); then
  echo "FAIL: new root-path keys detected (not in frozen baseline):"
  for k in "${ADDED_ROOT_KEYS[@]}"; do
    echo "  - $k"
  done
  FAILURES=$((FAILURES + 1))
else
  echo "PASS: no new root-path keys beyond frozen baseline"
fi

echo "baseline_root_keys: ${#BASELINE_ROOT_KEYS[@]}"
echo "current_root_keys: ${#LIVE_ROOT_KEYS[@]}"
echo "removed_root_keys: ${#REMOVED_ROOT_KEYS[@]}"

if (( FAILURES > 0 )); then
  echo
  echo "status: FAIL"
  exit 1
fi

echo
if (( ROOT_COUNT > 0 )); then
  echo "status: OK_WITH_LEGACY_DEBT"
  echo "note: root-path legacy debt remains frozen; migrate keys to /spine/* in phases"
  exit 0
fi

echo "status: OK"
exit 0
