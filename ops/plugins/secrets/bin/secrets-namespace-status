#!/usr/bin/env bash
# secrets-namespace-status - Infisical namespace hygiene + root-path freeze lock
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
BINDING="$SPINE_REPO/ops/bindings/secrets.binding.yaml"
POLICY="$SPINE_REPO/ops/bindings/secrets.namespace.policy.yaml"
CREDENTIALS_FILE="${HOME}/.config/infisical/credentials"

for dep in yq jq curl; do
  command -v "$dep" >/dev/null 2>&1 || { echo "MISSING_DEP: $dep"; exit 1; }
done

[[ -f "$BINDING" ]] || { echo "MISSING: $BINDING"; exit 2; }
[[ -f "$POLICY" ]] || { echo "MISSING: $POLICY"; exit 2; }
yq e '.' "$POLICY" >/dev/null 2>&1 || { echo "FAIL: invalid YAML in $POLICY"; exit 1; }

# Always source canonical credentials so rotated values override stale shell vars.
if [[ -f "$CREDENTIALS_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CREDENTIALS_FILE"
fi

# Binding values (prefer internal API URL to bypass forward-auth)
API_URL="$(yq e -r '.infisical.internal_api_url // .infisical.api_url // ""' "$BINDING")"
PROJECT_ID="$(yq e -r '.infisical.project // ""' "$BINDING")"
ENV_NAME="$(yq e -r '.infisical.environment // ""' "$BINDING")"
BASE_PATH="$(yq e -r '.infisical.base_path // ""' "$BINDING")"

# Policy values
POLICY_PROJECT_ID="$(yq e -r '.infisical.project_id // ""' "$POLICY")"
POLICY_ENV_NAME="$(yq e -r '.infisical.environment // ""' "$POLICY")"
POLICY_BASE_PATH="$(yq e -r '.namespace.canonical_base_path // ""' "$POLICY")"
ROOT_PATH="$(yq e -r '.freeze.root_path // "/"' "$POLICY")"

CLIENT_ID="${INFISICAL_UNIVERSAL_AUTH_CLIENT_ID:-}"
CLIENT_SECRET="${INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET:-}"

[[ -n "$API_URL" && -n "$PROJECT_ID" && -n "$ENV_NAME" && -n "$BASE_PATH" ]] || {
  echo "STOP: incomplete secrets binding"
  exit 2
}
[[ -n "$POLICY_PROJECT_ID" && -n "$POLICY_ENV_NAME" && -n "$POLICY_BASE_PATH" ]] || {
  echo "STOP: incomplete secrets namespace policy"
  exit 2
}
[[ -n "$CLIENT_ID" && -n "$CLIENT_SECRET" ]] || {
  echo "STOP: missing Infisical auth variables"
  exit 2
}

if [[ "$PROJECT_ID" != "$POLICY_PROJECT_ID" || "$ENV_NAME" != "$POLICY_ENV_NAME" ]]; then
  echo "FAIL: binding/project env mismatch between secrets.binding.yaml and secrets.namespace.policy.yaml"
  exit 1
fi

if [[ "$BASE_PATH" != "$POLICY_BASE_PATH" ]]; then
  echo "FAIL: base_path mismatch (binding=$BASE_PATH policy=$POLICY_BASE_PATH)"
  exit 1
fi

# Authenticate (capture code/body for clearer errors)
auth_response="$(curl -s -w '\n%{http_code}' -X POST "$API_URL/api/v1/auth/universal-auth/login" \
  -H 'Content-Type: application/json' \
  -d "{\"clientId\":\"$CLIENT_ID\",\"clientSecret\":\"$CLIENT_SECRET\"}")"
auth_code="$(echo "$auth_response" | tail -n1)"
auth_body="$(echo "$auth_response" | sed '$d')"

if [[ "$auth_code" =~ ^30[1278]$ ]]; then
  echo "STOP: api_redirected (HTTP $auth_code) api_url=$API_URL"
  echo "fix: set ops/bindings/secrets.binding.yaml infisical.internal_api_url to a direct API endpoint (bypasses Authentik forward-auth)"
  exit 2
fi

if [[ "$auth_code" != "200" ]]; then
  if ! echo "$auth_body" | jq -e . >/dev/null 2>&1; then
    echo "FAIL: Infisical auth failed (HTTP $auth_code): non_json_response"
    exit 1
  fi
  msg="$(echo "$auth_body" | jq -r '.message // "auth failed"' 2>/dev/null || echo 'auth failed')"
  echo "FAIL: Infisical auth failed (HTTP $auth_code): $msg"
  exit 1
fi

if ! echo "$auth_body" | jq -e . >/dev/null 2>&1; then
  echo "FAIL: Infisical auth failed (HTTP 200): non_json_response"
  exit 1
fi

TOKEN="$(echo "$auth_body" | jq -r '.accessToken // empty')"
[[ -n "$TOKEN" ]] || { echo "FAIL: auth token unavailable"; exit 1; }

list_response="$(curl -s -w '\n%{http_code}' "$API_URL/api/v3/secrets/raw?workspaceId=$PROJECT_ID&environment=$ENV_NAME&recursive=true" \
  -H "Authorization: Bearer $TOKEN")"
list_code="$(echo "$list_response" | tail -n1)"
list_body="$(echo "$list_response" | sed '$d')"

if [[ "$list_code" =~ ^30[1278]$ ]]; then
  echo "STOP: api_redirected (HTTP $list_code) api_url=$API_URL"
  echo "fix: set ops/bindings/secrets.binding.yaml infisical.internal_api_url to a direct API endpoint (bypasses Authentik forward-auth)"
  exit 2
fi

if [[ "$list_code" != "200" ]]; then
  if ! echo "$list_body" | jq -e . >/dev/null 2>&1; then
    echo "FAIL: unable to list secrets (HTTP $list_code): non_json_response"
    exit 1
  fi
  msg="$(echo "$list_body" | jq -r '.message // "list failed"' 2>/dev/null || echo 'list failed')"
  echo "FAIL: unable to list secrets (HTTP $list_code): $msg"
  exit 1
fi

if ! echo "$list_body" | jq -e . >/dev/null 2>&1; then
  echo "FAIL: unable to list secrets (HTTP 200): non_json_response"
  exit 1
fi

RAW_JSON="$list_body"

TOTAL="$(echo "$RAW_JSON" | jq -r '.secrets | length')"
ROOT_COUNT="$(echo "$RAW_JSON" | jq -r --arg root "$ROOT_PATH" '[.secrets[] | select((.secretPath // "/") == $root)] | length')"

mapfile -t LIVE_ROOT_KEYS < <(echo "$RAW_JSON" | jq -r --arg root "$ROOT_PATH" '.secrets[] | select((.secretPath // "/") == $root) | .secretKey' | sort -u)
mapfile -t BASELINE_ROOT_KEYS < <(yq e -r '.freeze.allowed_root_keys[]' "$POLICY" 2>/dev/null || true)
mapfile -t REQUIRED_KEYS < <(yq e -r '.rules.required_key_paths | keys | .[]' "$POLICY" 2>/dev/null || true)
mapfile -t FORBIDDEN_PREFIXES < <(yq e -r '.rules.forbidden_root_prefixes[]' "$POLICY" 2>/dev/null || true)
mapfile -t FORBIDDEN_ROOT_KEYS < <(yq e -r '.rules.forbidden_root_keys[]?' "$POLICY" 2>/dev/null || true)

echo "secrets.namespace.status"
echo "project_id: $PROJECT_ID"
echo "environment: $ENV_NAME"
echo "base_path: $BASE_PATH"
echo "total_keys: $TOTAL"
echo "root_path: $ROOT_PATH"
echo "root_path_keys: $ROOT_COUNT"
echo

echo "path_distribution:"
echo "$RAW_JSON" | jq -r '.secrets[] | (.secretPath // "/")' | sort | uniq -c | sort -nr | awk '{print "  - path: "$2" count: "$1}'

FAILURES=0

echo
for key in "${REQUIRED_KEYS[@]}"; do
  required_path="$(yq e -r ".rules.required_key_paths.${key} // \"\"" "$POLICY")"
  mapfile -t key_paths < <(echo "$RAW_JSON" | jq -r --arg k "$key" '.secrets[] | select(.secretKey == $k) | (.secretPath // "/")')

  if (( ${#key_paths[@]} == 0 )); then
    echo "FAIL: missing required key: $key"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  found_required=0
  for p in "${key_paths[@]}"; do
    [[ "$p" == "$required_path" ]] && found_required=1
    if [[ "$p" == "$ROOT_PATH" ]]; then
      echo "FAIL: $key present at root path '$ROOT_PATH'"
      FAILURES=$((FAILURES + 1))
    fi
  done

  if (( found_required == 0 )); then
    echo "FAIL: $key not found at required path: $required_path"
    FAILURES=$((FAILURES + 1))
  else
    echo "PASS: $key namespaced at $required_path"
  fi
done

echo
for prefix in "${FORBIDDEN_PREFIXES[@]}"; do
  mapfile -t prefix_hits < <(echo "$RAW_JSON" | jq -r --arg p "$prefix" --arg root "$ROOT_PATH" '.secrets[] | select((.secretPath // "/") == $root and (.secretKey | startswith($p))) | .secretKey' | sort -u)
  if (( ${#prefix_hits[@]} > 0 )); then
    echo "FAIL: forbidden prefix at root '$ROOT_PATH': $prefix"
    for k in "${prefix_hits[@]}"; do
      echo "  - $k"
    done
    FAILURES=$((FAILURES + 1))
  fi
done

for key in "${FORBIDDEN_ROOT_KEYS[@]}"; do
  [[ -n "$key" && "$key" != "null" ]] || continue
  if echo "$RAW_JSON" | jq -e --arg k "$key" --arg root "$ROOT_PATH" \
      '.secrets[] | select((.secretPath // "/") == $root and .secretKey == $k)' >/dev/null 2>&1; then
    echo "FAIL: forbidden root key present at '$ROOT_PATH': $key"
    FAILURES=$((FAILURES + 1))
  fi
done

# Root freeze check: block any new root-path keys not in baseline snapshot.
declare -A BASELINE_SET=()
for k in "${BASELINE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] && BASELINE_SET["$k"]=1
done

ADDED_ROOT_KEYS=()
for k in "${LIVE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] || continue
  if [[ -z "${BASELINE_SET[$k]:-}" ]]; then
    ADDED_ROOT_KEYS+=("$k")
  fi
done

declare -A LIVE_SET=()
for k in "${LIVE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] && LIVE_SET["$k"]=1
done

REMOVED_ROOT_KEYS=()
for k in "${BASELINE_ROOT_KEYS[@]}"; do
  [[ -n "$k" ]] || continue
  if [[ -z "${LIVE_SET[$k]:-}" ]]; then
    REMOVED_ROOT_KEYS+=("$k")
  fi
done

echo
if (( ${#ADDED_ROOT_KEYS[@]} > 0 )); then
  echo "FAIL: new root-path keys detected (not in frozen baseline):"
  for k in "${ADDED_ROOT_KEYS[@]}"; do
    echo "  - $k"
  done
  FAILURES=$((FAILURES + 1))
else
  echo "PASS: no new root-path keys beyond frozen baseline"
fi

echo "baseline_root_keys: ${#BASELINE_ROOT_KEYS[@]}"
echo "current_root_keys: ${#LIVE_ROOT_KEYS[@]}"
echo "removed_root_keys: ${#REMOVED_ROOT_KEYS[@]}"

if (( FAILURES > 0 )); then
  echo
  echo "status: FAIL"
  exit 1
fi

echo
if (( ROOT_COUNT > 0 )); then
  echo "status: OK_WITH_LEGACY_DEBT"
  echo "note: root-path legacy debt remains frozen; migrate keys to /spine/* in phases"
  exit 0
fi

echo "status: OK"
exit 0
