#!/usr/bin/env bash
# secrets-p1-root-cleanup - guarded cleanup for P1 keys at root path '/'
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
POLICY="$SPINE_REPO/ops/bindings/secrets.namespace.policy.yaml"
CREDENTIALS_FILE="${HOME}/.config/infisical/credentials"
EXECUTE=0
TARGET_PATH="/spine/platform/security"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --execute)
      EXECUTE=1
      shift
      ;;
    --target-path)
      TARGET_PATH="${2:-}"
      [[ -n "$TARGET_PATH" ]] || { echo "FAIL: --target-path requires a value"; exit 1; }
      shift 2
      ;;
    *)
      echo "FAIL: unknown argument: $1"
      exit 1
      ;;
  esac
done

for dep in yq curl jq; do
  command -v "$dep" >/dev/null 2>&1 || { echo "MISSING_DEP: $dep"; exit 1; }
done
[[ -f "$POLICY" ]] || { echo "MISSING: $POLICY"; exit 2; }
yq e '.' "$POLICY" >/dev/null 2>&1 || { echo "FAIL: invalid policy YAML"; exit 1; }

if [[ -f "$CREDENTIALS_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CREDENTIALS_FILE"
fi

PROJECT_ID="$(yq e -r '.infisical.project_id // ""' "$POLICY")"
ENV_NAME="$(yq e -r '.infisical.environment // ""' "$POLICY")"
ROOT_PATH="$(yq e -r '.freeze.root_path // "/"' "$POLICY")"
API_URL="${INFISICAL_API_URL:-https://secrets.ronny.works}"
CLIENT_ID="${INFISICAL_UNIVERSAL_AUTH_CLIENT_ID:-}"
CLIENT_SECRET="${INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET:-}"

[[ -n "$PROJECT_ID" && -n "$ENV_NAME" ]] || { echo "FAIL: policy missing project/env"; exit 1; }
[[ -n "$CLIENT_ID" && -n "$CLIENT_SECRET" ]] || { echo "FAIL: missing Infisical auth variables"; exit 1; }

mapfile -t COHORT_KEYS < <(yq e -r ".rules.key_path_overrides | to_entries[] | select(.value == \"$TARGET_PATH\") | .key" "$POLICY" 2>/dev/null || true)
(( ${#COHORT_KEYS[@]} > 0 )) || { echo "FAIL: no keys found in policy overrides for target path $TARGET_PATH"; exit 1; }

auth_resp="$(curl -s -w '\n%{http_code}' -X POST "$API_URL/api/v1/auth/universal-auth/login" \
  -H 'Content-Type: application/json' \
  -d "{\"clientId\":\"$CLIENT_ID\",\"clientSecret\":\"$CLIENT_SECRET\"}")"
auth_code="$(echo "$auth_resp" | tail -n1)"
auth_body="$(echo "$auth_resp" | sed '$d')"
[[ "$auth_code" == "200" ]] || { echo "FAIL: auth failed (HTTP $auth_code)"; exit 1; }
TOKEN="$(echo "$auth_body" | jq -r '.accessToken // empty')"
[[ -n "$TOKEN" ]] || { echo "FAIL: missing access token"; exit 1; }

list_resp="$(curl -s -w '\n%{http_code}' "$API_URL/api/v3/secrets/raw?workspaceId=$PROJECT_ID&environment=$ENV_NAME&recursive=true" \
  -H "Authorization: Bearer $TOKEN")"
list_code="$(echo "$list_resp" | tail -n1)"
list_body="$(echo "$list_resp" | sed '$d')"
[[ "$list_code" == "200" ]] || { echo "FAIL: unable to list secrets (HTTP $list_code)"; exit 1; }
RAW_JSON="$list_body"

secret_count_at_path() {
  local key="$1"
  local path="$2"
  echo "$RAW_JSON" | jq -r --arg k "$key" --arg p "$path" \
    '[.secrets[] | select(.secretKey == $k and (.secretPath // "/") == $p)] | length'
}

secret_value_at_path() {
  local key="$1"
  local path="$2"
  echo "$RAW_JSON" | jq -r --arg k "$key" --arg p "$path" \
    '[.secrets[] | select(.secretKey == $k and (.secretPath // "/") == $p) | .secretValue] | if length > 0 then .[0] else "" end'
}

echo "secrets.p1.root_cleanup"
echo "mode: $([[ "$EXECUTE" -eq 1 ]] && echo execute || echo dry_run)"
echo "project_id: $PROJECT_ID"
echo "environment: $ENV_NAME"
echo "root_path: $ROOT_PATH"
echo "target_path: $TARGET_PATH"
echo

ok=0
skip=0
fail=0
deleted=0

for key in "${COHORT_KEYS[@]}"; do
  dst_path="$(yq e -r ".rules.key_path_overrides.${key} // \"\"" "$POLICY")"
  [[ -n "$dst_path" && "$dst_path" != "null" ]] || {
    echo "FAIL: $key missing destination path in policy"
    fail=$((fail + 1))
    continue
  }

  dst_count="$(secret_count_at_path "$key" "$dst_path")"
  root_count="$(secret_count_at_path "$key" "$ROOT_PATH")"

  if (( dst_count == 0 )); then
    echo "FAIL: $key missing at destination path $dst_path"
    fail=$((fail + 1))
    continue
  fi

  if (( dst_count > 1 )); then
    echo "FAIL: $key duplicated at destination path $dst_path"
    fail=$((fail + 1))
    continue
  fi

  if (( root_count == 0 )); then
    echo "SKIP: $key already absent at root"
    skip=$((skip + 1))
    continue
  fi

  if (( root_count > 1 )); then
    echo "FAIL: $key duplicated at root path $ROOT_PATH"
    fail=$((fail + 1))
    continue
  fi

  root_val="$(secret_value_at_path "$key" "$ROOT_PATH")"
  dst_val="$(secret_value_at_path "$key" "$dst_path")"

  if [[ "$root_val" != "$dst_val" ]]; then
    echo "FAIL: $key root/destination mismatch"
    fail=$((fail + 1))
    continue
  fi

  if [[ "$EXECUTE" -eq 1 ]]; then
    del_resp="$(curl -s -w '\n%{http_code}' -X DELETE "$API_URL/api/v3/secrets/raw/$key" \
      -H "Authorization: Bearer $TOKEN" \
      -H 'Content-Type: application/json' \
      -d "{\"workspaceId\":\"$PROJECT_ID\",\"environment\":\"$ENV_NAME\",\"secretPath\":\"$ROOT_PATH\"}")"
    del_code="$(echo "$del_resp" | tail -n1)"
    del_body="$(echo "$del_resp" | sed '$d')"
    if [[ "$del_code" == "200" ]] && echo "$del_body" | jq -e '.secret' >/dev/null 2>&1; then
      echo "DELETED: $key from root"
      deleted=$((deleted + 1))
      ok=$((ok + 1))
    else
      msg="$(echo "$del_body" | jq -r '.message // "delete failed"' 2>/dev/null || echo 'delete failed')"
      if [[ "$msg" == *"Secret not found"* ]]; then
        echo "SKIP: $key already absent at root (delete returned not found)"
        skip=$((skip + 1))
      else
        echo "FAIL: delete failed for $key ($msg)"
        fail=$((fail + 1))
      fi
    fi
  else
    echo "READY: $key root copy eligible for delete"
    ok=$((ok + 1))
  fi
done

echo
echo "summary: ok=$ok skip=$skip fail=$fail deleted=$deleted"

if (( fail > 0 )); then
  echo "status: FAIL"
  exit 1
fi

echo "status: OK"
exit 0
