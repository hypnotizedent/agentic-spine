#!/usr/bin/env bash
# secrets-p1-root-cleanup - guarded cleanup for P1 keys at root path '/'
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
POLICY="$SPINE_REPO/ops/bindings/secrets.namespace.policy.yaml"
INFISICAL_AGENT="$SPINE_REPO/ops/tools/infisical-agent.sh"
EXECUTE=0
TARGET_PATH="/spine/platform/security"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --execute)
      EXECUTE=1
      shift
      ;;
    --target-path)
      TARGET_PATH="${2:-}"
      [[ -n "$TARGET_PATH" ]] || { echo "FAIL: --target-path requires a value"; exit 1; }
      shift 2
      ;;
    *)
      echo "FAIL: unknown argument: $1"
      exit 1
      ;;
  esac
done

for dep in yq jq curl; do
  command -v "$dep" >/dev/null 2>&1 || { echo "MISSING_DEP: $dep"; exit 1; }
done
[[ -x "$INFISICAL_AGENT" ]] || { echo "FAIL: infisical-agent.sh not found"; exit 1; }
[[ -f "$POLICY" ]] || { echo "MISSING: $POLICY"; exit 2; }
yq e '.' "$POLICY" >/dev/null 2>&1 || { echo "FAIL: invalid policy YAML"; exit 1; }

PROJECT_ID="$(yq e -r '.infisical.project_id // ""' "$POLICY")"
ENV_NAME="$(yq e -r '.infisical.environment // ""' "$POLICY")"
ROOT_PATH="$(yq e -r '.freeze.root_path // "/"' "$POLICY")"

[[ -n "$PROJECT_ID" && -n "$ENV_NAME" ]] || { echo "FAIL: policy missing project/env"; exit 1; }

mapfile -t COHORT_KEYS < <(yq e -r ".rules.key_path_overrides | to_entries[] | select(.value == \"$TARGET_PATH\") | .key" "$POLICY" 2>/dev/null || true)
(( ${#COHORT_KEYS[@]} > 0 )) || { echo "FAIL: no keys found in policy overrides for target path $TARGET_PATH"; exit 1; }

# Auth + list via canonical agent (TOKEN kept for delete calls)
TOKEN=$("$INFISICAL_AGENT" auth-token 2>/dev/null) || true
[[ -n "$TOKEN" ]] || { echo "FAIL: auth-token failed"; exit 1; }

RAW_JSON=$("$INFISICAL_AGENT" list-recursive infrastructure prod 2>/dev/null) || {
  echo "FAIL: list-recursive failed"; exit 1
}
echo "$RAW_JSON" | jq -e '.secrets' >/dev/null 2>&1 || { echo "FAIL: invalid JSON from list-recursive"; exit 1; }

# Resolve API URL for delete calls (agent handles auth, but delete needs direct curl)
BINDING="$SPINE_REPO/ops/bindings/secrets.binding.yaml"
API_URL="$(yq e -r '.infisical.internal_api_url // .infisical.api_url // ""' "$BINDING" 2>/dev/null || echo "")"
[[ -n "$API_URL" && "$API_URL" != "null" ]] || API_URL="https://secrets.ronny.works"

secret_count_at_path() {
  local key="$1"
  local path="$2"
  echo "$RAW_JSON" | jq -r --arg k "$key" --arg p "$path" \
    '[.secrets[] | select(.secretKey == $k and (.secretPath // "/") == $p)] | length'
}

secret_value_at_path() {
  local key="$1"
  local path="$2"
  echo "$RAW_JSON" | jq -r --arg k "$key" --arg p "$path" \
    '[.secrets[] | select(.secretKey == $k and (.secretPath // "/") == $p) | .secretValue] | if length > 0 then .[0] else "" end'
}

echo "secrets.p1.root_cleanup"
echo "mode: $([[ "$EXECUTE" -eq 1 ]] && echo execute || echo dry_run)"
echo "project_id: $PROJECT_ID"
echo "environment: $ENV_NAME"
echo "root_path: $ROOT_PATH"
echo "target_path: $TARGET_PATH"
echo

ok=0
skip=0
fail=0
deleted=0

for key in "${COHORT_KEYS[@]}"; do
  dst_path="$(yq e -r ".rules.key_path_overrides.${key} // \"\"" "$POLICY")"
  [[ -n "$dst_path" && "$dst_path" != "null" ]] || {
    echo "FAIL: $key missing destination path in policy"
    fail=$((fail + 1))
    continue
  }

  dst_count="$(secret_count_at_path "$key" "$dst_path")"
  root_count="$(secret_count_at_path "$key" "$ROOT_PATH")"

  if (( dst_count == 0 )); then
    echo "FAIL: $key missing at destination path $dst_path"
    fail=$((fail + 1))
    continue
  fi

  if (( dst_count > 1 )); then
    echo "FAIL: $key duplicated at destination path $dst_path"
    fail=$((fail + 1))
    continue
  fi

  if (( root_count == 0 )); then
    echo "SKIP: $key already absent at root"
    skip=$((skip + 1))
    continue
  fi

  if (( root_count > 1 )); then
    echo "FAIL: $key duplicated at root path $ROOT_PATH"
    fail=$((fail + 1))
    continue
  fi

  root_val="$(secret_value_at_path "$key" "$ROOT_PATH")"
  dst_val="$(secret_value_at_path "$key" "$dst_path")"

  if [[ "$root_val" != "$dst_val" ]]; then
    echo "FAIL: $key root/destination mismatch"
    fail=$((fail + 1))
    continue
  fi

  if [[ "$EXECUTE" -eq 1 ]]; then
    del_resp="$(curl -s -w '\n%{http_code}' -X DELETE "$API_URL/api/v3/secrets/raw/$key" \
      -H "Authorization: Bearer $TOKEN" \
      -H 'Content-Type: application/json' \
      -d "{\"workspaceId\":\"$PROJECT_ID\",\"environment\":\"$ENV_NAME\",\"secretPath\":\"$ROOT_PATH\"}")"
    del_code="$(echo "$del_resp" | tail -n1)"
    del_body="$(echo "$del_resp" | sed '$d')"
    if [[ "$del_code" == "200" ]] && echo "$del_body" | jq -e '.secret' >/dev/null 2>&1; then
      echo "DELETED: $key from root"
      deleted=$((deleted + 1))
      ok=$((ok + 1))
    else
      msg="$(echo "$del_body" | jq -r '.message // "delete failed"' 2>/dev/null || echo 'delete failed')"
      if [[ "$msg" == *"Secret not found"* ]]; then
        echo "SKIP: $key already absent at root (delete returned not found)"
        skip=$((skip + 1))
      else
        echo "FAIL: delete failed for $key ($msg)"
        fail=$((fail + 1))
      fi
    fi
  else
    echo "READY: $key root copy eligible for delete"
    ok=$((ok + 1))
  fi
done

echo
echo "summary: ok=$ok skip=$skip fail=$fail deleted=$deleted"

if (( fail > 0 )); then
  echo "status: FAIL"
  exit 1
fi

echo "status: OK"
exit 0
