#!/usr/bin/env bash
# secrets-runway-status - Container/domain secret normalization runway audit.
#
# Validates three things:
#  1) Domain critical key presence across active projects.
#  2) Compose stack secret-like env keys across all declared docker targets.
#  3) Canonical route enforcement (project/path) + onboarding guidance.
#
# No mutation. No secret values printed.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"

COMPOSE_BINDING="$SPINE_ROOT/ops/bindings/docker.compose.targets.yaml"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
POLICY_BINDING="$SPINE_ROOT/ops/bindings/secrets.namespace.policy.yaml"
INVENTORY_BINDING="$SPINE_ROOT/ops/bindings/secrets.inventory.yaml"
RUNWAY_BINDING="$SPINE_ROOT/ops/bindings/secrets.runway.contract.yaml"
INFISICAL_AGENT="$SPINE_ROOT/ops/tools/infisical-agent.sh"

TARGET_FILTER=""
ALLOW_UNREACHABLE=0
STRICT_UNREGISTERED=""
FAIL_ON_AMBIGUOUS=""
STRICT_UNREACHABLE=""

usage() {
  cat <<'EOF'
secrets.runway.status

Usage:
  secrets-runway-status [--target <target_id>] [--allow-unreachable] [--strict-unregistered] [--warn-unregistered]

Options:
  --target <id>            Audit only one docker.compose target from binding.
  --allow-unreachable      Do not fail when target SSH/stack is unreachable.
  --strict-unregistered    Fail when secret-like keys are inferred/not explicitly registered.
  --warn-unregistered      Warn only for inferred/not explicitly registered keys.
  -h, --help               Show this help.
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --target)
      TARGET_FILTER="${2:-}"
      [[ -n "$TARGET_FILTER" ]] || { echo "STOP (2): --target requires value"; exit 2; }
      shift 2
      ;;
    --allow-unreachable)
      ALLOW_UNREACHABLE=1
      shift
      ;;
    --strict-unregistered)
      STRICT_UNREGISTERED="true"
      shift
      ;;
    --warn-unregistered)
      STRICT_UNREGISTERED="false"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "STOP (2): unknown arg: $1"
      usage
      exit 2
      ;;
  esac
done

for dep in yq jq ssh python3; do
  command -v "$dep" >/dev/null 2>&1 || { echo "STOP (2): missing dependency: $dep"; exit 2; }
done

for f in "$COMPOSE_BINDING" "$SSH_BINDING" "$POLICY_BINDING" "$INVENTORY_BINDING" "$RUNWAY_BINDING"; do
  [[ -f "$f" ]] || { echo "STOP (2): missing binding: $f"; exit 2; }
done
[[ -x "$INFISICAL_AGENT" ]] || { echo "STOP (2): missing executable: $INFISICAL_AGENT"; exit 2; }

# Defaults from runway contract, overridden by flags.
STRICT_UNREACHABLE="$(yq e -r '.defaults.strict_unreachable_targets // true' "$RUNWAY_BINDING")"
[[ "$STRICT_UNREACHABLE" == "true" || "$STRICT_UNREACHABLE" == "false" ]] || STRICT_UNREACHABLE="true"
if [[ -z "$STRICT_UNREGISTERED" ]]; then
  STRICT_UNREGISTERED="$(yq e -r '.defaults.strict_unregistered_secret_keys // false' "$RUNWAY_BINDING")"
fi
[[ "$STRICT_UNREGISTERED" == "true" || "$STRICT_UNREGISTERED" == "false" ]] || STRICT_UNREGISTERED="false"
FAIL_ON_AMBIGUOUS="$(yq e -r '.defaults.fail_on_ambiguous_keys // true' "$RUNWAY_BINDING")"
[[ "$FAIL_ON_AMBIGUOUS" == "true" || "$FAIL_ON_AMBIGUOUS" == "false" ]] || FAIL_ON_AMBIGUOUS="true"
if [[ "$ALLOW_UNREACHABLE" -eq 1 ]]; then
  STRICT_UNREACHABLE="false"
fi

# Route maps (explicit).
declare -A KEY_PROJECT KEY_PATH KEY_SOURCE KEY_PRI
declare -A STACK_KEY_PROJECT STACK_KEY_PATH STACK_KEY_SOURCE STACK_KEY_LOOKUP_KEY
set_route() {
  local key="$1" project="$2" path="$3" source="$4" pri="$5"
  [[ -n "$key" && -n "$project" && -n "$path" ]] || return 0
  local old_pri="${KEY_PRI[$key]:-}"
  if [[ -z "$old_pri" || "$pri" -lt "$old_pri" ]]; then
    KEY_PRI["$key"]="$pri"
    KEY_PROJECT["$key"]="$project"
    KEY_PATH["$key"]="$path"
    KEY_SOURCE["$key"]="$source"
  fi
}

# Priority: required (1), key_overrides (2), policy overrides (3), policy planned (4)
while IFS=$'\t' read -r key path; do
  [[ -n "$key" && -n "$path" ]] || continue
  set_route "$key" "infrastructure" "$path" "policy.required" 1
done < <(yq e -r '.rules.required_key_paths | to_entries[]? | [.key, .value] | @tsv' "$POLICY_BINDING")

while IFS=$'\t' read -r key project path; do
  [[ -n "$key" && -n "$project" && -n "$path" ]] || continue
  set_route "$key" "$project" "$path" "contract.key_overrides" 2
done < <(yq e -r '.key_overrides | to_entries[]? | [.key, .value.project, .value.path] | @tsv' "$RUNWAY_BINDING")

while IFS=$'\t' read -r key path; do
  [[ -n "$key" && -n "$path" ]] || continue
  set_route "$key" "infrastructure" "$path" "policy.key_path_overrides" 3
done < <(yq e -r '.rules.key_path_overrides | to_entries[]? | [.key, .value] | @tsv' "$POLICY_BINDING")

while IFS=$'\t' read -r key path; do
  [[ -n "$key" && -n "$path" ]] || continue
  set_route "$key" "infrastructure" "$path" "policy.planned" 4
done < <(yq e -r '.rules.planned_key_paths | to_entries[]? | [.key, .value] | @tsv' "$POLICY_BINDING")

# Stack+key explicit overrides (highest context precision).
while IFS=$'\t' read -r stack key project path lookup_key; do
  [[ -n "$stack" && -n "$key" && -n "$project" && -n "$path" ]] || continue
  STACK_KEY_PROJECT["$stack:$key"]="$project"
  STACK_KEY_PATH["$stack:$key"]="$path"
  STACK_KEY_SOURCE["$stack:$key"]="contract.stack_key_overrides"
  STACK_KEY_LOOKUP_KEY["$stack:$key"]="${lookup_key:-$key}"
done < <(
  yq e -r '
    .stack_key_overrides | to_entries[]? as $stack
    | $stack.value | to_entries[]?
    | [$stack.key, .key, .value.project, .value.path, (.value.canonical_key // .key)] | @tsv
  ' "$RUNWAY_BINDING"
)

# Stack defaults from contract.
declare -A STACK_PROJECT STACK_PATH
while IFS=$'\t' read -r stack project path; do
  [[ -n "$stack" && -n "$project" && -n "$path" ]] || continue
  STACK_PROJECT["$stack"]="$project"
  STACK_PATH["$stack"]="$path"
done < <(yq e -r '.stack_defaults | to_entries[]? | [.key, .value.project, .value.path] | @tsv' "$RUNWAY_BINDING")

# Domain defaults for non-compose checks.
declare -A DOMAIN_PROJECT DOMAIN_PATH
while IFS=$'\t' read -r domain project path; do
  [[ -n "$domain" && -n "$project" && -n "$path" ]] || continue
  DOMAIN_PROJECT["$domain"]="$project"
  DOMAIN_PATH["$domain"]="$path"
done < <(yq e -r '.domain_defaults | to_entries[]? | [.key, .value.project, .value.path] | @tsv' "$RUNWAY_BINDING")

# Active projects: prefer runway list; fallback to inventory non-deprecated/non-overlaps.
declare -A PROJECT_ENV
active_projects_count="$(yq e -r '.active_projects | length' "$RUNWAY_BINDING" 2>/dev/null || echo 0)"
if [[ "$active_projects_count" -gt 0 ]]; then
  while IFS= read -r project; do
    [[ -n "$project" && "$project" != "null" ]] || continue
    PROJECT_ENV["$project"]="$(yq e -r '.defaults.environment // "prod"' "$RUNWAY_BINDING")"
  done < <(yq e -r '.active_projects[]?' "$RUNWAY_BINDING")
else
  while IFS=$'\t' read -r project health; do
    [[ -n "$project" ]] || continue
    if [[ "$health" != "deprecated" && "$health" != "overlaps" ]]; then
      PROJECT_ENV["$project"]="prod"
    fi
  done < <(yq e -r '.projects[]? | [.name, (.project_health // "")] | @tsv' "$INVENTORY_BINDING")
fi

if [[ "${#PROJECT_ENV[@]}" -eq 0 ]]; then
  echo "STOP (2): no active projects resolved for secrets runway"
  exit 2
fi

# Live inventory maps.
declare -A LIVE_PROJECT_KEY_PATHS   # key: project:key -> path1|path2
# keys present in project (set): LIVE_PROJECT_HAS_KEY[project:key]=1
declare -A LIVE_PROJECT_HAS_KEY
# key -> unique projects list as |proj|
declare -A LIVE_KEY_PROJECTS
# key -> first observed path per project list as proj:path|proj:path

auth_fail_projects=()

add_unique_project_for_key() {
  local key="$1" project="$2"
  local blob="${LIVE_KEY_PROJECTS[$key]:-}"
  if [[ "$blob" != *"|$project|"* ]]; then
    LIVE_KEY_PROJECTS["$key"]="${blob}|$project|"
  fi
}

for project in "${!PROJECT_ENV[@]}"; do
  env_name="${PROJECT_ENV[$project]}"
  raw_json="$($INFISICAL_AGENT list-recursive "$project" "$env_name" 2>/dev/null || true)"
  if ! echo "$raw_json" | jq -e '.secrets' >/dev/null 2>&1; then
    auth_fail_projects+=("$project")
    continue
  fi
  while IFS=$'\t' read -r key path; do
    [[ -n "$key" ]] || continue
    [[ -n "$path" && "$path" != "null" ]] || path="/"
    composite="$project:$key"
    LIVE_PROJECT_HAS_KEY["$composite"]=1
    if [[ -n "${LIVE_PROJECT_KEY_PATHS[$composite]:-}" ]]; then
      # de-dupe paths in pipe-delimited list
      if [[ "|${LIVE_PROJECT_KEY_PATHS[$composite]}|" != *"|$path|"* ]]; then
        LIVE_PROJECT_KEY_PATHS["$composite"]+="|$path"
      fi
    else
      LIVE_PROJECT_KEY_PATHS["$composite"]="$path"
    fi
    add_unique_project_for_key "$key" "$project"
  done < <(echo "$raw_json" | jq -r '.secrets[]? | [.secretKey, (.secretPath // "/")] | @tsv')
done

count_projects_for_key() {
  local key="$1"
  local blob="${LIVE_KEY_PROJECTS[$key]:-}"
  if [[ -z "$blob" ]]; then
    echo 0
    return 0
  fi
  # blob format: |a||b| etc
  echo "$blob" | awk -F'|' '{n=0; for(i=1;i<=NF;i++) if($i!="") n++; print n}'
}

first_project_for_key() {
  local key="$1"
  local blob="${LIVE_KEY_PROJECTS[$key]:-}"
  if [[ -z "$blob" ]]; then
    echo ""
    return 0
  fi
  echo "$blob" | awk -F'|' '{for(i=1;i<=NF;i++) if($i!="") {print $i; exit}}'
}

# Secret-like heuristic for runtime env keys.
is_secret_like() {
  local key="$1"
  case "$key" in
    ALLOW_EMPTY_PASSWORD)
      return 1
      ;;
  esac
  case "$key" in
    *_API_KEY|*_TOKEN|*_SECRET|*_PASSWORD|*_PASS|*_PAT|*_PRIVATE_KEY|*_AUTH_KEY|*_ENCRYPTION_KEY|*_CLIENT_SECRET)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# Resolve route for a key in a stack/domain context.
ROUTE_PROJECT=""
ROUTE_PATH=""
ROUTE_SOURCE=""
ROUTE_LOOKUP_KEY=""
resolve_route() {
  local key="$1"
  local stack_hint="${2:-}"
  local domain_hint="${3:-}"

  ROUTE_PROJECT=""
  ROUTE_PATH=""
  ROUTE_SOURCE=""
  ROUTE_LOOKUP_KEY="$key"

  if [[ -n "$stack_hint" ]]; then
    local stack_key="${stack_hint}:${key}"
    if [[ -n "${STACK_KEY_PROJECT[$stack_key]:-}" ]]; then
      ROUTE_PROJECT="${STACK_KEY_PROJECT[$stack_key]}"
      ROUTE_PATH="${STACK_KEY_PATH[$stack_key]}"
      ROUTE_SOURCE="${STACK_KEY_SOURCE[$stack_key]}"
      ROUTE_LOOKUP_KEY="${STACK_KEY_LOOKUP_KEY[$stack_key]:-$key}"
      return 0
    fi
  fi

  if [[ -n "${KEY_PROJECT[$key]:-}" ]]; then
    ROUTE_PROJECT="${KEY_PROJECT[$key]}"
    ROUTE_PATH="${KEY_PATH[$key]}"
    ROUTE_SOURCE="${KEY_SOURCE[$key]}"
    return 0
  fi

  # If domain has explicit default, use it for non-compose checks.
  if [[ -n "$domain_hint" && -n "${DOMAIN_PROJECT[$domain_hint]:-}" ]]; then
    ROUTE_PROJECT="${DOMAIN_PROJECT[$domain_hint]}"
    ROUTE_PATH="${DOMAIN_PATH[$domain_hint]}"
    ROUTE_SOURCE="contract.domain_default"
    return 0
  fi

  # Infer from currently live unique project if exactly one project owns this key.
  local proj_count
  proj_count="$(count_projects_for_key "$key")"
  if [[ "$proj_count" -eq 1 ]]; then
    local p
    p="$(first_project_for_key "$key")"
    local comp="$p:$key"
    local paths="${LIVE_PROJECT_KEY_PATHS[$comp]:-}"
    local first_path
    first_path="$(echo "$paths" | awk -F'|' '{print $1}')"
    [[ -n "$first_path" ]] || first_path="/"
    ROUTE_PROJECT="$p"
    ROUTE_PATH="$first_path"
    ROUTE_SOURCE="live.unique_project"
    return 0
  fi

  # Stack default fallback.
  if [[ -n "$stack_hint" && -n "${STACK_PROJECT[$stack_hint]:-}" ]]; then
    ROUTE_PROJECT="${STACK_PROJECT[$stack_hint]}"
    ROUTE_PATH="${STACK_PATH[$stack_hint]}"
    ROUTE_SOURCE="contract.stack_default"
    return 0
  fi

  # Last resort fallback.
  ROUTE_PROJECT="infrastructure"
  if [[ -n "$stack_hint" ]]; then
    ROUTE_PATH="/spine/services/$stack_hint"
  else
    ROUTE_PATH="/"
  fi
  ROUTE_SOURCE="fallback"
  return 0
}

_classify_ssh_error() {
  local stderr="$1"
  if echo "$stderr" | grep -qiE "permission denied|authentication failed|no more authentication"; then echo "ssh_auth_denied"; return; fi
  if echo "$stderr" | grep -qiE "operation timed out|connection timed out|timed out"; then echo "ssh_timeout"; return; fi
  if echo "$stderr" | grep -qiE "could not resolve hostname|name or service not known"; then echo "ssh_unreachable"; return; fi
  if echo "$stderr" | grep -qiE "connection refused|connection reset|no route"; then echo "ssh_unreachable"; return; fi
  echo "ssh_error"
}

# Evaluate one key against expected route.
FAILURES=0
WARNINGS=0
PASSES=0
CHECKED_KEYS=0
INFERRED_ROUTES=0
UNREGISTERED_KEYS=0
AMBIGUOUS_KEYS=0
UNREACHABLE_STACKS=0

check_key_route() {
  local key="$1"
  local context="$2"    # domain:<name> or stack:<host>/<stack>/<service>
  local stack_hint="${3:-}"
  local domain_hint="${4:-}"

  CHECKED_KEYS=$((CHECKED_KEYS + 1))
  resolve_route "$key" "$stack_hint" "$domain_hint"

  local source="$ROUTE_SOURCE"
  local expected_project="$ROUTE_PROJECT"
  local expected_path="$ROUTE_PATH"
  local lookup_key="${ROUTE_LOOKUP_KEY:-$key}"

  local proj_count
  proj_count="$(count_projects_for_key "$lookup_key")"

  if [[ "$proj_count" -gt 1 && "$source" != policy.* && "$source" != contract.* ]]; then
    local msg="AMBIGUOUS key=$key context=$context source=$source projects=${LIVE_KEY_PROJECTS[$lookup_key]}"
    if [[ "$FAIL_ON_AMBIGUOUS" == "true" ]]; then
      echo "FAIL: $msg"
      echo "  fix: add explicit route in $RUNWAY_BINDING under key_overrides.$key"
      FAILURES=$((FAILURES + 1))
    else
      echo "WARN: $msg"
      WARNINGS=$((WARNINGS + 1))
    fi
    AMBIGUOUS_KEYS=$((AMBIGUOUS_KEYS + 1))
    return 0
  fi

  # Missing from expected project.
  local comp="$expected_project:$lookup_key"
  local has_expected="${LIVE_PROJECT_HAS_KEY[$comp]:-}"
  if [[ -z "$has_expected" ]]; then
    if [[ "$lookup_key" != "$key" ]]; then
      echo "FAIL: missing key=$key (lookup=$lookup_key) context=$context expected_project=$expected_project expected_path=$expected_path route=$source"
    else
      echo "FAIL: missing key=$key context=$context expected_project=$expected_project expected_path=$expected_path route=$source"
    fi
    echo "  fix: ./bin/ops cap run secrets.set.interactive $expected_project ${PROJECT_ENV[$expected_project]:-prod}"
    if [[ "$source" != policy.* && "$source" != contract.* ]]; then
      echo "  fix: register route in $RUNWAY_BINDING (key_overrides or stack_defaults/domain_defaults)"
      INFERRED_ROUTES=$((INFERRED_ROUTES + 1))
      UNREGISTERED_KEYS=$((UNREGISTERED_KEYS + 1))
      if [[ "$STRICT_UNREGISTERED" == "true" ]]; then
        FAILURES=$((FAILURES + 1))
      fi
    fi
    FAILURES=$((FAILURES + 1))
    return 0
  fi

  # Path check inside expected project.
  local observed_paths="${LIVE_PROJECT_KEY_PATHS[$comp]:-}"
  local path_ok=0
  IFS='|' read -r -a split_paths <<< "$observed_paths"
  for p in "${split_paths[@]}"; do
    [[ -n "$p" ]] || continue
    if [[ "$p" == "$expected_path" ]]; then
      path_ok=1
      break
    fi
  done

  if [[ "$expected_path" != "/" && "$path_ok" -eq 0 ]]; then
    echo "FAIL: wrong_path key=$key context=$context expected=$expected_project:$expected_path observed=$expected_project:${observed_paths} route=$source"
    FAILURES=$((FAILURES + 1))
    return 0
  fi

  # If route is inferred (not explicit), surface warning for runway hardening.
  if [[ "$source" != policy.* && "$source" != contract.* ]]; then
    INFERRED_ROUTES=$((INFERRED_ROUTES + 1))
    UNREGISTERED_KEYS=$((UNREGISTERED_KEYS + 1))
    if [[ "$STRICT_UNREGISTERED" == "true" ]]; then
      echo "FAIL: inferred_route key=$key context=$context resolved=$expected_project:$expected_path source=$source"
      echo "  fix: add explicit key_overrides.$key in $RUNWAY_BINDING"
      FAILURES=$((FAILURES + 1))
    else
      echo "WARN: inferred_route key=$key context=$context resolved=$expected_project:$expected_path source=$source"
      WARNINGS=$((WARNINGS + 1))
    fi
  else
    PASSES=$((PASSES + 1))
    echo "PASS: key=$key context=$context resolved=$expected_project:$expected_path source=$source"
  fi
}

# 1) Domain required keys.
DOMAIN_CHECKS=0
mapfile -t REQUIRED_DOMAINS < <(yq e -r '.required_domain_keys | keys | .[]?' "$RUNWAY_BINDING")
for domain in "${REQUIRED_DOMAINS[@]}"; do
  [[ -n "$domain" ]] || continue
  mapfile -t domain_keys < <(yq e -r ".required_domain_keys.\"$domain\".keys[]?" "$RUNWAY_BINDING")
  for key in "${domain_keys[@]}"; do
    [[ -n "$key" ]] || continue
    DOMAIN_CHECKS=$((DOMAIN_CHECKS + 1))
    check_key_route "$key" "domain:$domain" "" "$domain"
  done
done

# 2) Compose stack key extraction (remote) from docker.compose.targets.
TARGET_KEYS="$(yq -r '.targets | keys | .[]' "$COMPOSE_BINDING" 2>/dev/null || true)"
[[ -n "$TARGET_KEYS" ]] || { echo "STOP (2): no targets in $COMPOSE_BINDING"; exit 2; }

DEF_USER="$(yq -r '.ssh.defaults.user // "root"' "$SSH_BINDING")"
DEF_PORT="$(yq -r '.ssh.defaults.port // 22' "$SSH_BINDING")"
DEF_TO="$(yq -r '.ssh.defaults.connect_timeout_sec // 5' "$SSH_BINDING")"
DEF_BATCH="$(yq -r '.ssh.defaults.batch_mode // true' "$SSH_BINDING")"
DEF_STRICT="$(yq -r '.ssh.defaults.strict_host_key_checking // "no"' "$SSH_BINDING")"
DEF_KNOWN_HOSTS="$(yq -r '.ssh.defaults.user_known_hosts_file // "/dev/null"' "$SSH_BINDING")"

REMOTE_EXTRACT_SCRIPT="$(cat <<'EOS'
set -euo pipefail
PATHX="$1"
STACK_NAME="$2"

case "$PATHX" in
  "~/"*) PATHX="$HOME/${PATHX:2}" ;;
  "~") PATHX="$HOME" ;;
esac

if [[ ! -d "$PATHX" ]]; then
  echo "STACK_RESULT status=down reason=dir_missing stack=$STACK_NAME"
  echo "__KEYS_BEGIN__"
  echo "__KEYS_END__"
  exit 0
fi

cd "$PATHX"
FILE=""
if [[ -f docker-compose.yml ]]; then FILE="docker-compose.yml"; fi
if [[ -z "$FILE" && -f compose.yml ]]; then FILE="compose.yml"; fi
if [[ -z "$FILE" ]]; then
  echo "STACK_RESULT status=down reason=compose_missing stack=$STACK_NAME"
  echo "__KEYS_BEGIN__"
  echo "__KEYS_END__"
  exit 0
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "STACK_RESULT status=down reason=docker_cmd_missing stack=$STACK_NAME"
  echo "__KEYS_BEGIN__"
  echo "__KEYS_END__"
  exit 0
fi

DOCKER_CMD=(docker)
if ! docker info >/dev/null 2>&1; then
  if command -v sudo >/dev/null 2>&1 && sudo -n docker info >/dev/null 2>&1; then
    DOCKER_CMD=(sudo -n docker)
  else
    echo "STACK_RESULT status=down reason=docker_unreachable stack=$STACK_NAME"
    echo "__KEYS_BEGIN__"
    echo "__KEYS_END__"
    exit 0
  fi
fi

tmp_json="$(mktemp /tmp/compose_cfg.XXXXXX)"
trap 'rm -f "$tmp_json"' EXIT

if "${DOCKER_CMD[@]}" compose -f "$FILE" config --format json > "$tmp_json" 2>/dev/null; then
  if command -v python3 >/dev/null 2>&1; then
    echo "STACK_RESULT status=ok reason=none stack=$STACK_NAME"
    python3 - "$tmp_json" <<'PY'
import json,sys
p=sys.argv[1]
with open(p,"r",encoding="utf-8") as f:
    obj=json.load(f)
services=obj.get("services",{})
print("__KEYS_BEGIN__")
for svc in sorted(services.keys()):
    cfg=services.get(svc, {}) or {}
    env=cfg.get("environment", {})
    keys=[]
    if isinstance(env, dict):
        keys.extend(env.keys())
    elif isinstance(env, list):
        for item in env:
            if isinstance(item, str) and item:
                keys.append(item.split("=",1)[0])
    for k in sorted(set([x for x in keys if x])):
        print(f"{svc}\t{k}")
print("__KEYS_END__")
PY
    exit 0
  fi
fi

# Fallback: parse variable refs directly from compose file.
echo "STACK_RESULT status=degraded reason=config_json_failed stack=$STACK_NAME"
echo "__KEYS_BEGIN__"
grep -oE '\$\{[A-Za-z_][A-Za-z0-9_]*(:-[^}]*)?\}' "$FILE" 2>/dev/null \
  | sed -E 's/^\$\{([A-Za-z_][A-Za-z0-9_]*).*/\1/' \
  | sort -u \
  | while read -r k; do
      [[ -n "$k" ]] && printf "_compose_ref\t%s\n" "$k"
    done
echo "__KEYS_END__"
exit 0
EOS
)"

COMPOSE_STACKS=0
COMPOSE_KEYS=0

for target in $TARGET_KEYS; do
  if [[ -n "$TARGET_FILTER" && "$target" != "$TARGET_FILTER" ]]; then
    continue
  fi

  enabled="$(yq -r ".targets.\"$target\".enabled" "$COMPOSE_BINDING" 2>/dev/null || echo "null")"
  [[ -z "$enabled" || "$enabled" == "null" ]] && enabled="true"
  if [[ "$enabled" != "true" ]]; then
    echo "SKIP: target=$target reason=disabled"
    continue
  fi

  ssh_target_id="$(yq -r ".targets.\"$target\".ssh_target // \"\"" "$COMPOSE_BINDING")"
  [[ -n "$ssh_target_id" && "$ssh_target_id" != "null" ]] || { echo "FAIL: target=$target missing ssh_target"; FAILURES=$((FAILURES + 1)); continue; }

  ssh_host="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .host // \"\"" "$SSH_BINDING" | head -n1 || true)"
  ssh_user="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .user // \"\"" "$SSH_BINDING" | head -n1 || true)"
  ssh_port="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .port // ${DEF_PORT}" "$SSH_BINDING" | head -n1 || true)"
  ssh_to="$(yq -r ".ssh.targets[] | select(.id == \"$ssh_target_id\") | .connect_timeout_sec // ${DEF_TO}" "$SSH_BINDING" | head -n1 || true)"
  [[ -n "$ssh_host" && "$ssh_host" != "null" ]] || { echo "FAIL: ssh target '$ssh_target_id' missing host"; FAILURES=$((FAILURES + 1)); continue; }
  [[ -n "$ssh_user" && "$ssh_user" != "null" ]] || ssh_user="$DEF_USER"
  [[ -n "$ssh_port" && "$ssh_port" != "null" ]] || ssh_port="$DEF_PORT"
  [[ -n "$ssh_to" && "$ssh_to" != "null" ]] || ssh_to="$DEF_TO"

  ssh_opts=(
    -o "ConnectTimeout=$ssh_to"
    -o "StrictHostKeyChecking=$DEF_STRICT"
    -o "UserKnownHostsFile=$DEF_KNOWN_HOSTS"
    -o "NumberOfPasswordPrompts=0"
    -o "LogLevel=ERROR"
  )
  if [[ "$DEF_BATCH" == "true" ]]; then
    ssh_opts+=( -o "BatchMode=yes" )
  fi

  set +e
  probe_out="$(ssh "${ssh_opts[@]}" -p "$ssh_port" "${ssh_user}@${ssh_host}" "true" 2>&1)"
  probe_rc=$?
  set -e
  if [[ "$probe_rc" -ne 0 ]]; then
    reason="$(_classify_ssh_error "$probe_out")"
    echo "FAIL: target=$target ssh=${ssh_user}@${ssh_host}:${ssh_port} reason=$reason"
    UNREACHABLE_STACKS=$((UNREACHABLE_STACKS + 1))
    if [[ "$STRICT_UNREACHABLE" == "true" ]]; then
      FAILURES=$((FAILURES + 1))
    else
      WARNINGS=$((WARNINGS + 1))
    fi
    continue
  fi

  stack_count="$(yq -r ".targets.\"$target\".stacks | length" "$COMPOSE_BINDING" 2>/dev/null || echo 0)"
  if [[ "$stack_count" -le 0 ]]; then
    echo "SKIP: target=$target has no stacks"
    continue
  fi

  for i in $(seq 0 $((stack_count-1))); do
    stack_name="$(yq -r ".targets.\"$target\".stacks[$i].name" "$COMPOSE_BINDING")"
    stack_path="$(yq -r ".targets.\"$target\".stacks[$i].path" "$COMPOSE_BINDING")"
    [[ -n "$stack_name" && "$stack_name" != "null" ]] || continue
    [[ -n "$stack_path" && "$stack_path" != "null" ]] || continue

    COMPOSE_STACKS=$((COMPOSE_STACKS + 1))

    set +e
    # Use non-login shell to preserve remote command exit semantics; some hosts
    # return non-zero for `bash -lc` despite successful command output.
    extract_out="$(ssh "${ssh_opts[@]}" -p "$ssh_port" "${ssh_user}@${ssh_host}" "bash -c $(printf %q "$REMOTE_EXTRACT_SCRIPT") -- $(printf %q "$stack_path") $(printf %q "$stack_name")" 2>&1)"
    extract_rc=$?
    set -e

    result_line="$(echo "$extract_out" | rg '^STACK_RESULT ' -m1 || true)"
    if [[ "$extract_rc" -ne 0 && -z "$result_line" ]]; then
      reason="$(_classify_ssh_error "$extract_out")"
      UNREACHABLE_STACKS=$((UNREACHABLE_STACKS + 1))
      if [[ "$STRICT_UNREACHABLE" == "true" ]]; then
        echo "FAIL: stack=$target/$stack_name reason=$reason"
        FAILURES=$((FAILURES + 1))
      else
        echo "WARN: stack=$target/$stack_name reason=$reason"
        WARNINGS=$((WARNINGS + 1))
      fi
      continue
    fi

    status="$(echo "$result_line" | sed -n 's/.*status=\([^ ]*\).*/\1/p')"
    reason="$(echo "$result_line" | sed -n 's/.*reason=\([^ ]*\).*/\1/p')"

    if [[ "$status" == "down" ]]; then
      if [[ "$STRICT_UNREACHABLE" == "true" ]]; then
        echo "FAIL: stack=$target/$stack_name status=down reason=$reason"
        FAILURES=$((FAILURES + 1))
      else
        echo "WARN: stack=$target/$stack_name status=down reason=$reason"
        WARNINGS=$((WARNINGS + 1))
      fi
      UNREACHABLE_STACKS=$((UNREACHABLE_STACKS + 1))
      continue
    fi

    if [[ "$status" == "degraded" ]]; then
      echo "WARN: stack=$target/$stack_name status=degraded reason=$reason"
      WARNINGS=$((WARNINGS + 1))
    fi

    # Deduplicate per stack/key to avoid repeated service noise.
    declare -A SEEN_STACK_KEY=()
    while IFS=$'\t' read -r service key; do
      [[ -n "$key" ]] || continue
      if ! is_secret_like "$key"; then
        continue
      fi
      uniq_key="$stack_name:$key"
      [[ -n "${SEEN_STACK_KEY[$uniq_key]:-}" ]] && continue
      SEEN_STACK_KEY["$uniq_key"]=1

      COMPOSE_KEYS=$((COMPOSE_KEYS + 1))
      check_key_route "$key" "stack:$target/$stack_name/$service" "$stack_name" ""
    done < <(
      echo "$extract_out" | awk '
        /^__KEYS_BEGIN__$/ {in_block=1; next}
        /^__KEYS_END__$/ {in_block=0}
        in_block {print}
      '
    )
  done
done

if [[ -n "$TARGET_FILTER" ]]; then
  if ! echo "$TARGET_KEYS" | grep -qx "$TARGET_FILTER"; then
    echo "STOP (2): target not found in binding: $TARGET_FILTER"
    exit 2
  fi
fi

# Report auth fetch issues for project inventories.
if [[ "${#auth_fail_projects[@]}" -gt 0 ]]; then
  for p in "${auth_fail_projects[@]}"; do
    echo "WARN: could not fetch live inventory for project=$p"
    WARNINGS=$((WARNINGS + 1))
  done
fi

echo
echo "secrets.runway.status"
echo "runway_contract: $RUNWAY_BINDING"
echo "policy_binding: $POLICY_BINDING"
echo "inventory_binding: $INVENTORY_BINDING"
echo "compose_binding: $COMPOSE_BINDING"
echo "strict_unreachable: $STRICT_UNREACHABLE"
echo "strict_unregistered: $STRICT_UNREGISTERED"
echo "fail_on_ambiguous: $FAIL_ON_AMBIGUOUS"
echo "domain_checks: $DOMAIN_CHECKS"
echo "compose_stacks_scanned: $COMPOSE_STACKS"
echo "compose_secret_keys_checked: $COMPOSE_KEYS"
echo "checked_keys_total: $CHECKED_KEYS"
echo "passes: $PASSES"
echo "warnings: $WARNINGS"
echo "failures: $FAILURES"
echo "inferred_routes: $INFERRED_ROUTES"
echo "unregistered_keys: $UNREGISTERED_KEYS"
echo "ambiguous_keys: $AMBIGUOUS_KEYS"
echo "unreachable_stacks: $UNREACHABLE_STACKS"

if [[ "$FAILURES" -gt 0 ]]; then
  echo "status: FAIL"
  exit 1
fi

if [[ "$WARNINGS" -gt 0 ]]; then
  echo "status: WARN"
  exit 0
fi

echo "status: OK"
exit 0
