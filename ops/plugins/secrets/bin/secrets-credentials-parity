#!/usr/bin/env bash
set -euo pipefail

# secrets.credentials.parity â€” Prove Infisical credential file setup across declared nodes
#
# Contract:
# - Non-secret output only (no values printed).
# - Read-only (remote checks are `test/stat/grep -q` only).
# - Uses SSOT bindings:
#   - ops/bindings/secrets.credentials.parity.yaml
#   - ops/bindings/ssh.targets.yaml
#
# Exit codes:
#   0 OK   (all required targets pass)
#   1 FAIL (one or more required targets failed/unreachable/misconfigured)
#   2 STOP (missing bindings/deps)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"

PARITY_BINDING="$SPINE_ROOT/ops/bindings/secrets.credentials.parity.yaml"
SSH_BINDING="$SPINE_ROOT/ops/bindings/ssh.targets.yaml"
SECRETS_BINDING="$SPINE_ROOT/ops/bindings/secrets.binding.yaml"

stop() { echo "STOP (2): $*" >&2; exit 2; }

for dep in yq ssh grep stat; do
  command -v "$dep" >/dev/null 2>&1 || stop "missing dependency: $dep"
done

[[ -f "$PARITY_BINDING" ]] || stop "missing binding: $PARITY_BINDING"
[[ -f "$SSH_BINDING" ]] || stop "missing binding: $SSH_BINDING"
[[ -f "$SECRETS_BINDING" ]] || stop "missing binding: $SECRETS_BINDING"
yq e '.' "$PARITY_BINDING" >/dev/null 2>&1 || stop "invalid YAML: $PARITY_BINDING"
yq e '.' "$SSH_BINDING" >/dev/null 2>&1 || stop "invalid YAML: $SSH_BINDING"
yq e '.' "$SECRETS_BINDING" >/dev/null 2>&1 || stop "invalid YAML: $SECRETS_BINDING"

REL_PATH="$(yq -r '.credentials.relpath // ""' "$PARITY_BINDING")"
REQ_PERM="$(yq -r '.credentials.require_perm // ""' "$PARITY_BINDING")"
[[ -n "$REL_PATH" ]] || stop "binding missing credentials.relpath"
[[ -n "$REQ_PERM" ]] || stop "binding missing credentials.require_perm"

CANONICAL_INFISICAL_API_URL="$(yq -r '.infisical.api_url // ""' "$SECRETS_BINDING" 2>/dev/null || true)"

mapfile -t REQUIRED_EXPORTS < <(yq -r '.credentials.required_exports[]?' "$PARITY_BINDING" 2>/dev/null || true)
(( ${#REQUIRED_EXPORTS[@]} > 0 )) || stop "binding missing credentials.required_exports[]"

COUNT="$(yq -r '.targets | length' "$PARITY_BINDING" 2>/dev/null || echo "0")"
[[ "$COUNT" =~ ^[0-9]+$ ]] || stop "cannot parse targets length"
(( COUNT > 0 )) || stop "binding has no targets"

# SSH defaults
DEF_USER="$(yq -r '.ssh.defaults.user // "root"' "$SSH_BINDING")"
DEF_PORT="$(yq -r '.ssh.defaults.port // 22' "$SSH_BINDING")"
DEF_TO="$(yq -r '.ssh.defaults.connect_timeout_sec // 5' "$SSH_BINDING")"
DEF_BATCH="$(yq -r '.ssh.defaults.batch_mode // true' "$SSH_BINDING")"
DEF_STRICT="$(yq -r '.ssh.defaults.strict_host_key_checking // "no"' "$SSH_BINDING")"
DEF_KNOWN_HOSTS="$(yq -r '.ssh.defaults.user_known_hosts_file // "/dev/null"' "$SSH_BINDING")"

echo "secrets.credentials.parity"
echo "binding: $PARITY_BINDING"
echo "ssh_binding: $SSH_BINDING"
echo "cred_relpath: $REL_PATH"
echo "required_exports: ${REQUIRED_EXPORTS[*]}"
echo

check_creds_file() {
  local label="$1"
  local cred_file="$2"
  local prefix="$3" # printed prefix (local/ssh)

  if [[ ! -f "$cred_file" ]]; then
    echo "- ${prefix}: ${label} -> FAIL reason=missing_file path=${cred_file}"
    return 1
  fi

  local perm="unknown"
  if stat -f '%Lp' "$cred_file" >/dev/null 2>&1; then
    perm="$(stat -f '%Lp' "$cred_file" 2>/dev/null || echo unknown)"
  elif stat -c '%a' "$cred_file" >/dev/null 2>&1; then
    perm="$(stat -c '%a' "$cred_file" 2>/dev/null || echo unknown)"
  fi

  if [[ "$perm" != "$REQ_PERM" ]]; then
    echo "- ${prefix}: ${label} -> FAIL reason=bad_perm perm=${perm} expected=${REQ_PERM} path=${cred_file}"
    return 1
  fi

  local missing=()
  local name
  for name in "${REQUIRED_EXPORTS[@]}"; do
    [[ -n "${name:-}" && "$name" != "null" ]] || continue
    if ! grep -Eq "^[[:space:]]*(export[[:space:]]+)?${name}=" "$cred_file" 2>/dev/null; then
      missing+=("$name")
    fi
  done

  if (( ${#missing[@]} > 0 )); then
    echo "- ${prefix}: ${label} -> FAIL reason=missing_exports exports=${missing[*]} path=${cred_file}"
    if printf '%s\n' "${missing[@]}" | grep -qx "INFISICAL_API_URL" && [[ -n "${CANONICAL_INFISICAL_API_URL:-}" ]]; then
      echo "  fix: add: export INFISICAL_API_URL=\"${CANONICAL_INFISICAL_API_URL}\""
    fi
    return 1
  fi

  echo "- ${prefix}: ${label} -> OK perm=${perm} path=${cred_file}"
  return 0
}

ssh_check_target() {
  local id="$1"
  local required="$2" # true/false (from parity binding)

  # Locate target in ssh binding
  local host user port timeout access_method
  host="$(yq -r ".ssh.targets[] | select(.id == \"$id\") | .host // \"\"" "$SSH_BINDING" | head -n 1)"
  user="$(yq -r ".ssh.targets[] | select(.id == \"$id\") | .user // \"${DEF_USER}\"" "$SSH_BINDING" | head -n 1)"
  port="$(yq -r ".ssh.targets[] | select(.id == \"$id\") | .port // ${DEF_PORT}" "$SSH_BINDING" | head -n 1)"
  timeout="$(yq -r ".ssh.targets[] | select(.id == \"$id\") | .connect_timeout_sec // ${DEF_TO}" "$SSH_BINDING" | head -n 1)"
  access_method="$(yq -r ".ssh.targets[] | select(.id == \"$id\") | .access_method // \"ssh\"" "$SSH_BINDING" | head -n 1)"

  if [[ -z "$host" || "$host" == "null" ]]; then
    echo "- ssh: ${id} -> FAIL reason=host_unassigned required=${required}"
    return 1
  fi

  if [[ "$access_method" == "lan_only" ]]; then
    echo "- ssh: ${id} -> SKIP reason=lan_only required=${required}"
    return 0
  fi

  local ssh_opts=(
    -o "ConnectTimeout=${timeout}"
    -o "StrictHostKeyChecking=${DEF_STRICT}"
    -o "UserKnownHostsFile=${DEF_KNOWN_HOSTS}"
    -o "NumberOfPasswordPrompts=0"
    -o "LogLevel=ERROR"
  )
  if [[ "$DEF_BATCH" == "true" ]]; then
    ssh_opts+=(-o "BatchMode=yes")
  fi

  # Remote check (no output of file contents).
  #
  # NOTE: Avoid `set -euo pipefail` here. Some hosts run login hooks that can
  # produce surprising exit codes when `exit` is used under strict mode.
  local required_list
  required_list="$(printf '%s ' "${REQUIRED_EXPORTS[@]}")"
  remote_script="$(cat <<EOF
cred="\$HOME/$REL_PATH"
if [[ ! -f "\$cred" ]]; then
  echo "FAIL missing_file path=\$cred"
  exit 0
fi
perm="\$(stat -c "%a" "\$cred" 2>/dev/null || stat -f "%Lp" "\$cred" 2>/dev/null || echo unknown)"
if [[ "\$perm" != "$REQ_PERM" ]]; then
  echo "FAIL bad_perm perm=\$perm expected=$REQ_PERM path=\$cred"
  exit 0
fi
missing=""
for name in $required_list; do
  [[ -n "\$name" ]] || continue
  if ! grep -Eq "^[[:space:]]*(export[[:space:]]+)?\${name}=" "\$cred" 2>/dev/null; then
    missing="\${missing}\${name} "
  fi
done
if [[ -n "\$missing" ]]; then
  echo "FAIL missing_exports exports=\${missing% } path=\$cred"
  exit 0
fi
echo "OK perm=\$perm path=\$cred"
EOF
)"

  set +e
  out="$(ssh "${ssh_opts[@]}" -p "$port" "${user}@${host}" "bash -lc $(printf %q "$remote_script")" 2>&1)"
  rc=$?
  set -e

  out="$(echo "$out" | head -n 1 | tr -d '\r')"

  if [[ "$out" == OK* ]]; then
    echo "- ssh: ${id} (${user}@${host}:${port}) -> ${out}"
    return 0
  fi

  if [[ "$out" == FAIL* ]]; then
    echo "- ssh: ${id} (${user}@${host}:${port}) -> ${out} required=${required}"
    if [[ "$out" == *"missing_exports"* && "$out" == *"INFISICAL_API_URL"* && -n "${CANONICAL_INFISICAL_API_URL:-}" ]]; then
      echo "  fix: add: export INFISICAL_API_URL=\"${CANONICAL_INFISICAL_API_URL}\""
    fi
    return 1
  fi

  # Non-zero rc with no structured output: treat as SSH error.
  if [[ "$rc" -ne 0 ]]; then
    [[ -n "$out" ]] || out="ssh_failed"
    echo "- ssh: ${id} (${user}@${host}:${port}) -> FAIL reason=ssh_error msg=${out} required=${required}"
    return 1
  fi

  # rc==0 but unknown output
  [[ -n "$out" ]] || out="unknown"
  echo "- ssh: ${id} (${user}@${host}:${port}) -> FAIL reason=unexpected_output msg=${out} required=${required}"
  return 1
}

fail_required=0
fail_optional=0
ok=0
skipped=0

for i in $(seq 0 $((COUNT-1))); do
  id="$(yq -r ".targets[$i].id // \"\"" "$PARITY_BINDING")"
  required="$(yq -r ".targets[$i].required // false" "$PARITY_BINDING")"

  [[ -n "$id" && "$id" != "null" ]] || stop "invalid targets[$i].id in binding"

  if [[ "$id" == "local" ]]; then
    cred="${HOME}/${REL_PATH}"
    if check_creds_file "local" "$cred" "local"; then
      ok=$((ok + 1))
    else
      fail_required=$((fail_required + 1))
    fi
    continue
  fi

  if ssh_check_target "$id" "$required"; then
    ok=$((ok + 1))
  else
    if [[ "$required" == "true" ]]; then
      fail_required=$((fail_required + 1))
    else
      fail_optional=$((fail_optional + 1))
    fi
  fi
done

echo
echo "summary: ok=${ok} fail_required=${fail_required} fail_optional=${fail_optional} skipped=${skipped}"

if (( fail_required > 0 )); then
  echo "status: FAIL"
  exit 1
fi

if (( fail_optional > 0 )); then
  echo "status: OK (optional mismatches present)"
  exit 0
fi

echo "status: OK"
exit 0
