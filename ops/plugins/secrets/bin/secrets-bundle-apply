#!/usr/bin/env bash
# secrets-bundle-apply
#
# Canonical CLI-first secret bundle rotation + verification.
# - Writes bundle keys to canonical project/path via Infisical agent.
# - Verifies endpoint auth health with canonical keys.
# - Detects legacy/deprecated project shadow copies that can trip agents.
# - Optional local .env sync for domain toolchains.
#
# No secret values are printed.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPINE_ROOT="${SPINE_ROOT:-$(cd "$SCRIPT_DIR/../../../.." && pwd)}"

CONTRACT="$SPINE_ROOT/ops/bindings/secrets.bundle.contract.yaml"
NAMESPACE_POLICY="$SPINE_ROOT/ops/bindings/secrets.namespace.policy.yaml"
SECRETS_INVENTORY="$SPINE_ROOT/ops/bindings/secrets.inventory.yaml"
INFISICAL_AGENT="$SPINE_ROOT/ops/tools/infisical-agent.sh"

BUNDLE_ID=""
VERIFY_ONLY=0
SYNC_LOCAL_ENV=0
FAIL_ON_LEGACY_SHADOW=0
INPUT_MODE=""
INPUT_ARG=""

usage() {
  cat <<'EOF'
secrets.bundle.apply

Usage:
  secrets-bundle-apply <bundle_id> [--json-file <path> | --json-stdin | --clipboard] [--sync-local-env] [--fail-on-legacy-shadow]
  secrets-bundle-apply --verify-only <bundle_id> [--sync-local-env] [--fail-on-legacy-shadow]

Examples:
  # Apply finance tokens from clipboard JSON:
  # {"FIREFLY_ACCESS_TOKEN":"...","PAPERLESS_API_TOKEN":"..."}
  secrets-bundle-apply finance --clipboard --sync-local-env

  # Verify only (no writes):
  secrets-bundle-apply --verify-only finance
EOF
}

STOP() {
  echo "STOP (2): $*" >&2
  exit 2
}

FAIL() {
  echo "FAIL: $*" >&2
  exit 1
}

PASS() {
  echo "PASS: $*"
}

WARN() {
  echo "WARN: $*"
}

normalize_path() {
  local p="${1:-/}"
  if [[ -z "$p" || "$p" == "/" ]]; then
    echo "/"
  else
    p="${p%/}"
    echo "$p"
  fi
}

upsert_env_key() {
  local file="$1"
  local key="$2"
  local value="$3"
  python3 - "$file" "$key" "$value" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
key = sys.argv[2]
value = sys.argv[3]
line = f"{key}={value}"

if path.exists():
    lines = path.read_text(encoding="utf-8").splitlines()
else:
    lines = []

written = False
out = []
for item in lines:
    if item.startswith(f"{key}="):
        out.append(line)
        written = True
    else:
        out.append(item)

if not written:
    out.append(line)

path.parent.mkdir(parents=True, exist_ok=True)
path.write_text("\n".join(out).rstrip("\n") + "\n", encoding="utf-8")
PY
}

project_health_from_inventory() {
  local project="$1"
  if [[ ! -f "$SECRETS_INVENTORY" ]]; then
    echo ""
    return 0
  fi
  yq e -r ".projects[]? | select(.name == \"${project}\") | .project_health // \"\"" "$SECRETS_INVENTORY" 2>/dev/null | head -n1
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --verify-only)
      VERIFY_ONLY=1
      shift
      ;;
    --sync-local-env)
      SYNC_LOCAL_ENV=1
      shift
      ;;
    --fail-on-legacy-shadow)
      FAIL_ON_LEGACY_SHADOW=1
      shift
      ;;
    --json-file)
      [[ -z "${2:-}" ]] && STOP "--json-file requires a path"
      INPUT_MODE="file"
      INPUT_ARG="$2"
      shift 2
      ;;
    --json-stdin)
      INPUT_MODE="stdin"
      shift
      ;;
    --clipboard)
      INPUT_MODE="clipboard"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -*)
      STOP "unknown arg: $1"
      ;;
    *)
      if [[ -z "$BUNDLE_ID" ]]; then
        BUNDLE_ID="$1"
      else
        STOP "unexpected positional arg: $1"
      fi
      shift
      ;;
  esac
done

[[ -n "$BUNDLE_ID" ]] || STOP "bundle_id is required"
[[ -f "$CONTRACT" ]] || STOP "missing contract: $CONTRACT"
[[ -x "$INFISICAL_AGENT" ]] || STOP "missing executable: $INFISICAL_AGENT"
command -v yq >/dev/null 2>&1 || STOP "missing dependency: yq"
command -v jq >/dev/null 2>&1 || STOP "missing dependency: jq"
command -v curl >/dev/null 2>&1 || STOP "missing dependency: curl"
command -v python3 >/dev/null 2>&1 || STOP "missing dependency: python3"

BUNDLE_EXPR=".bundles.\"${BUNDLE_ID}\""
exists="$(yq e -r "${BUNDLE_EXPR} != null" "$CONTRACT" 2>/dev/null || true)"
[[ "$exists" == "true" ]] || FAIL "unknown bundle: $BUNDLE_ID"

PROJECT="$(yq e -r "${BUNDLE_EXPR}.project // \"\"" "$CONTRACT")"
ENV_NAME="$(yq e -r "${BUNDLE_EXPR}.environment // \"prod\"" "$CONTRACT")"
[[ -n "$PROJECT" ]] || FAIL "bundle ${BUNDLE_ID} missing project"
[[ -n "$ENV_NAME" ]] || FAIL "bundle ${BUNDLE_ID} missing environment"

bundle_project_health="$(project_health_from_inventory "$PROJECT")"
if [[ "$bundle_project_health" == "deprecated" || "$bundle_project_health" == "overlaps" || "$bundle_project_health" == "delete_candidate" ]]; then
  FAIL "bundle project is non-canonical for writes: project=${PROJECT} project_health=${bundle_project_health}"
fi

declare -a KEY_NAMES=()
declare -a KEY_PATHS=()
declare -A KEY_PATH_BY_NAME=()
while IFS=$'\t' read -r name path; do
  [[ -n "$name" && -n "$path" ]] || continue
  normalized_path="$(normalize_path "$path")"
  KEY_NAMES+=("$name")
  KEY_PATHS+=("$normalized_path")
  KEY_PATH_BY_NAME["$name"]="$normalized_path"
done < <(yq e -r "${BUNDLE_EXPR}.keys[]? | [.name, .path] | @tsv" "$CONTRACT")

[[ "${#KEY_NAMES[@]}" -gt 0 ]] || FAIL "bundle ${BUNDLE_ID} has no keys"

# Route lock: when using infrastructure/prod, key_path_overrides must agree
# with bundle contract so set operations land in the canonical namespace.
if [[ "$PROJECT" == "infrastructure" && "$ENV_NAME" == "prod" && -f "$NAMESPACE_POLICY" ]]; then
  for idx in "${!KEY_NAMES[@]}"; do
    key="${KEY_NAMES[$idx]}"
    expected_path="${KEY_PATHS[$idx]}"
    [[ "$expected_path" == "/" ]] && continue
    policy_path="$(KEY="$key" yq e -r '.rules.key_path_overrides[env(KEY)] // ""' "$NAMESPACE_POLICY" 2>/dev/null || true)"
    policy_path="$(normalize_path "$policy_path")"
    if [[ -z "$policy_path" || "$policy_path" == "/" ]]; then
      FAIL "missing key_path_override for ${key} (expected ${expected_path})"
    fi
    if [[ "$policy_path" != "$expected_path" ]]; then
      FAIL "path mismatch for ${key}: policy=${policy_path} bundle=${expected_path}"
    fi
  done
fi

PAYLOAD_JSON=""
if [[ "$VERIFY_ONLY" -eq 0 ]]; then
  case "$INPUT_MODE" in
    file)
      [[ -f "$INPUT_ARG" ]] || FAIL "json file not found: $INPUT_ARG"
      PAYLOAD_JSON="$(cat "$INPUT_ARG")"
      ;;
    stdin)
      PAYLOAD_JSON="$(cat)"
      ;;
    clipboard)
      command -v pbpaste >/dev/null 2>&1 || STOP "pbpaste not available; use --json-file or --json-stdin"
      PAYLOAD_JSON="$(pbpaste)"
      ;;
    *)
      FAIL "input required: use --json-file, --json-stdin, or --clipboard (or --verify-only)"
      ;;
  esac

  echo "$PAYLOAD_JSON" | jq -e 'type == "object"' >/dev/null 2>&1 || FAIL "input must be a JSON object"
fi

PASS "bundle=${BUNDLE_ID} project=${PROJECT} env=${ENV_NAME} mode=$([[ "$VERIFY_ONLY" -eq 1 ]] && echo verify || echo apply)"

apply_count=0
if [[ "$VERIFY_ONLY" -eq 0 ]]; then
  for key in "${KEY_NAMES[@]}"; do
    value="$(echo "$PAYLOAD_JSON" | jq -r --arg k "$key" '.[$k] // ""')"
    [[ -n "$value" ]] || FAIL "missing input value for key=${key}"

    if ! "$INFISICAL_AGENT" set "$PROJECT" "$ENV_NAME" "$key" "$value" >/dev/null 2>&1; then
      FAIL "failed to set key=${key} in ${PROJECT}/${ENV_NAME}"
    fi

    readback="$("$INFISICAL_AGENT" get "$PROJECT" "$ENV_NAME" "$key" 2>/dev/null || true)"
    [[ -n "$readback" ]] || FAIL "canonical readback empty for key=${key}"
    if [[ "$readback" != "$value" ]]; then
      FAIL "readback mismatch for key=${key}"
    fi

    route_path="${KEY_PATH_BY_NAME[$key]:-/}"
    PASS "set key=${key} route=${PROJECT}:${route_path}"
    apply_count=$((apply_count + 1))
  done
fi

verify_count=0
while IFS=$'\t' read -r check_id check_type check_key check_url check_expect check_exchange_url; do
  [[ -n "$check_id" && -n "$check_type" && -n "$check_url" && -n "$check_expect" ]] || continue

  auth_header=""
  case "$check_type" in
    none)
      # No authentication â€” plain HTTP probe
      ;;
    bearer|token)
      [[ -n "$check_key" ]] || FAIL "verify=${check_id}: key required for type=${check_type}"
      token="$("$INFISICAL_AGENT" get "$PROJECT" "$ENV_NAME" "$check_key" 2>/dev/null || true)"
      [[ -n "$token" ]] || FAIL "verification key empty: ${check_key}"
      if [[ "$check_type" == "bearer" ]]; then
        auth_header="Authorization: Bearer ${token}"
      else
        auth_header="Authorization: Token ${token}"
      fi
      ;;
    security_token_exchange)
      [[ -n "$check_key" ]] || FAIL "verify=${check_id}: key required for type=${check_type}"
      [[ -n "$check_exchange_url" ]] || FAIL "verify=${check_id}: exchange_url required for type=${check_type}"
      token="$("$INFISICAL_AGENT" get "$PROJECT" "$ENV_NAME" "$check_key" 2>/dev/null || true)"
      [[ -n "$token" ]] || FAIL "verification key empty: ${check_key}"
      exchange_response="$(curl -sS --connect-timeout 10 --max-time 25 -X POST \
        -H 'Content-Type: application/json' \
        --data "$(jq -cn --arg token "$token" '{accessToken:$token}')" \
        "$check_exchange_url" 2>/dev/null || true)"
      [[ -n "$exchange_response" ]] || FAIL "verify=${check_id}: exchange returned empty response"
      exchange_token="$(jq -r '.token // .jwt // .authToken // .accessToken // .access_token // .data.token // .data.jwt // ""' <<<"$exchange_response" 2>/dev/null || true)"
      [[ -n "$exchange_token" && "$exchange_token" != "null" ]] || FAIL "verify=${check_id}: exchange token missing"
      auth_header="Authorization: Bearer ${exchange_token}"
      ;;
    *)
      FAIL "unsupported verify type: ${check_type}"
      ;;
  esac

  if [[ -n "$auth_header" ]]; then
    http_code="$(curl -sS -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 25 -H "$auth_header" "$check_url" 2>/dev/null || true)"
  else
    http_code="$(curl -sS -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 25 "$check_url" 2>/dev/null || true)"
  fi
  [[ -n "$http_code" ]] || http_code="000"
  if [[ "$http_code" != "$check_expect" ]]; then
    FAIL "verify=${check_id} expected_http=${check_expect} actual_http=${http_code}"
  fi
  PASS "verify=${check_id} http=${http_code}"
  verify_count=$((verify_count + 1))
done < <(yq e -r "${BUNDLE_EXPR}.verify[]? | [.id, .type, (.key // \"\"), .url, (.expect_http | tostring), (.exchange_url // \"\")] | @tsv" "$CONTRACT")

if [[ "$SYNC_LOCAL_ENV" -eq 1 ]]; then
  env_file="$(yq e -r "${BUNDLE_EXPR}.local_env.file // \"\"" "$CONTRACT")"
  [[ -n "$env_file" ]] || FAIL "bundle ${BUNDLE_ID} has no local_env.file"

  while IFS=$'\t' read -r static_key static_val; do
    [[ -n "$static_key" ]] || continue
    upsert_env_key "$env_file" "$static_key" "$static_val"
  done < <(yq e -r "${BUNDLE_EXPR}.local_env.static | to_entries[]? | [.key, .value] | @tsv" "$CONTRACT")

  while IFS= read -r secret_key; do
    [[ -n "$secret_key" ]] || continue
    secret_val="$("$INFISICAL_AGENT" get "$PROJECT" "$ENV_NAME" "$secret_key" 2>/dev/null || true)"
    [[ -n "$secret_val" ]] || FAIL "local env sync missing secret=${secret_key}"
    upsert_env_key "$env_file" "$secret_key" "$secret_val"
  done < <(yq e -r "${BUNDLE_EXPR}.local_env.secret_keys[]?" "$CONTRACT" 2>/dev/null | sed '/^null$/d')

  chmod 600 "$env_file" 2>/dev/null || true
  PASS "local_env_synced file=${env_file}"
fi

legacy_shadow_count=0
declare -a LEGACY_PROJECTS=()
while IFS= read -r project_name; do
  [[ -n "$project_name" ]] || continue
  LEGACY_PROJECTS+=("$project_name")
done < <(yq e -r "${BUNDLE_EXPR}.legacy_projects[]?" "$CONTRACT" 2>/dev/null | sed '/^null$/d')

if [[ "${#LEGACY_PROJECTS[@]}" -eq 0 ]]; then
  while IFS= read -r project_name; do
    [[ -n "$project_name" ]] || continue
    LEGACY_PROJECTS+=("$project_name")
  done < <(yq e -r '.defaults.deprecated_projects[]?' "$CONTRACT" 2>/dev/null | sed '/^null$/d')
fi

if [[ "${#LEGACY_PROJECTS[@]}" -eq 0 && -f "$SECRETS_INVENTORY" ]]; then
  while IFS= read -r project_name; do
    [[ -n "$project_name" ]] || continue
    LEGACY_PROJECTS+=("$project_name")
  done < <(yq e -r '.projects[]? | select(.project_health == "deprecated" or .project_health == "overlaps" or .project_health == "delete_candidate") | .name' "$SECRETS_INVENTORY" 2>/dev/null | sed '/^null$/d')
fi

for legacy_project in "${LEGACY_PROJECTS[@]}"; do
  legacy_json="$("$INFISICAL_AGENT" list-recursive "$legacy_project" "$ENV_NAME" 2>/dev/null || true)"
  if ! echo "$legacy_json" | jq -e '.secrets' >/dev/null 2>&1; then
    WARN "legacy_scan_unavailable project=${legacy_project}"
    continue
  fi

  for key in "${KEY_NAMES[@]}"; do
    while IFS= read -r shadow_path; do
      [[ -n "$shadow_path" ]] || continue
      shadow_path="$(normalize_path "$shadow_path")"
      WARN "legacy_shadow key=${key} project=${legacy_project} path=${shadow_path}"
      legacy_shadow_count=$((legacy_shadow_count + 1))
    done < <(echo "$legacy_json" | jq -r --arg k "$key" '.secrets[]? | select(.secretKey == $k) | (.secretPath // "/")')
  done
done

if [[ "$legacy_shadow_count" -gt 0 && "$FAIL_ON_LEGACY_SHADOW" -eq 1 ]]; then
  FAIL "legacy_shadow_count=${legacy_shadow_count}"
fi

PASS "complete bundle=${BUNDLE_ID} applied=${apply_count} verified=${verify_count} legacy_shadows=${legacy_shadow_count}"
