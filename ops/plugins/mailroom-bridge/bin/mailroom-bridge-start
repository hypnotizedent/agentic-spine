#!/usr/bin/env bash
set -euo pipefail

SPINE_REPO="${SPINE_REPO:-$HOME/code/agentic-spine}"
SPINE_CODE="${SPINE_CODE:-$SPINE_REPO}"

STATE_DIR="${SPINE_STATE:-$SPINE_REPO/mailroom/state}"
LOG_DIR="${SPINE_LOGS:-$SPINE_REPO/mailroom/logs}"

PID_FILE="${STATE_DIR}/mailroom-bridge.pid"
OUT_LOG="${LOG_DIR}/mailroom-bridge.out"
ERR_LOG="${LOG_DIR}/mailroom-bridge.err"

SERVE="${SPINE_CODE}/ops/plugins/mailroom-bridge/bin/mailroom-bridge-serve"
BINDING="${SPINE_REPO}/ops/bindings/mailroom.bridge.yaml"

LABEL="com.ronny.mailroom-bridge"
PLIST="$HOME/Library/LaunchAgents/${LABEL}.plist"

mkdir -p "$STATE_DIR" "$LOG_DIR"

if [[ ! -x "$SERVE" ]]; then
  echo "ERROR: serve script not executable: $SERVE"
  exit 1
fi
if [[ ! -f "$BINDING" ]]; then
  echo "ERROR: missing binding: $BINDING"
  exit 1
fi

host="127.0.0.1"
port="8799"
token_env="MAILROOM_BRIDGE_TOKEN"
require_token="false"
if command -v yq >/dev/null 2>&1; then
  host="$(yq -r '.listen.host // "127.0.0.1"' "$BINDING" 2>/dev/null || echo "127.0.0.1")"
  port="$(yq -r '.listen.port // 8799' "$BINDING" 2>/dev/null || echo "8799")"
  token_env="$(yq -r '.auth.token_env // "MAILROOM_BRIDGE_TOKEN"' "$BINDING" 2>/dev/null || echo "MAILROOM_BRIDGE_TOKEN")"
  require_token="$(yq -r '.auth.require_token // false' "$BINDING" 2>/dev/null || echo "false")"
fi
token_file="${STATE_DIR}/mailroom-bridge.token"
token_value="${!token_env:-}"
if [[ -z "$token_value" && -f "$token_file" ]]; then
  token_value="$(tr -d '\r\n' < "$token_file" 2>/dev/null || true)"
fi

if [[ "$require_token" == "true" && -z "$token_value" ]]; then
  if command -v openssl >/dev/null 2>&1; then
    token_value="$(openssl rand -hex 24)"
  elif command -v python3 >/dev/null 2>&1; then
    token_value="$(python3 - <<'PY'
import secrets
print(secrets.token_hex(24))
PY
)"
  fi
  if [[ -n "$token_value" ]]; then
    printf '%s\n' "$token_value" > "$token_file"
    chmod 600 "$token_file" 2>/dev/null || true
    echo "TOKEN_GENERATED: ${token_file}"
  fi
fi
if [[ "$require_token" == "true" && -z "$token_value" ]]; then
  echo "STOP (2): auth.require_token=true but no token is available (${token_env} or ${token_file})"
  exit 2
fi
if [[ -n "$token_value" ]]; then
  printf '%s\n' "$token_value" > "$token_file"
  chmod 600 "$token_file" 2>/dev/null || true
fi

extra_env=""
if [[ -n "$token_value" ]]; then
  extra_env=$(cat <<EOF
      <key>${token_env}</key>
      <string>${token_value}</string>
EOF
)
fi

# Inject RBAC role tokens into plist EnvironmentVariables
if command -v yq >/dev/null 2>&1; then
  role_envs="$(yq -r '.cap_rpc.roles[].token_env' "$BINDING" 2>/dev/null || true)"
  for role_env in $role_envs; do
    # Skip the primary token (already handled above)
    [[ "$role_env" == "$token_env" ]] && continue
    role_val="${!role_env:-}"
    # Try state file fallback.
    #
    # Convention:
    #   MAILROOM_BRIDGE_MONITOR_TOKEN -> mailroom-bridge-monitor.token
    #   MAILROOM_BRIDGE_MEDIA_TOKEN   -> mailroom-bridge-media.token
    if [[ -z "$role_val" ]]; then
      if [[ "$role_env" =~ ^MAILROOM_BRIDGE_(.+)_TOKEN$ ]]; then
        role_slug="${BASH_REMATCH[1]}"
        role_slug="$(printf '%s' "$role_slug" | tr '[:upper:]' '[:lower:]' | tr '_' '-')"
        role_file="${STATE_DIR}/mailroom-bridge-${role_slug}.token"
        if [[ -f "$role_file" ]]; then
          role_val="$(tr -d '\r\n' < "$role_file" 2>/dev/null || true)"
        fi
      fi
    fi
    if [[ -n "$role_val" ]]; then
      extra_env+=$(cat <<EOF

      <key>${role_env}</key>
      <string>${role_val}</string>
EOF
)
      echo "RBAC_TOKEN_LOADED: ${role_env}"
    fi
  done
fi

if ! command -v launchctl >/dev/null 2>&1; then
  echo "STOP (2): launchctl required (macOS launchd)"
  exit 2
fi

plist_action="UPDATED"
if [[ ! -f "$PLIST" ]]; then
  plist_action="CREATED"
fi

mkdir -p "$(dirname "$PLIST")"
cat >"$PLIST" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>${LABEL}</string>

    <key>ProgramArguments</key>
    <array>
      <string>${SERVE}</string>
    </array>

    <key>WorkingDirectory</key>
    <string>${SPINE_REPO}</string>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <true/>

    <key>EnvironmentVariables</key>
    <dict>
      <key>SPINE_REPO</key>
      <string>${SPINE_REPO}</string>
      <key>PYTHONUNBUFFERED</key>
      <string>1</string>
      <key>PATH</key>
      <string>${HOME}/.local/bin:/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
${extra_env}
    </dict>

    <key>StandardOutPath</key>
    <string>${OUT_LOG}</string>
    <key>StandardErrorPath</key>
    <string>${ERR_LOG}</string>
  </dict>
</plist>
EOF
echo "PLIST_${plist_action}: ${PLIST}"

svc="$(launchctl list "$LABEL" 2>/dev/null || true)"
svc_pid="$(printf '%s\n' "$svc" | awk -F' = ' '/"PID"/ {gsub(/[^0-9]/,"",$2); print $2; exit}')"
if [[ -n "$svc_pid" ]] && command -v curl >/dev/null 2>&1; then
  if curl -fsS "http://${host}:${port}/health" >/dev/null 2>&1; then
    echo "ALREADY_RUNNING: pid=${svc_pid}"
    echo "HEALTH: http://${host}:${port}/health"
    echo "$svc_pid" >"$PID_FILE" 2>/dev/null || true
    exit 0
  fi
fi

echo "STARTING: ${LABEL} (${host}:${port})"
echo "LOGS:"
echo "  stdout: ${OUT_LOG}"
echo "  stderr: ${ERR_LOG}"

if [[ -n "$svc" ]]; then
  launchctl bootout "gui/$(id -u)" "$PLIST" 2>/dev/null || true
fi

launchctl bootstrap "gui/$(id -u)" "$PLIST"

svc_pid=""
for _ in {1..50}; do
  svc="$(launchctl list "$LABEL" 2>/dev/null || true)"
  svc_pid="$(printf '%s\n' "$svc" | awk -F' = ' '/"PID"/ {gsub(/[^0-9]/,"",$2); print $2; exit}')"
  [[ -n "$svc_pid" ]] && break
  sleep 0.1
done

if [[ -z "$svc_pid" ]]; then
  echo "ERROR: service did not start (no PID from launchctl)"
  tail -n 60 "$ERR_LOG" 2>/dev/null || true
  exit 1
fi

echo "$svc_pid" >"$PID_FILE" 2>/dev/null || true

if ! command -v curl >/dev/null 2>&1; then
  echo "STARTED: pid=${svc_pid} (curl not found; skipping /health probe)"
  exit 0
fi

health_url="http://${host}:${port}/health"
for _ in {1..50}; do
  if curl -fsS "$health_url" >/dev/null 2>&1; then
    echo "STARTED: pid=${svc_pid}"
    echo "HEALTH: ${health_url}"
    exit 0
  fi
  sleep 0.1
done

echo "ERROR: /health probe failed: ${health_url}"
tail -n 60 "$ERR_LOG" 2>/dev/null || true
exit 1
